{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-f58868b12116f2f5c12dc977878ee9a0c20bbb34",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/market/SecondaryMarketFactory.sol": "project/contracts/market/SecondaryMarketFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ERC20/IERC20.sol": {
        "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
      },
      "project/contracts/market/IntentHash.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport {IERC20} from \"../ERC20/IERC20.sol\";\n\n/**\n * @title Intent\n * @author Luzius Meisser, luzius@aktionariat.com\n * @author Murat Ögat, murat@aktionariat.com\n *\n * The struct to be signed for submitting orders to the TradeReactor contract and its hashing per EIP-712.\n */\n\nstruct Intent {\n\taddress owner;\n\taddress filler;\n\taddress tokenOut; // The ERC20 token sent out\n\tuint256 amountOut; // The maximum amount\n\taddress tokenIn; // The ERC20 token received\n\tuint256 amountIn; // The amount received in exchange for the maximum of the sent token\n\tuint256 creation; // timestamp at which the intent was created\n\tuint256 expiration; // timestamp at which the intent expires\n\tbytes data;\n}\n\nlibrary IntentHash {\n\tbytes32 internal constant INTENT_TYPE_HASH = keccak256(\"Intent(address owner,address filler,address tokenOut,uint256 amountOut,address tokenIn,uint256 amountIn,uint256 creation,uint256 expiration,bytes data)\");\n\n\tfunction hash(Intent calldata intent) internal pure returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tINTENT_TYPE_HASH,\n\t\t\t\t\tintent.owner,\n\t\t\t\t\tintent.filler,\n\t\t\t\t\tintent.tokenOut,\n\t\t\t\t\tintent.amountOut,\n\t\t\t\t\tintent.tokenIn,\n\t\t\t\t\tintent.amountIn,\n\t\t\t\t\tintent.creation,\n\t\t\t\t\tintent.expiration,\n\t\t\t\t\tkeccak256(intent.data)\n\t\t\t\t)\n\t\t\t);\n\t}\n}\n"
      },
      "project/contracts/market/IReactor.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport {Intent} from \"./IntentHash.sol\";\n\ninterface IReactor {\n\n    function verify(Intent calldata intent, bytes calldata sig) external view;\n    function signalIntent(Intent calldata intent, bytes calldata signature) external;\n    function getFilledAmount(Intent calldata intent) external view returns (uint256);\n    function verifyPriceMatch(Intent calldata buyerIntent, Intent calldata sellerIntent) external pure;\n    function getTotalExecutionPrice(Intent calldata buyerIntent, Intent calldata sellerIntent, uint256 tradedAmount) external pure returns (uint256);\n    function getBid(Intent calldata intent, uint256 amount) external pure returns (uint256);\n    function process(Intent calldata sellerIntent, bytes calldata sellerSig, Intent calldata buyerIntent, bytes calldata buyerSig, uint256 tradedAmount, uint256 totalFee) external;\n    function cancelIntent(Intent calldata intent) external;\n\n}"
      },
      "project/contracts/market/SecondaryMarket.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"../utils/Ownable.sol\";\nimport {IReactor} from \"./IReactor.sol\";\nimport {Intent, IntentHash} from \"./IntentHash.sol\";\n\n/**\n * @title SecondaryMarket\n * \n * @author Luzius Meisser, luzius@aktionariat.com\n * @author Murat Ögat, murat@aktionariat.com\n * \n * @notice This contract handles the secondary market transactions and is controlled by the issuer.\n * @notice It works together with a TradeReactor contract to verify and process trade intents.\n * @notice If a filler is specified when creating and signing an intent, only this contract can forward it to the reactor for processing.\n * @notice If a router is specified in this contract, only that address can call the process function to execute trades.\n * @notice This contract also collects and distributes trading fees, if any. \n*/\n\ncontract SecondaryMarket is Ownable {\n    using IntentHash for Intent;\n\n    // Version\n    // 1: initial version\n    uint16 public constant VERSION = 1;\n\n    uint16 public constant ALL = 10000;\n    address public constant LICENSE_FEE_RECIPIENT = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D;\n    uint256 public constant CANCELLED = type(uint256).max;\n\n    address public immutable CURRENCY;\n    address public immutable TOKEN;\n    address public immutable REACTOR; \n\n    event TradingFeeCollected(address currency, uint256 actualFee, address spreadRecipient, uint256 returnedSpread);\n    event TradingFeeWithdrawn(address currency, address target, uint256 amount);\n    event LicenseFeePaid(address currency, address target, uint256 amount);\n    event MarketStatusChanged(bool isOpen, uint256 timestamp);\n    event Trade(address indexed seller, address indexed buyer, bytes32 sellIntentHash, bytes32 buyIntentHash, address token, uint256 tokenAmount, address currency, uint256 currencyAmount, uint256 fees);\n\n    error LargerSpreadNeeded(uint256 feesCollected, uint256 requiredMinimum);\n    error WrongFiller();\n    error WrongTokens();\n    error WrongRouter(address expected, address actual);\n    error InvalidConfiguration();\n    error MarketClosed();\n    error AlreadyFilled();\n    error UserCancelled();\n\n\n    address public router; // null for any, 20B\n    uint16 public tradingFeeBips; // 2B\n    uint16 public licenseShare; // Share of the trading fee that goes to the router in bips\n    bool public isOpen;\n\n    constructor(address owner, address currency, address token, address _reactor, address _router) Ownable(owner) {\n        CURRENCY = currency;\n        TOKEN = token;\n        REACTOR = _reactor;\n        tradingFeeBips = 190; // default trading fee is 1.9%\n        licenseShare = 5000; // default license share is 50% of trading fee\n        router = _router;\n        isOpen = true;\n    }\n\n    //// ADMINISTRATION ////\n\n    /**\n     * Opens the market.\n     */\n    function open() onlyOwner external {\n        isOpen = true;\n        emit MarketStatusChanged(true, block.timestamp);\n    }\n\n    /**\n     * Closes the market.\n     */\n    function close() onlyOwner external {\n        isOpen = false;\n        emit MarketStatusChanged(false, block.timestamp);\n    }\n\n    /**\n     * Configures the permissible router or the null address for any.\n     * \n     * Having a trusted router helps with the prevention of front-running attacks as no\n     * one else can front the router with a different matching of the submitted orders.\n     */\n    function setRouter(address router_) onlyOwner external {\n        router = router_;\n    }\n\n    /**\n     * Configures the software license fee as agreed with the copyright owners.\n     */\n    function setLicenseFee(uint16 licenseShare_) onlyOwner external {\n        if (uint256(licenseShare_) > ALL) revert InvalidConfiguration();\n        licenseShare = licenseShare_;\n    }\n\n    function setTradingFee(uint16 tradingFeeBips_) onlyOwner external {\n        if (tradingFeeBips_ > 500) revert InvalidConfiguration(); // commit to never set it above 5%\n        tradingFeeBips = tradingFeeBips_;\n    }\n\n    //// TRADING ////\n\n    /**\n     * Create an order intent that can be signed by the owner.\n     */\n    function createBuyOrder(address owner, uint256 amountOut, uint256 amountIn, uint24 validitySeconds) public view returns (Intent memory) {\n        return Intent(owner, address(this), CURRENCY, amountOut, TOKEN, amountIn, block.timestamp, block.timestamp + validitySeconds, new bytes(0));\n    }\n\n    /**\n     * Create an order intent that can be signed by the owner.\n     * The tokenIn amount is reduced by the trading fee, which is always charged to the seller.\n     */\n    function createSellOrder(address owner, uint256 amountOut, uint256 amountIn, uint24 validitySeconds) public view returns (Intent memory) {\n        return Intent(owner, address(this), TOKEN, amountOut, CURRENCY, amountIn, block.timestamp, block.timestamp + validitySeconds, new bytes(0));\n    }\n\n    function getIntentHash(Intent calldata intent) external pure returns (bytes32) {\n        return intent.hash();\n    }\n\n    /**\n     * Stores an order in the Ethereum blockchain as a publicly readable event, so any allowed router\n     * can pick it up and execute it against another valid order.\n     * \n     * In case the owner configured a specific router to be used, it is usually better to send the\n     * order to the configured router directly through a suitable API. Note that all partially filled\n     * orders and all filled orders are publicly recorded on-chain anyway, so taking the direct\n     * transmission shortcut does not effectively preserve privacy.\n     * \n     * To invalidate an order, the owner must call the invalidateNonce function on the SignatureTransfer\n     * \n     * contract found in this.ROUTER().TRANSFER().\n     */\n    function placeOrder(Intent calldata intent, bytes calldata signature) external {\n        verifySignature(intent, signature);\n        IReactor(REACTOR).signalIntent(intent, signature);\n    }\n\n    /**\n     * Verify the signature of an order.\n     */\n    function verifySignature(Intent calldata intent, bytes calldata sig) public view {\n        if (intent.filler != address(this)) revert WrongFiller();\n        IReactor(REACTOR).verify(intent, sig);\n    }\n\n    /**\n     * Check if an order can be executed and if yes, returns the maximum amount of the tokenOut.\n     */\n    function validateOrder(Intent calldata intent, bytes calldata sig) external view returns (uint256 unfilled, uint256 balance, uint256 allowance) {\n        verifySignature(intent, sig);\n        require((intent.tokenOut == TOKEN && intent.tokenIn == CURRENCY) || (intent.tokenOut == CURRENCY && intent.tokenIn == TOKEN), WrongTokens());\n\n        balance = IERC20(intent.tokenOut).balanceOf(intent.owner);\n        allowance = IERC20(intent.tokenOut).allowance(intent.owner, REACTOR);\n\n        uint256 amountTokens = (intent.tokenOut == TOKEN) ? intent.amountOut : intent.amountIn;\n        uint256 alreadyFilled = IReactor(REACTOR).getFilledAmount(intent);\n        if (alreadyFilled == CANCELLED) revert UserCancelled();\n        if (amountTokens <= alreadyFilled) revert AlreadyFilled();\n        uint256 remaining = amountTokens - alreadyFilled;\n\n        return (remaining, balance, allowance);\n    }\n\n    /**\n     * Returns multiple order book entries for an array of intents, avoiding multiple calls.\n     * The returned numbers are to be used directly in the order book.\n     * Therefore, this function doesn't revert, it returns 0 for unexecutable entries instead.\n     */\n    function executableAmounts(Intent[] calldata intents) public view returns (uint256[] memory) {\n        uint256[] memory available = new uint256[](intents.length);\n        for (uint256 i = 0; i < intents.length; i++) {\n            available[i] = executableAmount(intents[i]);\n        }\n        return available;\n    }\n\n    /**\n     * Check if an order can be executed and if yes, returns the maximum amount in TOKENS that can be executed immediately.\n     * Considers the unfilled amount, and also the actual balance and allowance of the intent owner.\n     * This is useful for user interfaces to show how much can be traded right now.\n     * This function should never return zero. It should either revert or return a non-zero value.\n     */\n    function executableAmount(Intent calldata intent) public view returns (uint256) {\n        if (intent.tokenOut == TOKEN && intent.tokenIn == CURRENCY) {\n            return executableSellAmount(intent);\n        } else if (intent.tokenOut == CURRENCY && intent.tokenIn == TOKEN) {\n            return executableBuyAmount(intent);\n        } else {\n            revert WrongTokens();\n        }\n    }\n\n    /**\n     * Internal counterpart of getAvailableForExecution for selling.\n     * This is straightforward as we can directly check the token balance and allowance.\n     */\n    function executableSellAmount(Intent calldata intent) internal view returns (uint256) {\n        uint256 alreadyFilled = IReactor(REACTOR).getFilledAmount(intent);\n        uint256 balance = IERC20(intent.tokenOut).balanceOf(intent.owner);\n        uint256 allowance = IERC20(intent.tokenOut).allowance(intent.owner, REACTOR);\n\n        if (intent.amountOut <= alreadyFilled) return 0;\n\n        uint256 unfilled = intent.amountOut - alreadyFilled;\n        uint256 availableInWallet = (balance < allowance) ? balance : allowance;\n        uint256 finalAvailable = (unfilled < availableInWallet) ? unfilled : availableInWallet;\n\n        return finalAvailable;\n    }\n\n    /**\n     * Internal counterpart of getAvailableForExecution for buying.\n     * This is slightly more tricky, as we need to check balance/allowance in CURRENCY \n     * but return available amount in TOKENS, so getBid() is used to get the conversion rate.\n     */\n    function executableBuyAmount(Intent calldata intent) internal view returns (uint256) {\n        uint256 alreadyFilled = IReactor(REACTOR).getFilledAmount(intent);\n        uint256 bid = IReactor(REACTOR).getBid(intent, 1);\n        uint256 balanceInShares = IERC20(intent.tokenOut).balanceOf(intent.owner) / bid;\n        uint256 allowanceInShares = IERC20(intent.tokenOut).allowance(intent.owner, REACTOR) / bid;\n\n        if (intent.amountIn <= alreadyFilled) return 0;\n\n        uint256 unfilled = intent.amountIn - alreadyFilled;\n        uint256 availableInShares = (balanceInShares < allowanceInShares) ? balanceInShares : allowanceInShares;\n        uint256 finalAvailable = (unfilled < availableInShares) ? unfilled : availableInShares;\n\n        return finalAvailable;\n    }\n\n    /**\n     * Convenience method to check with 2 intents to get what can be executed right now.\n     * Takes into account unfilled amounts, balances and allowances of both sides.\n     * Also reverts if price is not matching, with OfferTooLow().\n     */\n    function executableTrade(Intent calldata sellerIntent, Intent calldata buyerIntent) external view returns (uint256) {\n        IReactor(REACTOR).verifyPriceMatch(buyerIntent, sellerIntent);\n        uint256 executableSell = executableSellAmount(sellerIntent);\n        uint256 executableBuy = executableBuyAmount(buyerIntent);\n        return (executableSell < executableBuy) ? executableSell : executableBuy;\n    }\n\n    function process(Intent calldata seller, bytes calldata sellerSig, Intent calldata buyer, bytes calldata buyerSig, uint256 tradedAmount) external {\n        if (!isOpen) revert MarketClosed();\n        if (router != address(0) && msg.sender != router) revert WrongRouter(msg.sender, router);\n\n        uint256 totalExecutionPrice = IReactor(REACTOR).getTotalExecutionPrice(buyer, seller, tradedAmount);\n        uint256 totalFee = totalExecutionPrice * tradingFeeBips / 10000;\n\n        IReactor(REACTOR).process(seller, sellerSig, buyer, buyerSig, tradedAmount, totalFee);\n        emit Trade(seller.owner, buyer.owner, seller.hash(), buyer.hash(), seller.tokenOut, tradedAmount, seller.tokenIn, totalExecutionPrice, totalFee);\n    }\n\n    function cancelIntent(Intent calldata intent) external {\n        if (msg.sender != router && msg.sender != owner) revert WrongRouter(msg.sender, router);\n        IReactor(REACTOR).cancelIntent(intent);\n    }\n\n    /**\n     * Withdraw the accumulated fees applying a 50/50 split between the two addresses.\n     * \n     * The assumption is that this can be used to collect accumulated trading fees and to pay license fees\n     * to Aktionariat in the same transaction for convenience.\n     */\n    function withdrawFees() external {\n        withdrawFees(CURRENCY, IERC20(CURRENCY).balanceOf(address(this)));\n    }\n\n    function withdrawFees(address currency, uint256 amount) public onlyOwner {\n        uint256 split = amount * licenseShare / 10000;\n        IERC20(currency).transfer(owner, amount - split); // rounded up\n        IERC20(currency).transfer(LICENSE_FEE_RECIPIENT, split); // rounded down\n        emit LicenseFeePaid(currency, LICENSE_FEE_RECIPIENT, split);\n    }\n\n}"
      },
      "project/contracts/market/SecondaryMarketFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./SecondaryMarket.sol\";\n\ncontract SecondaryMarketFactory {\n\n    bytes32 public constant SALT = bytes32(uint256(20251119));\n\n    event SecondaryMarketDeployed(address indexed owner, address market);\n\n    /**\n     * @notice Deploys a new SecondaryMarket contract using CREATE2\n     * @param owner The owner of the SecondaryMarket\n     * @param router The router address\n     * @return market The address of the deployed SecondaryMarket\n     */\n    function deploy(address owner, address currency, address token, address reactor, address router) external returns (address) {\n        SecondaryMarket market = new SecondaryMarket{salt: SALT}(owner, currency, token, reactor, router);\n        emit SecondaryMarketDeployed(owner, address(market));\n        return address(market);\n    }\n\n    /**\n     * @notice Predicts the address where a SecondaryMarket will be deployed\n     * @param owner The owner of the SecondaryMarket\n     * @param router The router address\n     * @return predicted The predicted deployment address\n     */\n    function predict(address owner, address currency, address token, address reactor, address router) external view returns (address predicted) {\n        bytes memory initCode = abi.encodePacked(type(SecondaryMarket).creationCode, abi.encode(owner, currency, token, reactor, router));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), SALT, keccak256(initCode)));\n        return address(uint160(uint256(hash)));\n    }\n\n    /**\n     * @notice Checks if a SecondaryMarket is already deployed at the predicted address\n     * @param owner The owner of the SecondaryMarket\n     * @param router The router address\n     * @return isDeployed True if a contract exists at the predicted address\n     */\n    function isDeployed(address owner, address currency, address token, address reactor, address router) external view returns (bool) {\n        address predictedAddress = this.predict(owner, currency, token, reactor, router);\n        uint32 size;\n        assembly {\n            size := extcodesize(predictedAddress)\n        }\n        return size > 0;\n    }\n}"
      },
      "project/contracts/utils/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error Ownable_NotOwner(address sender);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function _checkOwner() internal view {\n        if (msg.sender != owner) {\n            revert Ownable_NotOwner(msg.sender);\n        }\n    }\n}"
      }
    }
  }
}