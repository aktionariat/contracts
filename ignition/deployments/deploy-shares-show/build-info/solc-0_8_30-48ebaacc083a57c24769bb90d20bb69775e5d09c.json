{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-48ebaacc083a57c24769bb90d20bb69775e5d09c",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/utils/factory/TokenFactory.sol": "project/contracts/utils/factory/TokenFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@chainlink/contracts@1.5.0/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/proxy/Clones.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Arrays.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytesSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getStringSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(string[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Comparators.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Create2.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Panic.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/SlotDerivation.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/structs/EnumerableSet.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\nimport {Arrays} from \"../Arrays.sol\";\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n * - Set can be cleared (all elements removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * The following types are supported:\n *\n * - `bytes32` (`Bytes32Set`) since v3.3.0\n * - `address` (`AddressSet`) since v3.3.0\n * - `uint256` (`UintSet`) since v3.3.0\n * - `string` (`StringSet`) since v5.4.0\n * - `bytes` (`BytesSet`) since v5.4.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with set size. Developers should keep in mind that\n     * using it may render the function uncallable if the set grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function _clear(Set storage set) private {\n        uint256 len = _length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set, uint256 start, uint256 end) private view returns (bytes32[] memory) {\n        unchecked {\n            end = Math.min(end, _length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes32[] memory result = new bytes32[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32Set storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    struct StringSet {\n        // Storage of set values\n        string[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(string value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(StringSet storage set, string memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(StringSet storage set, string memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                string memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(StringSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(StringSet storage set, string memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(StringSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(StringSet storage set, uint256 index) internal view returns (string memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set) internal view returns (string[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set, uint256 start, uint256 end) internal view returns (string[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            string[] memory result = new string[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    struct BytesSet {\n        // Storage of set values\n        bytes[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(BytesSet storage set, bytes memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(BytesSet storage set, bytes memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(BytesSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(BytesSet storage set, bytes memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(BytesSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(BytesSet storage set, uint256 index) internal view returns (bytes memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set) internal view returns (bytes[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set, uint256 start, uint256 end) internal view returns (bytes[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes[] memory result = new bytes[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n}\n"
      },
      "project/contracts/brokerbot/IBrokerbot.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"../ERC20/IERC20Permit.sol\";\r\n\r\ninterface IBrokerbot {\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n  //////////////////////////////////////////////////////////////*/\r\n  error Brokerbot_BuyingDisabled();\r\n  error Brokerbot_SellingDisabled();\r\n  /// Sender(msg.sender) has to be incoming token or paymenthub.\r\n  /// @param sender The msg.sender.\r\n  error Brokerbot_InvalidSender(address sender);\r\n  /// target.call() wasn't successful.\r\n  /// @param target The receiver of the Eth.\r\n  /// @param amount The withdraw amount.\r\n  error Brokerbot_WithdrawFailed(address target, uint256 amount);\r\n  /// Sender(msg.sender) needs to be owner or paymenthub.\r\n  /// @param sender The msg.sender.\r\n  error Brokerbot_NotAuthorized(address sender);\r\n\r\n  function paymenthub() external view returns (address);\r\n\r\n  function base() external view returns (IERC20);\r\n\r\n  function token() external view returns (IERC20Permit);\r\n  \r\n  function settings() external view returns (uint256);\r\n\r\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\r\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\r\n\r\n  function getBuyPrice(uint256 shares) external view returns (uint256);\r\n\r\n  function getSellPrice(uint256 shares) external view returns (uint256);\r\n\r\n}"
      },
      "project/contracts/brokerbot/IUniswapV3.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// Copied from \r\n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\r\n// https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\n\r\ninterface IQuoter {\r\n\r\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param fee The fee of the token pool to consider for the pair\r\n    /// @param amountOut The desired output amount\r\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\r\n    function quoteExactOutputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountOut,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountIn);\r\n\r\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\r\n    /// @param amountOut The amount of the last token to receive\r\n    /// @return amountIn The amount of first token required to be paid\r\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\r\n\r\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\r\n    /// @param amountIn The amount of the first token to swap\r\n    /// @return amountOut The amount of the last token that would be received\r\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\r\n\r\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param fee The fee of the token pool to consider for the pair\r\n    /// @param amountIn The desired input amount\r\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountOut The amount of `tokenOut` that would be received\r\n    function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n    \r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function WETH9() external view returns (address);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n    \r\n    function refundETH() external payable;\r\n}\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n}\r\n"
      },
      "project/contracts/brokerbot/PaymentHub.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../utils/Address.sol\";\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"../ERC20/IERC20Permit.sol\";\r\nimport \"./IUniswapV3.sol\";\r\nimport \"../utils/Ownable.sol\";\r\nimport \"./IBrokerbot.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\nimport \"../utils/SafeERC20.sol\";\r\n\r\n/**\r\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\r\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\r\n * Instead, an allowance needs to be set only once, namely for this contract.\r\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap or the reception of Ether\r\n * using the current exchange rate as found in the chainlink oracle.\r\n */\r\ncontract PaymentHub {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Version history\r\n    // Version 4: added path to pay with any ecr20 via uniswap\r\n    // Version 5: added sell via permit\r\n    // Version 6: added transferEther function\r\n    // Version 7: added sell against eth and erc20, version, add permitinfo/swapinfo struct\r\n    // Version 8: use SafeERC20 for transfers\r\n    // Version 9: change payFromEther to include a swap path\r\n    uint256 public constant VERSION = 9;\r\n\r\n    uint256 private constant KEEP_ETHER = 0x4; // copied from brokerbot\r\n\r\n    uint256 private constant DENOMINATOR = 1e8;\r\n    address private constant XCHF_TOKEN = 0xB4272071eCAdd69d933AdcD19cA99fe80664fc08;\r\n    address private constant ZCHF_TOKEN = 0xB58E61C3098d85632Df34EecfB899A1Ed80921cB;\r\n\r\n    IQuoter private immutable uniswapQuoter;\r\n    ISwapRouter private immutable uniswapRouter;\r\n    AggregatorV3Interface internal immutable priceFeedCHFUSD;\r\n    AggregatorV3Interface internal immutable priceFeedETHUSD;\r\n\r\n    address public trustedForwarder;\r\n\r\n    struct PermitInfo {\r\n        uint256 exFee;\r\n        uint256 deadline;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    // event to when new forwarder is set\r\n    event ForwarderChanged(address indexed _oldForwarder, address indexed _newForwarder);\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// Failguard when an erc20 transfer returns false. \r\n    error PaymentHub_TransferFailed();\r\n    /// Sender not trusted.\r\n    /// @param sender The msg.sender of this transaction.\r\n    error PaymentHub_InvalidSender(address sender);\r\n    /// swap with less base token as required.\r\n    /// @param amountBase Required amount.\r\n    /// @param swappedAmount Swapped amount.\r\n    error PaymentHub_SwapError(uint256 amountBase, uint256 swappedAmount);\r\n\r\n    constructor(address _trustedForwarder, IQuoter _quoter, ISwapRouter swapRouter, AggregatorV3Interface _aggregatorCHFUSD, AggregatorV3Interface _aggregatorETHUSD) {\r\n        trustedForwarder = _trustedForwarder;\r\n        uniswapQuoter = _quoter;\r\n        uniswapRouter = swapRouter;\r\n        priceFeedCHFUSD = _aggregatorCHFUSD;\r\n        priceFeedETHUSD = _aggregatorETHUSD;\r\n    }\r\n\r\n    modifier onlySellerAndForwarder(address seller) {\r\n        if (msg.sender != trustedForwarder && msg.sender != seller) {\r\n            revert PaymentHub_InvalidSender(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyForwarder() {\r\n        if (msg.sender != trustedForwarder) {\r\n            revert PaymentHub_InvalidSender(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the trusted forwarder.\r\n     * @param newForwarder The new trusted forwarder.\r\n     */\r\n     function changeForwarder(address newForwarder) external onlyForwarder {\r\n        trustedForwarder = newForwarder;\r\n        emit ForwarderChanged(msg.sender, newForwarder);\r\n    }\r\n\r\n    /**  \r\n     * Get price in ERC20\r\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\r\n     * @param amountInBase The amount of the base currency for the exact output.\r\n     * @param path The encoded path of the swap from erc20 to base.\r\n     * @return amount quoted to pay\r\n     */\r\n    function getPriceInERC20(uint256 amountInBase, bytes memory path) public returns (uint256) {\r\n        return getPriceERC20(amountInBase, path, true);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get price for given amount and path swapped via uniswap. \r\n     * @param amount The exact amount which you want get out (exactOutput) or you put in (exactInput).\r\n     * @param path The path of the swap (inreverse order for exactOutput).\r\n     * @param exactOutput True if exactOutput should be used or false if exactInput should be used.\r\n     */\r\n    function getPriceERC20(uint256 amount, bytes memory path, bool exactOutput) public returns (uint256) {\r\n        if (exactOutput) {\r\n            return uniswapQuoter.quoteExactOutput(\r\n                path,\r\n                amount\r\n            );\r\n        } else {\r\n            return uniswapQuoter.quoteExactInput(\r\n                path,\r\n                amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get price in Ether depding on brokerbot setting.\r\n     * If keep ETH is set price is from oracle.\r\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\r\n     * @return The price in wei.\r\n     */\r\n    function getPriceInEther(uint256 amountInBase, IBrokerbot brokerBot, bytes calldata path) public returns (uint256) {\r\n        if ((address(brokerBot) != address(0)) && hasSettingKeepEther(brokerBot)) {\r\n            return getPriceInEtherFromOracle(amountInBase, IBrokerbot(brokerBot).base());\r\n        } else {\r\n            return getPriceERC20(amountInBase, path, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Price in ETH with 18 decimals\r\n     */\r\n    function getPriceInEtherFromOracle(uint256 amountInBase, IERC20 base) public view returns (uint256) {\r\n        if(address(base) == XCHF_TOKEN || address(base) == ZCHF_TOKEN) {\r\n            return getLatestPriceCHFUSD() * amountInBase / getLatestPriceETHUSD();\r\n        } else {\r\n            return amountInBase * DENOMINATOR / getLatestPriceETHUSD();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the latest price of eth/usd pair from chainlink with 8 decimals\r\n     */\r\n    function getLatestPriceETHUSD() public view returns (uint256) {\r\n        (, int256 price, , , ) = priceFeedETHUSD.latestRoundData();\r\n        return uint256(price);\r\n    }\r\n\r\n    /**\r\n     * Returns the latest price of chf/usd pair from chainlink with 8 decimals\r\n     */\r\n    function getLatestPriceCHFUSD() public view returns (uint256) {\r\n        (, int256 price, , , ) = priceFeedCHFUSD.latestRoundData();\r\n        return uint256(price);\r\n    }\r\n\r\n    /**\r\n     * Convenience method to swap ether into base and pay a target address\r\n     */\r\n    function payFromEther(address recipient, uint256 amountInBase, bytes memory path) public payable returns (uint256 amountIn) {\r\n        ISwapRouter swapRouter = uniswapRouter;\r\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\r\n        ISwapRouter.ExactOutputParams memory params =\r\n            ISwapRouter.ExactOutputParams({\r\n                path: path,\r\n                recipient: recipient,\r\n                // solhint-disable-next-line not-rely-on-time\r\n                deadline: block.timestamp,\r\n                amountOut: amountInBase,\r\n                amountInMaximum: msg.value\r\n            });\r\n\r\n        // Executes the swap, returning the amountIn actually spent.\r\n        amountIn = swapRouter.exactOutput{value: msg.value}(params);\r\n\r\n        // For exact output swaps, the amountInMaximum may not have all been spent.\r\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\r\n        if (amountIn < msg.value) {\r\n            swapRouter.refundETH();\r\n            (bool success, ) = msg.sender.call{value:msg.value - amountIn}(\"\"); // return change\r\n            if (!success) {\r\n                revert PaymentHub_TransferFailed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev The calling address must approve this contract to spend its ERC20 for this function to succeed. As the amount of input ERC20 is variable,\r\n    /// the calling address will need to approve for a slightly higher or infinit amount, anticipating some variance.\r\n    /// @param amountOut The desired amount of baseCurrency.\r\n    /// @param amountInMaximum The maximum amount of ERC20 willing to be swapped for the specified amountOut of baseCurrency.\r\n    /// @param erc20In The address of the erc20 token to pay with.\r\n    /// @param path The encoded path of the swap from erc20 to base.\r\n    /// @param recipient The reciving address - brokerbot.\r\n    /// @return amountIn The amountIn of ERC20 actually spent to receive the desired amountOut.\r\n    function payFromERC20(uint256 amountOut, uint256 amountInMaximum, address erc20In, bytes memory path, address recipient) public returns (uint256 amountIn) {\r\n        ISwapRouter swapRouter = uniswapRouter;\r\n        // Transfer the specified `amountInMaximum` to this contract.\r\n        IERC20(erc20In).safeTransferFrom(msg.sender, address(this), amountInMaximum);\r\n\r\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\r\n        ISwapRouter.ExactOutputParams memory params =\r\n            ISwapRouter.ExactOutputParams({\r\n                path: path,\r\n                recipient: recipient,\r\n                // solhint-disable-next-line not-rely-on-time\r\n                deadline: block.timestamp,\r\n                amountOut: amountOut,\r\n                amountInMaximum: amountInMaximum\r\n            });\r\n\r\n        // Executes the swap, returning the amountIn actually spent.\r\n        amountIn = swapRouter.exactOutput(params);\r\n\r\n        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.\r\n        if (amountIn < amountInMaximum) {\r\n            IERC20(erc20In).safeTransfer(msg.sender, amountInMaximum - amountIn);\r\n        }\r\n    }\r\n\r\n    ///This function appoves infinite allowance for Uniswap, this is safe as the paymenthub should never hold any token (see also recover() ).\r\n    ///@dev This function needs to be called before using the PaymentHub the first time with a new ERC20 token.\r\n    ///@param erc20In The erc20 addresse to approve.\r\n    function approveERC20(address erc20In) external {\r\n        IERC20(erc20In).approve(address(uniswapRouter), type(uint256).max);\r\n    }\r\n\r\n    function multiPay(IERC20 token, address[] calldata recipients, uint256[] calldata amounts) public {\r\n        for (uint i=0; i<recipients.length; i++) {\r\n            IERC20(token).safeTransferFrom(msg.sender, recipients[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\r\n     */\r\n    function multiPayAndNotify(IERC20 token, IBrokerbot[] calldata brokerbots, uint256[] calldata amounts, bytes calldata ref) external {\r\n        for (uint i=0; i<brokerbots.length; i++) {\r\n            payAndNotify(token, brokerbots[i], amounts[i], ref);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to make a base currency payment from the sender to the brokerbot, given an allowance to this contract.\r\n     * @dev Equivalent to xchf.transferAndCall(brokerbot, amountInBase)\r\n     * @param brokerbot The brokerbot to pay and receive the shares from.\r\n     * @param amountInBase The amount of base currency used to buy shares.\r\n     * @param ref The reference data blob.\r\n     * @return The amount of shares bought\r\n     */\r\n    function payAndNotify(IBrokerbot brokerbot, uint256 amountInBase, bytes calldata ref) external returns (uint256) {\r\n        return payAndNotify(brokerbot.base(), brokerbot, amountInBase, ref);\r\n    }\r\n\r\n    function payAndNotify(IERC20 token, IBrokerbot brokerbot, uint256 amount, bytes calldata ref) public returns (uint256) {\r\n        token.safeTransferFrom(msg.sender, address(brokerbot), amount);\r\n        return brokerbot.processIncoming(token, msg.sender, amount, ref);\r\n    }\r\n\r\n    /**\r\n     * @notice Pay with Ether to buy shares.\r\n     * @param brokerbot The brokerbot to pay and receive the shares from.\r\n     * @param amountBase The amount of base currency used to buy shares.\r\n     * @param ref The reference data blob.\r\n     * @param path The Uniswap path from ETH to base currency (uses exactOuput => reverse order)\r\n     * @return priceInEther The amount of Ether spent.\r\n     * @return sharesOut The amount of shares bought.\r\n     */\r\n    function payFromEtherAndNotify(IBrokerbot brokerbot, uint256 amountBase, bytes calldata ref, bytes memory path) external payable returns (uint256 priceInEther, uint256 sharesOut) {\r\n        IERC20 base = brokerbot.base();\r\n        // Check if the brokerbot has setting to keep ETH\r\n        if (hasSettingKeepEther(brokerbot)) {\r\n            priceInEther = getPriceInEtherFromOracle(amountBase, base);\r\n            sharesOut = brokerbot.processIncoming{value: priceInEther}(base, msg.sender, amountBase, ref);\r\n\r\n            // Pay back ETH that was overpaid\r\n            if (priceInEther < msg.value) {\r\n                (bool success, ) = msg.sender.call{value:msg.value - priceInEther}(\"\"); // return change\r\n                if (!success) {\r\n                    revert PaymentHub_TransferFailed();\r\n                }\r\n            }\r\n\r\n        } else {\r\n            uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\r\n            priceInEther = payFromEther(address(brokerbot), amountBase, path);\r\n            uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\r\n            if (amountBase != (balanceAfter - balanceBefore)) { // check that the swap was successful with correct currency\r\n                revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\r\n            }    \r\n            sharesOut = brokerbot.processIncoming(base, msg.sender, amountBase, ref); // not sending msg.value as this is already done in payFromEther function\r\n        }\r\n    }\r\n\r\n    /***\r\n     * @notice Pay from any ERC20 token (which has Uniswapv3 ERC20-ETH pool) and send swapped base currency to brokerbot.\r\n     * @notice The needed amount needs to be approved at the ERC20 contract beforehand\r\n     * @param brokerbot The brokerbot to pay and receive the shares from.\r\n     * @param amountBase The amount of base currency used to buy shares.\r\n     * @param erc20 The address of the ERC20 token to pay.\r\n     * @param amountInMaximum The maximum amount of the ERC20 to pay (should include some slippage).\r\n     * @param path The encoded path of the swap from erc20 to base currency.\r\n     * @param ref Reference data blob.\r\n     * @return amountIn The amount erc20 spent to buy shares.\r\n     * @return amountOut The amount of shares received by the brokerbot.\r\n     */\r\n    function payFromERC20AndNotify(IBrokerbot brokerbot, uint256 amountBase, address erc20, uint256 amountInMaximum, bytes memory path, bytes calldata ref) external returns (uint256 amountIn, uint256 amountOut) {\r\n        IERC20 base = brokerbot.base();\r\n        uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\r\n        amountIn = payFromERC20(amountBase, amountInMaximum, erc20, path, address(brokerbot));\r\n        uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\r\n        if (amountBase != (balanceAfter - balanceBefore)) {\r\n            revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\r\n        }        \r\n        amountOut = brokerbot.processIncoming(base, msg.sender, balanceAfter - balanceBefore, ref);\r\n    }\r\n\r\n    /**\r\n     * @notice Sell shares with permit\r\n     * @param brokerbot The brokerbot to recive the shares.\r\n     * @param seller The address of the seller.\r\n     * @param recipient The address of the recipient of the sell preceeds.\r\n     * @param amountToSell The amount the seller wants to sell.\r\n     * @param ref Reference e.g. insider declaration and the type of sell.\r\n     * @param permitInfo Information about the permit.\r\n     * @return The base currency amount for the selling of the shares.\r\n     */\r\n    function sellSharesWithPermit(IBrokerbot brokerbot, IERC20Permit shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo) public onlySellerAndForwarder(seller) returns (uint256) {\r\n        // Call permit to set allowance\r\n        shares.permit(seller, address(this), amountToSell, permitInfo.deadline, permitInfo.v, permitInfo.r,permitInfo.s);\r\n        // process sell\r\n        if (permitInfo.exFee > 0){\r\n            uint256 proceeds = _sellShares(brokerbot, shares, seller, address(this), amountToSell, ref);\r\n            IERC20 currency = brokerbot.base();\r\n            currency.safeTransfer(msg.sender, permitInfo.exFee);\r\n            currency.safeTransfer(recipient, proceeds - permitInfo.exFee);\r\n            return proceeds - permitInfo.exFee;\r\n        } else {\r\n            return _sellShares(brokerbot, shares, seller, recipient, amountToSell, ref);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice With this function a user can sell shares with permit and swap them to a desired token.\r\n     * @param brokerbot The brokerbot of the shares to sell.\r\n     * @param shares The (draggable)shares address.\r\n     * @param seller The seller address.\r\n     * @param amountToSell The amount of shares to sell.\r\n     * @param ref Reference e.g. insider declaration and the type of sell.\r\n     * @param permitInfo Information about the permit.\r\n     * @param params Information about the swap.\r\n     * @return The output amount of the swap to the desired token.\r\n     */\r\n    function sellSharesWithPermitAndSwap(IBrokerbot brokerbot, IERC20Permit shares, address seller,  uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external onlySellerAndForwarder(seller) returns (uint256) {\r\n        params.amountIn = sellSharesWithPermit(brokerbot, shares, seller, address(this), amountToSell, ref, permitInfo);\r\n        return _swap(params, unwrapWeth);\r\n    }\r\n\r\n    /**\r\n     * @notice With this function a user can sell shares and swap them to a desired token. The user has to approve the paymenthub before on the shares contract.\r\n     * @param brokerbot The brokerbot of the shares to sell.\r\n     * @param shares The (draggable)shares address.\r\n     * @param amountToSell The amount of shares to sell.\r\n     * @param ref Reference e.g. insider declaration and the type of sell.\r\n     * @param params Information about the swap.\r\n     * @return The output amount of the swap to the desired token.\r\n     */\r\n    function sellSharesAndSwap(IBrokerbot brokerbot, IERC20 shares, uint256 amountToSell,  bytes calldata ref, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external returns (uint256) {\r\n        params.amountIn = _sellShares(brokerbot, shares, msg.sender, address(this), amountToSell, ref);\r\n        return _swap(params, unwrapWeth);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers shares to brokerbot and executes the selling.\r\n     * @param brokerbot The brokerbot of the shares to sell.\r\n     * @param shares The (draggable)shares address.\r\n     * @param seller The seller address.\r\n     * @param recipient The recipient of the base currency tokens. (this can be a 3rd party to off-ramp or the paymenthub itself if a swap will be done direct after)\r\n     * @param amountToSell The amount of shares to sell.\r\n     * @param ref Reference e.g. insider declaration and the type of sell.\r\n     * @return The base currency amount for the selling of the shares.\r\n     */ \r\n    function _sellShares(IBrokerbot brokerbot, IERC20 shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref ) internal returns (uint256) {\r\n        // send shares token to brokerbot\r\n        shares.safeTransferFrom(seller, address(brokerbot), amountToSell);\r\n        // process sell on brokerbot\r\n        return brokerbot.processIncoming(shares, recipient, amountToSell, ref);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap (base currency) token according to given path and unwrap weth if needed.\r\n     * @param params Information about the swap (includes path).\r\n     * @return amountOut The output amount of the swap to the desired token.\r\n     */\r\n    function _swap(ISwapRouter.ExactInputParams memory params, bool unwrapWeth) internal returns(uint256 amountOut) {\r\n        // if weth should be unwrapped, swap recipient is this contract and eth is send to seller\r\n        if (unwrapWeth){\r\n            address seller = params.recipient;\r\n            params.recipient = address(this);\r\n            amountOut = _swapToERC20(params);\r\n            IWETH9(uniswapQuoter.WETH9()).withdraw(amountOut);\r\n            (bool success, ) = payable(seller).call{value:amountOut}(\"\");\r\n            if (!success) revert PaymentHub_TransferFailed();\r\n        } else {\r\n            amountOut = _swapToERC20(params);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calls the Uniswap router to swap tokens according to given path.\r\n     * @param params Information about the swap (includes path).\r\n     * @return amountOut The output amount of the swap to the desired token.\r\n     */\r\n    function _swapToERC20(ISwapRouter.ExactInputParams memory params) internal returns(uint256 amountOut) {\r\n        amountOut = uniswapRouter.exactInput(params);\r\n        if (amountOut < params.amountOutMinimum){\r\n            revert PaymentHub_SwapError(params.amountOutMinimum, amountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the brokerbot has setting enabled to keep ether\r\n     */\r\n    function hasSettingKeepEther(IBrokerbot brokerbot) public view returns (bool) {\r\n        return brokerbot.settings() & KEEP_ETHER == KEEP_ETHER;\r\n    }\r\n\r\n    /**\r\n     * @notice In case tokens have been accidentally sent directly to this contract. Only Forwarder can withdraw, else a MEV bot will intercept it.\r\n     * @param ercAddress The erc20 address.\r\n     * @param to The address to transfer tokens to.\r\n     * @param amount The amount of tokens to transfer.\r\n     */\r\n    function recover(IERC20 ercAddress, address to, uint256 amount) external onlyForwarder {\r\n        ercAddress.safeTransfer(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer ether to a given address. Only Forwarder can withdraw, else a MEV bot will intercept it.\r\n     * @param to The address to transfer ether to.\r\n     */\r\n    function withdrawEther(address to, uint256 amount) external onlyForwarder {\r\n        (bool success, ) = payable(to).call{value:amount}(\"\");\r\n        if (!success) {\r\n            revert PaymentHub_TransferFailed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer ether to a given address.\r\n     * @dev Used with the mutlisigwallet.\r\n     * @param to The address to transfer ether to.\r\n     */\r\n    function transferEther(address to) external payable {\r\n        (bool success, ) = payable(to).call{value:msg.value}(\"\");\r\n        if (!success) {\r\n            revert PaymentHub_TransferFailed();\r\n        }\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {\r\n        // Important to receive ETH refund from Uniswap\r\n    }\r\n}\r\n"
      },
      "project/contracts/draggable/ERC20Draggable.sol": {
        "content": "/**\r\n * SPDX-License-Identifier: LicenseRef-Aktionariat\r\n *\r\n * MIT License with Automated License Fee Payments\r\n *\r\n * Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n *\r\n * Permission is hereby granted to any person obtaining a copy of this software\r\n * and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy,\r\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * - The above copyright notice and this permission notice shall be included in\r\n *   all copies or substantial portions of the Software.\r\n * - All automated license fee payments integrated into this and related Software\r\n *   are preserved.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @title ERC-20 tokens subject to a drag-along agreement\r\n * @author Luzius Meisser, luzius@aktionariat.com\r\n *\r\n * This is an ERC-20 token that is bound to a shareholder or other agreement that contains\r\n * a drag-along clause. The smart contract can help enforce this drag-along clause in case\r\n * an acquirer makes an offer using the provided functionality. If a large enough quorum of\r\n * token holders agree, the remaining token holders can be automatically \"dragged along\" or\r\n * squeezed out. For shares non-tokenized shares, the contract relies on an external Oracle\r\n * to provide the votes of those.\r\n *\r\n * Subclasses should provide a link to a human-readable form of the agreement.\r\n */\r\n\r\nimport \"./IDraggable.sol\";\r\nimport \"../ERC20/ERC20Flaggable.sol\";\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"../ERC20/IERC677Receiver.sol\";\r\nimport \"./IOffer.sol\";\r\nimport \"./IOfferFactory.sol\";\r\nimport \"../shares/IShares.sol\";\r\nimport \"../utils/SafeERC20.sol\";\r\n\r\nstruct DraggableParams {\r\n\tIERC20Permit wrappedToken;\r\n\tuint256 quorumDrag;\r\n\tuint256 quorumMigration;\r\n\tuint256 votePeriod;\r\n}\r\n\r\nabstract contract ERC20Draggable is IERC677Receiver, IDraggable, ERC20Flaggable {\r\n\r\n\tusing SafeERC20 for IERC20;\r\n    \r\n\t// If flag is not present, one can be sure that the address did not vote. If the \r\n\t// flag is present, the address might have voted and one needs to check with the\r\n\t// current offer (if any) when transferring tokens.\r\n\tuint8 private constant FLAG_VOTE_HINT = 1;\r\n\r\n\tIERC20 public override wrapped; // The wrapped contract\r\n\tIOfferFactory public immutable factory;\r\n\r\n\t// If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\r\n\tuint256 public unwrapConversionFactor = 0;\r\n\r\n\t// The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\r\n\tIOffer public override offer;\r\n\r\n\tuint256 private constant QUORUM_MULTIPLIER = 10000;\r\n\r\n\tuint256 public immutable quorumMigration; // used for contract migartion, in BPS (out of 10'000)\r\n\tuint256 public immutable quorum; // used for drag-along at acquisition offers, in BPS (out of 10'000)\r\n\tuint256 public immutable votePeriod; // In seconds\r\n\r\n\taddress public override oracle;\r\n\r\n\tevent MigrationSucceeded(address newContractAddress, uint256 yesVotes, uint256 oracleVotes, uint256 totalVotingPower);\r\n\tevent ChangeOracle(address oracle);\r\n\r\n    /**\r\n\t * Note that the Brokerbot only supports tokens that revert on failure and where transfer never returns false.\r\n     */\r\n\tconstructor(\r\n\t\tDraggableParams memory _params,\r\n\t\tIOfferFactory _offerFactory,\r\n\t\taddress _oracle\r\n\t) \r\n\t\tERC20Flaggable(0)\r\n\t{\r\n\t\twrapped = _params.wrappedToken;\r\n\t\tquorum = _params.quorumDrag;\r\n\t\tquorumMigration = _params.quorumMigration;\r\n\t\tvotePeriod = _params.votePeriod;\r\n\t\tfactory = _offerFactory;\r\n\t\toracle = _oracle;\r\n\t}\r\n\r\n\tmodifier onlyOracle {\r\n\t\t_checkSender(oracle);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyWrappedToken {\r\n\t\t_checkSender(address(wrapped));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOffer(){\r\n\t\t_checkSender(address(offer));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier checkBinding(bool expected) {\r\n\t\tif (expected != isBinding()) {\r\n\t\t\tif(expected) {\r\n\t\t\t\trevert Draggable_NotBinding();\r\n\t\t\t}\r\n\t\t\tif(!expected) {\r\n\t\t\t\trevert Draggable_IsBinding();\r\n\t\t\t}\r\n\t\t} \r\n\t\t_;\r\n\t}\r\n\r\n\tfunction onTokenTransfer(\r\n\t\taddress from, \r\n\t\tuint256 amount, \r\n\t\tbytes calldata\r\n\t) external override onlyWrappedToken returns (bool) {\r\n\t\t_mint(from, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/** Wraps additional tokens, thereby creating more ERC20Draggable tokens. */\r\n\tfunction wrap(address shareholder, uint256 amount) external {\r\n\t\twrapped.safeTransferFrom(msg.sender, address(this), amount);\r\n\t\t_mint(shareholder, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates that the token holders are bound to the token terms and that:\r\n\t * - Conversion back to the wrapped token (unwrap) is not allowed\r\n\t * - A drag-along can be performed by making an according offer\r\n\t * - They can be migrated to a new version of this contract in accordance with the terms\r\n\t */\r\n\tfunction isBinding() public view returns (bool) {\r\n\t\treturn unwrapConversionFactor == 0;\r\n\t}\r\n\r\n    /**\r\n\t * Current recommended naming convention is to add the postfix \"SHA\" to the plain shares\r\n\t * in order to indicate that this token represents shares bound to a shareholder agreement.\r\n\t */\r\n\tfunction name() public view override returns (string memory) {\r\n\t\tstring memory wrappedName = wrapped.name();\r\n\t\tif (isBinding()) {\r\n\t\t\treturn string(abi.encodePacked(wrappedName, \" SHA\"));\r\n\t\t} else {\r\n\t\t\treturn string(abi.encodePacked(wrappedName, \" (Wrapped)\"));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction symbol() public view override returns (string memory) {\r\n\t\t// ticker should be less dynamic than name\r\n\t\treturn string(abi.encodePacked(wrapped.symbol(), \"S\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Deactivates the drag-along mechanism and enables the unwrap function.\r\n\t */\r\n\tfunction _deactivate(uint256 factor) internal {\r\n\t\tif (factor == 0) {\r\n\t\t\trevert Draggable_FactorZero();\r\n\t\t}\r\n\t\tunwrapConversionFactor = factor;\r\n\t}\r\n\r\n\t/** Decrease the number of drag-along tokens. The user gets back their shares in return */\r\n\tfunction unwrap(uint256 amount) external override checkBinding(false) {\r\n\t\t_unwrap(msg.sender, amount, unwrapConversionFactor);\r\n\t}\r\n\r\n\tfunction _unwrap(address owner, uint256 amount, uint256 factor) internal {\r\n\t\t_burn(owner, amount);\r\n\t\twrapped.safeTransfer(owner, amount * factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Burns both the token itself as well as the wrapped token!\r\n\t * If you want to get out of the shareholder agreement, use unwrap after it has been\r\n\t * deactivated by a majority vote or acquisition.\r\n\t *\r\n\t * Burning only works if wrapped token supports burning. Also, the exact meaning of this\r\n\t * operation might depend on the circumstances. Burning and reussing the wrapped token\r\n\t * does not free the sender from the legal obligations of the shareholder agreement.\r\n\t */\r\n\tfunction burn(uint256 amount) external {\r\n\t\t_burn(msg.sender, amount);\r\n\t\tIShares(address(wrapped)).burn(isBinding() ? amount : amount * unwrapConversionFactor);\r\n\t}\r\n\r\n\tfunction makeAcquisitionOffer(\r\n\t\tbytes32 salt, \r\n\t\tuint256 pricePerShare, \r\n\t\tIERC20 currency\r\n\t) external payable checkBinding(true) {\r\n\t\tIOffer newOffer = factory.create{value: msg.value}(\r\n\t\t\tsalt, msg.sender, pricePerShare, currency, quorum, votePeriod);\r\n\r\n\t\tif (_offerExists()) {\r\n\t\t\toffer.makeCompetingOffer(newOffer);\r\n\t\t}\r\n\t\toffer = newOffer;\r\n\t}\r\n\r\n\tfunction drag(address buyer, IERC20 currency) external override onlyOffer {\r\n\t\t_unwrap(buyer, balanceOf(buyer), 1);\r\n\t\t_replaceWrapped(currency, buyer);\r\n\t}\r\n\r\n\tfunction notifyOfferEnded() external override onlyOffer {\r\n\t\toffer = IOffer(address(0));\r\n\t}\r\n\r\n\tfunction _replaceWrapped(IERC20 newWrapped, address oldWrappedDestination) internal checkBinding(true) {\r\n\t\t// Free all old wrapped tokens we have\r\n\t\twrapped.safeTransfer(oldWrappedDestination, wrapped.balanceOf(address(this)));\r\n\t\t// Count the new wrapped tokens\r\n\t\twrapped = newWrapped;\r\n\t\tif (totalSupply() > 0) // if there are no tokens, no need to deactivate\r\n\t\t\t_deactivate(newWrapped.balanceOf(address(this)) / totalSupply());\r\n\t\temit NameChanged(name(), symbol());\r\n\t}\r\n\r\n\tfunction setOracle(address newOracle) external override onlyOracle {\r\n\t\toracle = newOracle;\r\n\t\temit ChangeOracle(oracle);\r\n\t}\r\n\r\n\tfunction migrateWithExternalApproval(address successor, uint256 additionalVotes) external override onlyOracle {\r\n\t\t// Additional votes cannot be higher than the votes not represented by these tokens.\r\n\t\t// The assumption here is that more shareholders are bound to the shareholder agreement\r\n\t\t// that this contract helps enforce and a vote among all parties is necessary to change\r\n\t\t// it, with an oracle counting and reporting the votes of the others.\r\n\t\tif (totalSupply() + additionalVotes > totalVotingTokens()) {\r\n\t\t\trevert Draggable_TooManyVotes(totalVotingTokens(), totalSupply() + additionalVotes);\r\n\t\t}\r\n\t\t_migrate(successor, additionalVotes);\r\n\t}\r\n\r\n\tfunction migrate() external override {\r\n\t\t_migrate(msg.sender, 0);\r\n\t}\r\n\r\n\tfunction _migrate(address successor, uint256 additionalVotes) internal {\r\n\t\tuint256 yesVotes = additionalVotes + balanceOf(successor);\r\n\t\tuint256 totalVotes = totalVotingTokens();\r\n\t\tif (yesVotes > totalVotes) {\r\n\t\t\trevert Draggable_TooManyVotes(totalVotes, yesVotes);\r\n\t\t}\r\n\t\tif (_offerExists()) {\r\n\t\t\t// if you have the quorum, you can cancel the offer first if necessary\r\n\t\t\trevert Draggable_OpenOffer();\r\n\t\t}\r\n\t\tif (yesVotes * QUORUM_MULTIPLIER < totalVotes * quorumMigration) {\r\n\t\t\trevert Draggable_QuorumNotReached(totalVotes * quorumMigration, yesVotes * QUORUM_MULTIPLIER);\r\n\t\t}\r\n\t\t_replaceWrapped(IERC20(successor), successor);\r\n\t\temit MigrationSucceeded(successor, yesVotes, additionalVotes, totalVotes);\r\n\t}\r\n\r\n\tfunction votingPower(address voter) external view override returns (uint256) {\r\n\t\treturn balanceOf(voter);\r\n\t}\r\n\r\n\tfunction totalVotingTokens() public view override returns (uint256) {\r\n\t\treturn IShares(address(wrapped)).totalShares();\r\n\t}\r\n\r\n\tfunction _hasVoted(address voter) internal view returns (bool) {\r\n\t\treturn hasFlagInternal(voter, FLAG_VOTE_HINT);\r\n\t}\r\n\r\n\tfunction notifyVoted(address voter) external override onlyOffer {\r\n\t\tsetFlag(voter, FLAG_VOTE_HINT, true);\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to,\tuint256 amount) internal virtual override {\r\n\t\tif (_hasVoted(from) || _hasVoted(to)) {\r\n\t\t\tif (_offerExists()) {\r\n\t\t\t\toffer.notifyMoved(from, to, amount);\r\n\t\t\t} else {\r\n\t\t\t\tsetFlag(from, FLAG_VOTE_HINT, false);\r\n\t\t\t\tsetFlag(to, FLAG_VOTE_HINT, false);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsuper._beforeTokenTransfer(from, to, amount);\r\n\t}\r\n\r\n\tfunction _offerExists() internal view returns (bool) {\r\n\t\treturn address(offer) != address(0) && ! offer.isKilled();\t\t// needs to have contract deployed AND offer needs to be not in deleted state\r\n\t}\r\n}\r\n"
      },
      "project/contracts/draggable/IDraggable.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"./IOffer.sol\";\r\ninterface IDraggable is IERC20 {\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// conversion factor has to be > 0 for this transaction.\r\n    error Draggable_NotBinding();\r\n    /// conversion factor has to be = 0 for this transaction.\r\n    error Draggable_IsBinding();\r\n    /// conversion factor can't be 0 if binding gets deactivated.\r\n    error Draggable_FactorZero();\r\n    /// the reported votes can't be > max voting tokens.\r\n    /// @param maxVotes The max voting tokens.\r\n    /// @param reportedVotes The actual reported votes.\r\n    error Draggable_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\r\n    /// there is still an open offer that has to be canceled first\r\n    error Draggable_OpenOffer();\r\n    /// For migration the quorum needs to be reached.\r\n    /// @param needed The needed quorum.\r\n    /// @param actual The current yes votes.\r\n    error Draggable_QuorumNotReached(uint256 needed, uint256 actual);\r\n    \r\n    function wrapped() external view returns (IERC20);\r\n    function unwrap(uint256 amount) external;\r\n    function offer() external view returns (IOffer);\r\n    function oracle() external view returns (address);\r\n    function drag(address buyer, IERC20 currency) external;\r\n    function notifyOfferEnded() external;\r\n    function votingPower(address voter) external returns (uint256);\r\n    function totalVotingTokens() external view returns (uint256);\r\n    function notifyVoted(address voter) external;\r\n    function migrate() external;\r\n    function setOracle(address newOracle) external;\r\n    function migrateWithExternalApproval(address successor, uint256 additionalVotes) external;\r\n    function setTerms(string calldata _terms) external;\r\n\r\n\r\n}\r\n"
      },
      "project/contracts/draggable/IOffer.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\n\r\ninterface IOffer {\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n  //////////////////////////////////////////////////////////////*/\r\n\t/// Invalid msg.sender.\r\n\t/// @param sender The msg.sender of the transaction.\r\n\terror Offer_InvalidSender(address sender);\r\n\t/// Offer needs to be still open.\r\n\terror Offer_AlreadyAccepted();\r\n\t/// Offer needs to be not accepted yet.\r\n\terror Offer_NotAccepted();\r\n\t/// Sender of the offer needs to have needed funds in his account.\r\n\terror Offer_NotWellFunded();\r\n\t/// New offer not valid. `newPrice` needs to be higher than `oldPrice`.\r\n\t/// @param oldPrice Price of the old offer.\r\n\t/// @param newPrice Price of the new offer.\r\n\terror Offer_OldOfferBetter(uint256 oldPrice, uint256 newPrice);\r\n\t/// Voting needs to be still open.\r\n\terror Offer_VotingEnded();\r\n\t/// Too many (External) reported votes. `reportedVotes` needs to be less or equal to `maxVotes`.\r\n\t/// @param maxVotes The max possible votes for the token.\r\n\t/// @param reportedVotes The external reported votes + circulating supply of the token.\r\n\terror Offer_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\r\n\t/// Competing offer needs to be in the same currency.\r\n\terror Offer_OfferInWrongCurrency();\r\n\t/// Offer got already killed.\r\n\terror Offer_IsKilled();\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Function Interfaces\r\n\t//////////////////////////////////////////////////////////////*/\r\n\r\n\tfunction makeCompetingOffer(IOffer newOffer) external;\r\n\r\n\t// if there is a token transfer while an offer is open, the votes get transfered too\r\n\tfunction notifyMoved(address from, address to, uint256 value) external;\r\n\r\n\tfunction currency() external view returns (IERC20);\r\n\r\n\tfunction price() external view returns (uint256);\r\n\r\n\tfunction isWellFunded() external view returns (bool);\r\n\r\n\tfunction voteYes() external;\r\n\r\n\tfunction voteNo() external;\r\n\r\n\tfunction isKilled() external view returns (bool);\r\n}"
      },
      "project/contracts/draggable/IOfferFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"./IOffer.sol\";\r\n\r\ninterface IOfferFactory {\r\n\r\n\tfunction create(\r\n\t\tbytes32 salt, address buyer, uint256 pricePerShare,\tIERC20 currency,\tuint256 quorum,\tuint256 votePeriod\r\n\t) external payable returns (IOffer);\r\n}"
      },
      "project/contracts/ERC20/ERC20Allowlistable.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nimport \"./ERC20Flaggable.sol\";\r\nimport \"../utils/Ownable.sol\";\r\n\r\n/**\r\n * A very flexible and efficient form to subject ERC-20 tokens to an allowlisting.\r\n * See ../../doc/allowlist.md for more information.\r\n */\r\nabstract contract ERC20Allowlistable is ERC20Flaggable, Ownable {\r\n\r\n  uint8 private constant TYPE_FREE = 0x0;\r\n  uint8 private constant TYPE_ALLOWED = 0x1;\r\n  uint8 private constant TYPE_RESTRICTED = 0x2;\r\n  uint8 private constant TYPE_ADMIN = 0x4;\r\n\r\n  uint8 private constant FLAG_INDEX_ALLOWED = 20;\r\n  uint8 private constant FLAG_INDEX_RESTRICTED = 21;\r\n  uint8 private constant FLAG_INDEX_ADMIN = 22;\r\n\r\n  event AddressTypeUpdate(address indexed account, uint8 addressType);\r\n\r\n  /// Receiver has flag forbidden.\r\n  /// @param receiver the address of the forbidden receiver.\r\n  error Allowlist_ReceiverIsForbidden(address receiver);\r\n  /// Sender has flag forbidden.\r\n  /// @param sender the address of the forbidden sender.\r\n  error Allowlist_SenderIsForbidden(address sender);\r\n  /// Receiver has no allowlist flag.\r\n  /// @param receiver the address which isn't allowlisted.\r\n  error Allowlist_ReceiverNotAllowlisted(address receiver);\r\n\r\n  /**\r\n   * Configures whether the allowlisting is applied.\r\n   * Also sets the powerlist and allowlist flags on the null address accordingly.\r\n   * It is recommended to also deactivate the powerlist flag on other addresses.\r\n   */\r\n  function setApplicable(bool transferRestrictionsApplicable) external onlyOwner {\r\n    setApplicableInternal(transferRestrictionsApplicable);\r\n  }\r\n\r\n  /**\r\n   * Sets the 0x0 address to ADMIN, to apply restrictions to newly minted shares.\r\n   * The issuer should decide if existing shares are freely transferable or not.\r\n   * If not, existing holders need to be converted to ALLOWED as well\r\n   */\r\n  function setApplicableInternal(bool transferRestrictionsApplicable) internal {\r\n    if (transferRestrictionsApplicable){\r\n      setTypeInternal(address(0x0), TYPE_ADMIN);\r\n    } else {\r\n      setTypeInternal(address(0x0), TYPE_FREE);\r\n    }\r\n  }\r\n\r\n  function setType(address account, uint8 typeNumber) public onlyOwner {\r\n    setTypeInternal(account, typeNumber);\r\n  }\r\n\r\n  function setType(address[] calldata addressesToAdd, uint8 typeNumber) public onlyOwner {\r\n    for (uint i = 0 ; i < addressesToAdd.length ; i++){\r\n      setType(addressesToAdd[i], typeNumber);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If TYPE_FREE all flags are set to 0\r\n   */\r\n  function setTypeInternal(address account, uint8 typeNumber) internal {\r\n    setFlag(account, FLAG_INDEX_ALLOWED, typeNumber == TYPE_ALLOWED);\r\n    setFlag(account, FLAG_INDEX_RESTRICTED, typeNumber == TYPE_RESTRICTED);\r\n    setFlag(account, FLAG_INDEX_ADMIN, typeNumber == TYPE_ADMIN);\r\n    emit AddressTypeUpdate(account, typeNumber);\r\n  }\r\n\r\n  /**\r\n   * If true, this address is allowlisted and can only transfer tokens to other allowlisted addresses.\r\n   */\r\n  function isAllowed(address account) public view returns (bool) {\r\n    return hasFlagInternal(account, FLAG_INDEX_ALLOWED);\r\n  }\r\n\r\n  /**\r\n   * If true, this address can only transfer tokens to admin addresses and not receive from anyone.\r\n   */\r\n  function isRestricted(address account) public view returns (bool){\r\n    return hasFlagInternal(account, FLAG_INDEX_RESTRICTED);\r\n  }\r\n\r\n  /**\r\n   * If true, this address can send to any address, except restricted\r\n   * It also automatically allowlists target addresses\r\n   */\r\n  function isAdmin(address account) public view returns (bool) {\r\n    return hasFlagInternal(account, FLAG_INDEX_ADMIN);\r\n  }\r\n\r\n  /**\r\n   * Implements the following ruleset.\r\n   * 1. \"Restricted\" addresses cannot send or receive shares, except sending to an admin address\r\n   * 2. Shares on \"Free\" addresses are freely transferable\r\n   * 3. \"Allowed\" addresses can only send to \"Allowed\" or \"Admin\" addresses   * \r\n   * \r\n   * +------------+-----+-----+-----+-----+\r\n   * |            | Fre | Alw | Res | Adm |\r\n   * +------------+-----+-----+-----+-----+\r\n   * | Free       |  Y  |  Y  |  N  |  Y  |\r\n   * | Allowed    |  N  |  Y  |  N  |  Y  |\r\n   * | Restricted |  N  |  N  |  N  |  Y  |\r\n   * | Admin      |  Y  |  Y  |  N  |  Y  |\r\n   * +------------+-----+-----+-----+-----+\r\n   */\r\n\r\n  function _beforeTokenTransfer(address from, address to, uint256 amount) override virtual internal {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n\r\n    if (isRestricted(to)) {\r\n        revert Allowlist_ReceiverIsForbidden(to);\r\n    }\r\n    else if (isRestricted(from)) {\r\n      if (!isAdmin(to)) {\r\n        revert Allowlist_SenderIsForbidden(from);\r\n      }\r\n    }\r\n    else if (!isAdmin(to) && !isAllowed(to)) {\r\n      if (isAllowed(from)) {\r\n        revert Allowlist_ReceiverNotAllowlisted(to);\r\n      }\r\n\r\n      // Admin address always sets the recipient to ALLOWED\r\n      // If this behaviour is not desired, set admin addresses to FREE instead\r\n      if (isAdmin(from)) {\r\n        setFlag(to, FLAG_INDEX_ALLOWED, true);\r\n        emit AddressTypeUpdate(to, TYPE_ALLOWED);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n"
      },
      "project/contracts/ERC20/ERC20Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @title Standard ERC20 Errors\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-20\r\n///  https://eips.ethereum.org/EIPS/eip-6093\r\ninterface ERC20Errors {\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n    error ERC20InvalidSender(address sender);\r\n    error ERC20InvalidReceiver(address receiver);\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n    error ERC20InvalidApprover(address approver);\r\n    error ERC20InvalidSpender(address spender);\r\n}"
      },
      "project/contracts/ERC20/ERC20Flaggable.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// Copied and adjusted from OpenZeppelin\r\n// Adjustments:\r\n// - modifications to support ERC-677\r\n// - removed unnecessary require statements\r\n// - removed GSN Context\r\n// - upgraded to 0.8 to drop SafeMath\r\n// - let name() and symbol() be implemented by subclass\r\n// - infinite allowance support, with 2^255 and above considered infinite\r\n// - use upper 32 bits of balance for flags\r\n// - add a global settings variable\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./ERC20Errors.sol\";\r\nimport \"./IERC677Receiver.sol\";\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\n\r\nabstract contract ERC20Flaggable is IERC20, ERC20Errors {\r\n\r\n    // as Documented in /doc/infiniteallowance.md\r\n    // 0x8000000000000000000000000000000000000000000000000000000000000000\r\n    uint256 constant private INFINITE_ALLOWANCE = 2**255;\r\n\r\n    uint256 private constant FLAGGING_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\r\n\r\n    // Documentation of flags used by subclasses:\r\n    // NOTE: flags denote the bit number that is being used and must be smaller than 32\r\n    // ERC20Draggable: uint8 private constant FLAG_INDEX_VOTED = 1;\r\n    // ERC20Recoverable: uint8 private constant FLAG_INDEX_CLAIM_PRESENT = 10;\r\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\r\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\r\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_POWERLIST = 22;\r\n\r\n    mapping (address => uint256) private _balances; // upper 32 bits reserved for flags\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    uint8 public immutable override decimals;\r\n\r\n    event NameChanged(string name, string symbol);\r\n\r\n    /// Overflow on minting, transfer. \r\n    /// @param receiver The address were the balance overflows. \r\n    /// @param balance The current balance of the receiver. \r\n    /// @param amount The amount added, which result in the overflow. \r\n    error ERC20BalanceOverflow(address receiver, uint256 balance, uint256 amount);\r\n\r\n    constructor(uint8 _decimals) {\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return uint224 (_balances [account]);\r\n    }\r\n\r\n    function hasFlag(address account, uint8 number) external view returns (bool) {\r\n        return hasFlagInternal(account, number);\r\n    }\r\n\r\n    function setFlag(address account, uint8 index, bool value) internal {\r\n        uint256 flagMask = 1 << (index + 224);\r\n        uint256 balance = _balances [account];\r\n        if ((balance & flagMask == flagMask) != value) {\r\n            _balances [account] = balance ^ flagMask;\r\n        }\r\n    }\r\n\r\n    function hasFlagInternal(address account, uint8 number) internal view returns (bool) {\r\n        uint256 flag = 0x1 << (number + 224);\r\n        return _balances[account] & flag == flag;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = allowance(sender, msg.sender);\r\n        if (currentAllowance < INFINITE_ALLOWANCE){\r\n            // Only decrease the allowance if it was not set to 'infinite'\r\n            // Documented in /doc/infiniteallowance.md\r\n            _allowances[sender][msg.sender] = currentAllowance - amount;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        decreaseBalance(sender, amount);\r\n        increaseBalance(recipient, amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\r\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external virtual returns (bool) {\r\n        return transfer (recipient, amount) \r\n            && IERC677Receiver (recipient).onTokenTransfer (msg.sender, amount, data);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address recipient, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(address(0), recipient, amount);\r\n        _totalSupply += amount;\r\n        increaseBalance(recipient, amount);\r\n        emit Transfer(address(0), recipient, amount);\r\n    }\r\n\r\n    function increaseBalance(address recipient, uint256 amount) private {\r\n        if (recipient == address(0x0)) {\r\n            revert ERC20InvalidReceiver(recipient); //use burn instead\r\n        }\r\n        uint256 oldBalance = _balances[recipient];\r\n        uint256 newBalance = oldBalance + amount;\r\n        if (oldBalance & FLAGGING_MASK != newBalance & FLAGGING_MASK) {\r\n            revert ERC20BalanceOverflow(recipient, oldBalance, amount);\r\n        }\r\n        _balances[recipient] = newBalance;\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _totalSupply -= amount;\r\n        decreaseBalance(account, amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function decreaseBalance(address sender, uint256 amount) private {\r\n        uint256 oldBalance = _balances[sender];\r\n        uint256 newBalance = oldBalance - amount;\r\n        if (oldBalance & FLAGGING_MASK != newBalance & FLAGGING_MASK) {\r\n            revert ERC20InsufficientBalance(sender, balanceOf(sender), amount);\r\n        }\r\n        _balances[sender] = newBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n     // solhint-disable-next-line no-empty-blocks\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\r\n        // intentionally left blank\r\n    }\r\n\r\n    /**\r\n     * Checks if msg.sender is an authorized address.\r\n     * @param validSender The authorized address.\r\n     */\r\n    function _checkSender(address validSender) internal view {\r\n        if (msg.sender != validSender) {\r\n            revert ERC20InvalidSender(msg.sender);\r\n        }\r\n    }\r\n\r\n}"
      },
      "project/contracts/ERC20/ERC20Named.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./ERC20Flaggable.sol\";\r\nimport \"../utils/Ownable.sol\";\r\n\r\ncontract ERC20Named is ERC20Flaggable, Ownable {\r\n\r\n    string public override name;\r\n    string public override symbol;\r\n\r\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, address _admin) ERC20Flaggable(_decimals) Ownable(_admin) {\r\n        setNameInternal(_symbol, _name);\r\n    }\r\n\r\n    function setName(string memory _symbol, string memory _name) external onlyOwner {\r\n        setNameInternal(_symbol, _name);\r\n    }\r\n\r\n    function setNameInternal(string memory _symbol, string memory _name) internal {\r\n        symbol = _symbol;\r\n        name = _name;\r\n        emit NameChanged(_name, _symbol);\r\n    }\r\n\r\n}"
      },
      "project/contracts/ERC20/ERC20Permit2.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./ERC20Flaggable.sol\";\r\nimport \"../utils/Permit2Hub.sol\";\r\n\r\n/// @title ERC20Permit2\r\n/// @dev This abstract contract extends the ERC20Flaggable contract and introduces the Permit2Hub.\r\nabstract contract ERC20Permit2 is ERC20Flaggable {\r\n    \r\n    /// @dev The Permit2Hub contract instance.\r\n    Permit2Hub public immutable permit2Hub;\r\n\r\n    /// @dev Initializes the ERC20Permit2 contract.\r\n    /// @param _permit2Hub The address of the Permit2Hub contract.\r\n    constructor(Permit2Hub _permit2Hub) {\r\n        permit2Hub = _permit2Hub;\r\n    }\r\n\r\n    /// @inheritdoc ERC20Flaggable\r\n    function allowance(address owner, address spender) public view virtual override(ERC20Flaggable) returns (uint256) {\r\n        if (permit2Hub.isPermit2Enabled(owner, spender)) \r\n            return type(uint256).max;  // If permit is enabled, return the maximum value of uint256\r\n        else \r\n            return super.allowance(owner, spender);  // Otherwise, call the parent(ERC20Flaggable) allowance function\r\n    }\r\n}\r\n"
      },
      "project/contracts/ERC20/ERC20PermitLight.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\r\n// and modified it.\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./ERC20Flaggable.sol\";\r\nimport \"./IERC20Permit.sol\";\r\nabstract contract ERC20PermitLight is ERC20Flaggable, IERC20Permit {\r\n\r\n   /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => uint256) public override nonces;\r\n\r\n  /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public override {\r\n        if (deadline < block.timestamp) {\r\n            revert Permit_DeadlineExpired(deadline, block.timestamp);\r\n        }\r\n\r\n        unchecked { // unchecked to save a little gas with the nonce increment...\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\r\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            if (recoveredAddress == address(0) || recoveredAddress != owner) {\r\n                revert Permit_InvalidSigner(recoveredAddress);\r\n            }\r\n            _approve(recoveredAddress, spender, value);\r\n        }\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\r\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n}"
      },
      "project/contracts/ERC20/IERC20.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: MIT\r\n*\r\n* Copyright (c) 2016-2019 zOS Global Limited\r\n*\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\n\r\ninterface IERC20 {\r\n\r\n    // Optional functions\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}"
      },
      "project/contracts/ERC20/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit is IERC20 {\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n\t//////////////////////////////////////////////////////////////*/\r\n    /// Block timestamp must to be before deadline.\r\n    /// @param deadline The deadline of the permit.\r\n    /// @param blockTimestamp The timestamp of the execution block.\r\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\r\n    /// Recovered address must be owner and not zero address.\r\n    /// @param signerAddress The recovered signer address.\r\n    error Permit_InvalidSigner(address signerAddress);\r\n\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}"
      },
      "project/contracts/ERC20/IERC677Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\r\ninterface IERC677Receiver {\r\n\r\n    error IERC677_OnTokenTransferFailed();\r\n    \r\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\r\n\r\n}"
      },
      "project/contracts/multisig/MultiSigCloneFactory.sol": {
        "content": "\r\n/**\r\n * SPDX-License-Identifier: MIT\r\n */\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\n\r\ncontract MultiSigCloneFactory {\r\n\r\n  address immutable public IMPLEMENTATION;\r\n\r\n  event ContractCreated(address indexed contractAddress, string indexed typeName, bytes32 salt);\r\n\r\n  constructor(address master){\r\n    IMPLEMENTATION = master;\r\n  }\r\n\r\n  function predict(bytes32 salt) external view returns (address) {\r\n    return Clones.predictDeterministicAddress(IMPLEMENTATION, salt);\r\n  }\r\n\r\n  function create(address owner, bytes32 salt) external returns (address) {\r\n    address payable instance = payable(Clones.cloneDeterministic(IMPLEMENTATION, salt));\r\n    IMultisig(instance).initialize(block.chainid == 1 ? owner : address(0x0));\r\n    emit ContractCreated(instance, \"MultiSigWallet\", salt);\r\n    return instance;\r\n  }\r\n}\r\n\r\ninterface IMultisig {\r\n  function initialize(address owner) external;\r\n}"
      },
      "project/contracts/recovery/ERC20Recoverable.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/ERC20Flaggable.sol\";\r\nimport \"./IRecoveryHub.sol\";\r\nimport \"./IRecoverable.sol\";\r\n\r\n/**\r\n * @title Recoverable\r\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\r\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\r\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\r\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\r\n * declareLost function on the recovery hub to post a deposit and claim that the shares assigned to a\r\n * specific address are lost.\r\n * If an attacker trying to claim shares belonging to someone else, they risk losing the deposit\r\n * as it can be claimed at anytime by the rightful owner.\r\n * Furthermore, if \"getClaimDeleter\" is defined in the subclass, the returned address is allowed to\r\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\r\n * function, e.g. cases of front-running.\r\n * Most functionality is implemented in a shared RecoveryHub.\r\n */\r\nabstract contract ERC20Recoverable is ERC20Flaggable, IRecoverable {\r\n\r\n    uint8 private constant FLAG_CLAIM_PRESENT = 10;\r\n\r\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\r\n    IERC20 public customCollateralAddress;\r\n    // Rate the custom collateral currency is multiplied to be valued like one share.\r\n    uint256 public customCollateralRate;\r\n\r\n    uint256 constant CLAIM_PERIOD = 180 days;\r\n\r\n    IRecoveryHub public override immutable recovery;\r\n\r\n    constructor(IRecoveryHub recoveryHub){\r\n        recovery = recoveryHub;\r\n    }\r\n\r\n    modifier onlyRecovery {\r\n        _checkSender(address(recovery));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Returns the collateral rate for the given collateral type and 0 if that type\r\n     * of collateral is not accepted. By default, only the token itself is accepted at\r\n     * a rate of 1:1.\r\n     *\r\n     * Subclasses should override this method if they want to add additional types of\r\n     * collateral.\r\n     */\r\n    function getCollateralRate(IERC20 collateralType) public override virtual view returns (uint256) {\r\n        if (address(collateralType) == address(this)) {\r\n            return 1;\r\n        } else if (collateralType == customCollateralAddress) {\r\n            return customCollateralRate;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function claimPeriod() external pure override returns (uint256){\r\n        return CLAIM_PERIOD;\r\n    }\r\n\r\n    /**\r\n     * Allows subclasses to set a custom collateral besides the token itself.\r\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\r\n     * throws an exception or returns false on failure.\r\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\r\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\r\n     */\r\n    function _setCustomClaimCollateral(IERC20 collateral, uint256 rate) internal {\r\n        customCollateralAddress = collateral;\r\n        if (address(customCollateralAddress) == address(0)) {\r\n            customCollateralRate = 0; // disabled\r\n        } else {\r\n            if (rate == 0) {\r\n                revert Recoverable_RateZero();\r\n            }\r\n            customCollateralRate = rate;\r\n        }\r\n    }\r\n\r\n    function getClaimDeleter() virtual public view returns (address);\r\n\r\n    function transfer(address recipient, uint256 amount) override(ERC20Flaggable, IERC20) virtual public returns (bool) {\r\n        super.transfer(recipient, amount); // no need for safe transfer, as it's our own token\r\n        if (hasFlagInternal(msg.sender, FLAG_CLAIM_PRESENT)){\r\n            recovery.clearClaimFromToken(msg.sender);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function notifyClaimMade(address target) external override onlyRecovery {\r\n        setFlag(target, FLAG_CLAIM_PRESENT, true);\r\n    }\r\n\r\n    function notifyClaimDeleted(address target) external override onlyRecovery {\r\n        setFlag(target, FLAG_CLAIM_PRESENT, false);\r\n    }\r\n\r\n    function deleteClaim(address lostAddress) external {\r\n        _checkSender(getClaimDeleter());\r\n        recovery.deleteClaim(lostAddress);\r\n    }\r\n\r\n    function recover(address oldAddress, address newAddress) external override onlyRecovery {\r\n        _transfer(oldAddress, newAddress, balanceOf(oldAddress));\r\n    }\r\n\r\n}"
      },
      "project/contracts/recovery/IRecoverable.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"./IRecoveryHub.sol\";\r\n\r\ninterface IRecoverable is IERC20{\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// The new custom claim collateral rate has to be always > 0. \r\n    error Recoverable_RateZero();\r\n\r\n    // returns the recovery hub\r\n    function recovery() external view returns (IRecoveryHub);\r\n\r\n    function claimPeriod() external view returns (uint256);\r\n    \r\n    function notifyClaimMade(address target) external;\r\n\r\n    function notifyClaimDeleted(address target) external;\r\n\r\n    function getCollateralRate(IERC20 collateral) external view returns(uint256);\r\n\r\n    function recover(address oldAddress, address newAddress) external;\r\n\r\n}"
      },
      "project/contracts/recovery/IRecoveryHub.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./IRecoverable.sol\";\r\nimport \"../ERC20/IERC20.sol\";\r\n\r\ninterface IRecoveryHub {\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// Recovery can be disabled per address.\r\n    /// @param lostAddress The address for which the recovery is disabled.\r\n    error RecoveryHub_RecoveryDisabled(address lostAddress);\r\n    /// No valid collateral type\r\n    /// @param collateralType The address of collateral type token\r\n    error RecoveryHub_BadCollateral(IERC20 collateralType);\r\n    /// No token to able to recover on the lost address\r\n    /// @param token The token address which is checked for recovery.\r\n    /// @param lostAddress The lost address.\r\n    error RecoveryHub_NothingToRecover(IERC20 token, address lostAddress);\r\n    /// The was already a claim for this token and address.\r\n    /// @param token The token address.\r\n    /// @param lostAddress The lost address.\r\n    error RecoveryHub_AlreadyClaimed(IERC20 token, address lostAddress);\r\n    /// Sender has to be claimant\r\n    /// @param sender The msg.sender of the call\r\n    error RecoveryHub_InvalidSender(address sender);\r\n    /// No claim for this address exists\r\n    /// @param lostAddress The checked address \r\n    error RecoveryHub_ClaimNotFound(address lostAddress);\r\n    /// Recover can only be called after the claim period\r\n    /// @param claimPeriodEnd The timestamp when the period ends\r\n    /// @param currentTimestamp The block timestamp of the call\r\n    error RecoveryHub_InClaimPeriod(uint256 claimPeriodEnd, uint256 currentTimestamp);\r\n\r\n    function setRecoverable(bool flag) external;\r\n    \r\n    // deletes claim and transfers collateral back to claimer\r\n    function deleteClaim(address target) external;\r\n\r\n    // clears claim and transfers collateral to holder\r\n    function clearClaimFromToken(address holder) external;\r\n\r\n    function clearClaimFromUser(IRecoverable token) external;\r\n\r\n}"
      },
      "project/contracts/recovery/RecoveryHub.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./IRecoveryHub.sol\";\r\nimport \"./IRecoverable.sol\";\r\nimport \"../ERC20/IERC20.sol\";\r\nimport \"../utils/SafeERC20.sol\";\r\n\r\ncontract RecoveryHub is IRecoveryHub {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    // A struct that represents a claim made\r\n    struct Claim {\r\n        address claimant; // the person who created the claim\r\n        uint256 collateral; // the amount of collateral deposited\r\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\r\n        IERC20 currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\r\n    }\r\n\r\n    mapping(IRecoverable => mapping (address => Claim)) public claims; // there can be at most one claim per token and claimed address\r\n    mapping(address => bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\r\n\r\n    event ClaimMade(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 balance);\r\n    event ClaimCleared(IRecoverable indexed token, address indexed lostAddress, uint256 collateral);\r\n    event ClaimDeleted(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\r\n    event ClaimResolved(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\r\n\r\n    function setRecoverable(bool enabled) external override {\r\n        recoveryDisabled[msg.sender] = !enabled;\r\n    }\r\n\r\n    /**\r\n     * Some users might want to disable claims for their address completely.\r\n     * For example if they use a deep cold storage solution or paper wallet.\r\n     */\r\n    function isRecoverable(address target) public view returns (bool) {\r\n        return !recoveryDisabled[target];\r\n    }\r\n\r\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\r\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\r\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\r\n    * 2) The \"lost\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\r\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\r\n    *    whenever someone transfers funds to let claims be resolved automatically when the \"lost\" private key is\r\n    *    used again.\r\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\r\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\r\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\r\n    *    rightful owner of the deposit.\r\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\r\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\r\n    * through a shareholder register).\r\n    */\r\n    function declareLost(IRecoverable token, IERC20 collateralType, address lostAddress) external {\r\n        if(recoveryDisabled[lostAddress]) {\r\n            revert RecoveryHub_RecoveryDisabled(lostAddress);\r\n        }\r\n        uint256 collateralRate = IRecoverable(token).getCollateralRate(collateralType);\r\n        if (collateralRate == 0) {\r\n            // if the there is no rate the collateral isn't accepted\r\n            revert RecoveryHub_BadCollateral(collateralType);\r\n        }\r\n        uint256 balance = IERC20(token).balanceOf(lostAddress);\r\n        if (balance == 0) {\r\n            // if lost address has no balance, there also nothing to recover\r\n            revert RecoveryHub_NothingToRecover(token, lostAddress);\r\n        }\r\n        uint256 collateral = balance * collateralRate;\r\n        IERC20 currency = IERC20(collateralType);\r\n        if (claims[token][lostAddress].collateral > 0) {\r\n            revert RecoveryHub_AlreadyClaimed(token, lostAddress);\r\n        }\r\n\r\n        claims[token][lostAddress] = Claim({\r\n            claimant: msg.sender,\r\n            collateral: collateral,\r\n            // rely on time stamp is ok, no exact time stamp needed\r\n            // solhint-disable-next-line not-rely-on-time\r\n            timestamp: block.timestamp,\r\n            currencyUsed: collateralType\r\n        });\r\n        emit ClaimMade(token, lostAddress, msg.sender, balance);\r\n        // errors like no allowance/no balance revert generally in the transferFrom\r\n        currency.safeTransferFrom(msg.sender, address(this), collateral);\r\n        IRecoverable(token).notifyClaimMade(lostAddress);\r\n    }\r\n\r\n    function getClaimant(IRecoverable token, address lostAddress) external view returns (address) {\r\n        return claims[token][lostAddress].claimant;\r\n    }\r\n\r\n    function getCollateral(IRecoverable token, address lostAddress) external view returns (uint256) {\r\n        return claims[token][lostAddress].collateral;\r\n    }\r\n\r\n    function getCollateralType(IRecoverable token, address lostAddress) external view returns (IERC20) {\r\n        return claims[token][lostAddress].currencyUsed;\r\n    }\r\n\r\n    function getTimeStamp(IRecoverable token, address lostAddress) external view returns (uint256) {\r\n        return claims[token][lostAddress].timestamp;\r\n    }\r\n\r\n    /**\r\n     * Clears a claim after the key has been found again and assigns the collateral to the \"lost\" address.\r\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\r\n     */\r\n    function clearClaimFromToken(address holder) external override {\r\n        clearClaim(IRecoverable(msg.sender), holder);\r\n    }\r\n\r\n    function clearClaimFromUser(IRecoverable token) external override {\r\n        clearClaim(token, msg.sender);\r\n    }\r\n\r\n    function clearClaim(IRecoverable token, address holder) private {\r\n        Claim memory claim = claims[token][holder];\r\n        if (claim.collateral > 0){\r\n            IERC20 currency = IERC20(claim.currencyUsed);\r\n            delete claims[token][holder];\r\n            currency.safeTransfer(holder, claim.collateral);\r\n            emit ClaimCleared(token, holder, claim.collateral);\r\n        }\r\n        IRecoverable(token).notifyClaimDeleted(holder);\r\n    }\r\n\r\n   /**\r\n    * After the claim period has passed, the claimant can call this function to send the\r\n    * tokens on the lost address as well as the collateral to himself.\r\n    */\r\n    function recover(IRecoverable token, address lostAddress) external {\r\n        Claim memory claim = claims[token][lostAddress];\r\n        uint256 collateral = claim.collateral;\r\n        if (collateral == 0) {\r\n            revert RecoveryHub_ClaimNotFound(lostAddress);\r\n        }\r\n        address claimant = claim.claimant;\r\n        if (claimant != msg.sender) {\r\n            revert RecoveryHub_InvalidSender(msg.sender);\r\n        }\r\n        // rely on time stamp is ok, no exact time stamp needed\r\n        // solhint-disable-next-line not-rely-on-time\r\n        uint256 claimPeriodEnd = claim.timestamp + IRecoverable(token).claimPeriod();\r\n        if (claimPeriodEnd > block.timestamp) {\r\n            revert RecoveryHub_InClaimPeriod(claimPeriodEnd, block.timestamp);\r\n        }\r\n        delete claims[token][lostAddress];\r\n        emit ClaimResolved(token, lostAddress, claimant, collateral);\r\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\r\n        IERC20 currency = IERC20(claim.currencyUsed);\r\n        currency.safeTransfer(claimant, collateral);\r\n        IRecoverable(token).recover(lostAddress, claimant);\r\n    }\r\n\r\n    /**\r\n     * The token contract can delete claims. It is the responsibility of the token contract to make sure\r\n     * only authorized parties can trigger such a call.\r\n     */\r\n    function deleteClaim(address lostAddress) external override {\r\n        IRecoverable token = IRecoverable(msg.sender);\r\n        Claim memory claim = claims[token][lostAddress];\r\n        IERC20 currency = IERC20(claim.currencyUsed);\r\n        if (claim.collateral == 0) {\r\n            revert RecoveryHub_ClaimNotFound(lostAddress);\r\n        }\r\n        delete claims[token][lostAddress];\r\n        emit ClaimDeleted(token, lostAddress, claim.claimant, claim.collateral);\r\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\r\n        currency.safeTransfer(claim.claimant, claim.collateral);\r\n    }\r\n\r\n}"
      },
      "project/contracts/shares/AllowlistDraggableShares.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/ERC20Allowlistable.sol\";\r\nimport \"./DraggableShares.sol\";\r\n\r\ncontract AllowlistDraggableShares is DraggableShares, ERC20Allowlistable {\r\n\r\n  constructor(\r\n    string memory _terms,\r\n    DraggableParams memory _params,\r\n    IRecoveryHub _recoveryHub,\r\n    IOfferFactory _offerFactory,\r\n    address _oracle,\r\n    Permit2Hub _permit2Hub\r\n  )\r\n    DraggableShares(_terms, _params, _recoveryHub, _offerFactory, _oracle, _permit2Hub)\r\n    Ownable(_oracle)\r\n  {\r\n    // initialization is done in ERC20Allowlistbale and DraggableShares\r\n  }\r\n\r\n  function transfer(address to, uint256 value) virtual override(ERC20Flaggable, DraggableShares) public returns (bool) {\r\n      return super.transfer(to, value);\r\n  }\r\n  \r\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Allowlistable, DraggableShares) internal {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n  }\r\n\r\n    function allowance(address owner, address spender) public view override(DraggableShares, ERC20Flaggable) returns (uint256) {\r\n        return super.allowance(owner,spender);\r\n  }\r\n\r\n}"
      },
      "project/contracts/shares/AllowlistShares.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../recovery/ERC20Recoverable.sol\";\r\nimport \"../ERC20/ERC20Allowlistable.sol\";\r\nimport \"./Shares.sol\";\r\n\r\ncontract AllowlistShares is Shares, ERC20Allowlistable {\r\n\r\n  constructor(\r\n    string memory _symbol,\r\n    string memory _name,\r\n    string memory _terms,\r\n    uint256 _totalShares,\r\n    IRecoveryHub _recoveryHub,\r\n    address _owner,\r\n    Permit2Hub _permit2Hub\r\n  )\r\n    Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub, _permit2Hub)\r\n    ERC20Allowlistable()\r\n  {\r\n    // initialization in shares\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount) override(ERC20Flaggable, Shares) virtual public returns (bool) {\r\n    return super.transfer(recipient, amount); \r\n  }\r\n\r\n  function _mint(address account, uint256 amount) internal override(ERC20Flaggable, Shares) {\r\n      super._mint(account, amount);\r\n  }\r\n\r\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Allowlistable) internal {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view override(Shares, ERC20Flaggable) returns (uint256) {\r\n        return super.allowance(owner,spender);\r\n  }\r\n\r\n}"
      },
      "project/contracts/shares/DraggableShares.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../recovery/ERC20Recoverable.sol\";\r\nimport \"../draggable/ERC20Draggable.sol\";\r\nimport \"../ERC20/ERC20PermitLight.sol\";\r\nimport \"../ERC20/ERC20Permit2.sol\";\r\n\r\n/**\r\n * @title CompanyName AG Shares SHA\r\n * @author Luzius Meisser, luzius@aktionariat.com\r\n *\r\n * This is an ERC-20 token representing share tokens of CompanyName AG that are bound to\r\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\r\n */\r\ncontract DraggableShares is ERC20Draggable, ERC20Recoverable, ERC20PermitLight, ERC20Permit2 {\r\n\r\n    // Version history:\r\n    // 1: pre permit\r\n    // 2: includes permit\r\n    // 3: added permit2 allowance, VERSION field\r\n    uint8 public constant VERSION = 3;\r\n\r\n    string public terms;\r\n\r\n    /// Event when the terms are changed with setTerms().\r\n    event ChangeTerms(string terms); \r\n\r\n    constructor(\r\n        string memory _terms,\r\n        DraggableParams memory _params,\r\n        IRecoveryHub _recoveryHub,\r\n        IOfferFactory _offerFactory,\r\n        address _oracle,\r\n        Permit2Hub _permit2Hub\r\n    )\r\n        ERC20Draggable(_params, _offerFactory, _oracle)\r\n        ERC20Recoverable(_recoveryHub)\r\n        ERC20Permit2(_permit2Hub)\r\n    {\r\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\r\n        _recoveryHub.setRecoverable(false);\r\n    }\r\n\r\n    function transfer(address to, uint256 value) virtual override(IERC20, ERC20Flaggable, ERC20Recoverable) public returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    /**\r\n     * Let the oracle act as deleter of invalid claims. In earlier versions, this was referring to the claim deleter\r\n     * of the wrapped token. But that stops working after a successful acquisition as the acquisition currency most\r\n     * likely does not have a claim deleter.\r\n     */\r\n    function getClaimDeleter() public view override returns (address) {\r\n        return oracle;\r\n    }\r\n\r\n    function getCollateralRate(IERC20 collateralType) public view override returns (uint256) {\r\n        uint256 rate = super.getCollateralRate(collateralType);\r\n        if (rate > 0) {\r\n            return rate;\r\n        } else {\r\n            // as long as it is binding, the conversion rate is 1:1\r\n            uint256 factor = isBinding() ? 1 : unwrapConversionFactor;\r\n            if (address(collateralType) == address(wrapped)) {\r\n                // allow wrapped token as collateral\r\n                return factor;\r\n            } else {\r\n                // If the wrapped contract allows for a specific collateral, we should too.\r\n                // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\r\n                return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * factor;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function allows the oracle to set the terms.\r\n     * @param _terms The new terms.\r\n     */\r\n    function setTerms(string calldata _terms) external override onlyOracle {\r\n        terms = _terms;\r\n        emit ChangeTerms(terms);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Draggable) internal {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override(ERC20Permit2, ERC20Flaggable, IERC20) returns (uint256) {\r\n        return super.allowance(owner, spender);\r\n    }\r\n\r\n}"
      },
      "project/contracts/shares/IShares.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/IERC20.sol\";\r\n\r\ninterface IShares is IERC20 {\r\n\r\n\t/*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n\t//////////////////////////////////////////////////////////////*/\r\n\t/// New total shares can't be below current valid supply\r\n\t/// @param totalSupply  The current valid supply. \r\n\t/// @param newTotalShares  The new max shares. \r\n\terror Shares_InvalidTotalShares(uint256 totalSupply, uint256 newTotalShares);\r\n\t/// Array lengths have to be equal. \r\n\t/// @param targets Array length of targets. \r\n\t/// @param amount Array length of amounts. \r\n\terror Shares_UnequalLength(uint256 targets, uint256 amount);\r\n\t/// It isn't possible to mint more share token than max shares in existens. \r\n\t/// @param totalShares The max amount of shares. \r\n\t/// @param needed The max amount of shares needed (current valid supply + new mint amount). \r\n\terror Shares_InsufficientTotalShares(uint256 totalShares, uint256 needed);\r\n\r\n\tfunction burn(uint256) external;\r\n\r\n\tfunction totalShares() external view returns (uint256);\r\n}"
      },
      "project/contracts/shares/Shares.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: LicenseRef-Aktionariat\r\n*\r\n* MIT License with Automated License Fee Payments\r\n*\r\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\r\n*\r\n* Permission is hereby granted to any person obtaining a copy of this software\r\n* and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy,\r\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n* Software, and to permit persons to whom the Software is furnished to do so,\r\n* subject to the following conditions:\r\n*\r\n* - The above copyright notice and this permission notice shall be included in\r\n*   all copies or substantial portions of the Software.\r\n* - All automated license fee payments integrated into this and related Software\r\n*   are preserved.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../ERC20/ERC20Named.sol\";\r\nimport \"../ERC20/ERC20PermitLight.sol\";\r\nimport \"../ERC20/ERC20Permit2.sol\";\r\nimport \"../ERC20/IERC677Receiver.sol\";\r\nimport \"../recovery/ERC20Recoverable.sol\";\r\nimport \"../shares/IShares.sol\";\r\n\r\n/**\r\n * @title CompanyName AG Shares\r\n * @author Luzius Meisser, luzius@aktionariat.com\r\n *\r\n * These tokens represent ledger-based securities according to article 973d of the Swiss Code of Obligations.\r\n * This smart contract serves as an ownership registry, enabling the token holders to register them as\r\n * shareholders in the issuer's shareholder registry. This is equivalent to the traditional system\r\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\r\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\r\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\r\n * themselves. For example, in case the company pays out a dividend to a previous shareholder because\r\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\r\n * the \"wrong\" shareholder. In relation to the company, only the registered shareholders count as such.\r\n */\r\ncontract Shares is ERC20Recoverable, ERC20Named, ERC20PermitLight, ERC20Permit2, IShares{\r\n\r\n    // Version history:\r\n    // 1: everything before 2022-07-19\r\n    // 2: added mintMany and mintManyAndCall, added VERSION field\r\n    // 3: added permit\r\n    // 4: refactor to custom errors, added allowance for permit2\r\n    uint8 public constant VERSION = 4;\r\n\r\n    string public terms;\r\n\r\n    uint256 public override totalShares; // total number of shares, maybe not all tokenized\r\n    uint256 public invalidTokens;\r\n\r\n    event Announcement(string message);\r\n    event TokensDeclaredInvalid(address indexed holder, uint256 amount, string message);\r\n    event ChangeTerms(string terms);\r\n    event ChangeTotalShares(uint256 total);\r\n\r\n    constructor(\r\n        string memory _symbol,\r\n        string memory _name,\r\n        string memory _terms,\r\n        uint256 _totalShares,\r\n        address _owner,\r\n        IRecoveryHub _recoveryHub,\r\n        Permit2Hub _permit2Hub\r\n    )\r\n        ERC20Named(_symbol, _name, 0, _owner) \r\n        ERC20Recoverable(_recoveryHub)\r\n        ERC20Permit2(_permit2Hub)\r\n    {\r\n        totalShares = _totalShares;\r\n        terms = _terms;\r\n        invalidTokens = 0;\r\n        _recoveryHub.setRecoverable(false); \r\n    }\r\n\r\n    function setTerms(string memory _terms) external onlyOwner {\r\n        terms = _terms;\r\n        emit ChangeTerms(_terms);\r\n    }\r\n\r\n    /**\r\n     * Declares the number of total shares, including those that have not been tokenized and those\r\n     * that are held by the company itself. This number can be substiantially higher than totalSupply()\r\n     * in case not all shares have been tokenized. Also, it can be lower than totalSupply() in case some\r\n     * tokens have become invalid.\r\n     */\r\n    function setTotalShares(uint256 _newTotalShares) external onlyOwner() {\r\n        uint256 _totalValidSupply = totalValidSupply();\r\n        if (_newTotalShares < _totalValidSupply) {\r\n            revert Shares_InvalidTotalShares(_totalValidSupply, _newTotalShares);\r\n            \r\n        }\r\n        totalShares = _newTotalShares;\r\n        emit ChangeTotalShares(_newTotalShares);\r\n    }\r\n\r\n    /**\r\n     * Allows the issuer to make public announcements that are visible on the blockchain.\r\n     */\r\n    function announcement(string calldata message) external onlyOwner() {\r\n        emit Announcement(message);\r\n    }\r\n\r\n    /**\r\n     * See parent method for collateral requirements.\r\n     */\r\n    function setCustomClaimCollateral(IERC20 collateral, uint256 rate) external onlyOwner() {\r\n        super._setCustomClaimCollateral(collateral, rate);\r\n    }\r\n\r\n    function getClaimDeleter() public override view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * Signals that the indicated tokens have been declared invalid (e.g. by a court ruling in accordance\r\n     * with article 973g of the Swiss Code of Obligations) and got detached from\r\n     * the underlying shares. Invalid tokens do not carry any shareholder rights any more.\r\n     *\r\n     * This function is purely declarative. It does not technically immobilize the affected tokens as\r\n     * that would give the issuer too much power.\r\n     */\r\n    function declareInvalid(address holder, uint256 amount, string calldata message) external onlyOwner() {\r\n        uint256 holderBalance = balanceOf(holder);\r\n        if (amount > holderBalance) {\r\n            revert ERC20InsufficientBalance(holder, holderBalance, amount);\r\n        }\r\n        invalidTokens += amount;\r\n        emit TokensDeclaredInvalid(holder, amount, message);\r\n    }\r\n\r\n    /**\r\n     * The total number of valid tokens in circulation. In case some tokens have been declared invalid, this\r\n     * number might be lower than totalSupply(). Also, it will always be lower than or equal to totalShares().\r\n     */\r\n    function totalValidSupply() public view returns (uint256) {\r\n        return totalSupply() - invalidTokens;\r\n    }\r\n\r\n    /**\r\n     * Allows the company to tokenize shares and transfer them e.g to the draggable contract and wrap them.\r\n     * If these shares are newly created, setTotalShares must be called first in order to adjust the total number of shares.\r\n     */\r\n    function mintAndCall(address shareholder, address callee, uint256 amount, bytes calldata data) external {\r\n        mint(callee, amount);\r\n        if (!IERC677Receiver(callee).onTokenTransfer(shareholder, amount, data)) {\r\n            revert IERC677Receiver.IERC677_OnTokenTransferFailed();\r\n        }\r\n    }\r\n\r\n    function mintManyAndCall(address[] calldata target, address callee, uint256[] calldata amount, bytes calldata data) external {\r\n        uint256 len = target.length;\r\n        if (len != amount.length) {\r\n            revert Shares_UnequalLength(len, amount.length);\r\n        }\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i<len; i++){\r\n            total += amount[i];\r\n        }\r\n        mint(callee, total);\r\n        for (uint256 i = 0; i<len; i++){\r\n            if(!IERC677Receiver(callee).onTokenTransfer(target[i], amount[i], data)){\r\n                revert IERC677Receiver.IERC677_OnTokenTransferFailed();\r\n            }\r\n        }\r\n    }\r\n\r\n    function mint(address target, uint256 amount) public onlyOwner {\r\n        _mint(target, amount);\r\n    }\r\n\r\n    function mintMany(address[] calldata target, uint256[] calldata amount) public onlyOwner {\r\n        uint256 len = target.length;\r\n        if (len != amount.length) {\r\n            revert Shares_UnequalLength(len, amount.length);\r\n        }\r\n        for (uint256 i = 0; i<len; i++){\r\n            _mint(target[i], amount[i]);\r\n        }\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual override {\r\n        uint256 newValidSupply = totalValidSupply() + amount;\r\n        if (newValidSupply > totalShares) {\r\n            revert Shares_InsufficientTotalShares(totalShares, newValidSupply);\r\n        }\r\n        super._mint(account, amount);\r\n    }\r\n\r\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20Flaggable, IERC20) public returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    /**\r\n     * Transfers _amount tokens to the company and burns them.\r\n     * The meaning of this operation depends on the circumstances and the fate of the shares does\r\n     * not necessarily follow the fate of the tokens. For example, the company itself might call\r\n     * this function to implement a formal decision to destroy some of the outstanding shares.\r\n     * Also, this function might be called by an owner to return the shares to the company and\r\n     * get them back in another form under an according agreement (e.g. printed certificates or\r\n     * tokens on a different blockchain). It is not recommended to call this function without\r\n     * having agreed with the company on the further fate of the shares in question.\r\n     */\r\n    function burn(uint256 _amount) override external {\r\n        _transfer(msg.sender, address(this), _amount);\r\n        _burn(address(this), _amount);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override(ERC20Permit2, ERC20Flaggable, IERC20) returns (uint256) {\r\n        return super.allowance(owner, spender);\r\n    }\r\n\r\n}"
      },
      "project/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n// and modified it.\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nlibrary Address {\r\n\r\n    /// @param target Target address to call the function on.\r\n    error Address_NotTransferNorContract(address target);\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n        return account.code.length > 0;\r\n    }\r\n    \r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\r\n        if (data.length != 0 && !isContract(target)) {\r\n            revert Address_NotTransferNorContract(target);\r\n        }\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else if (returndata.length > 0) {\r\n            assembly{\r\n                revert (add (returndata, 0x20), mload (returndata))\r\n            }\r\n        } else {\r\n           revert(\"failed\");\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/utils/factory/AllowlistDraggableFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport { AllowlistDraggableShares, DraggableParams } from \"../../shares/AllowlistDraggableShares.sol\";\r\nimport { IERC20Permit } from \"../../ERC20/IERC20Permit.sol\";\r\nimport { FactoryManager } from \"./FactoryManager.sol\";\r\nimport { TokenConfig } from \"./FactoryStructs.sol\";\r\nimport { Ownable } from \"../Ownable.sol\";\r\n\r\n/**\r\n * @title Allowlist draggable factory\r\n * @author muratogat\r\n * \r\n * @notice This contract is responsible for creating new AllowlistDraggableShares tokens\r\n * @dev Inherits from Ownable for access control\r\n */\r\ncontract AllowlistDraggableFactory is Ownable {\r\n\r\n    /// @notice The factory manager contract\r\n    FactoryManager public manager;\r\n\r\n    /// @notice Emitted when the factory manager is updated\r\n    /// @param manager The new factory manager address\r\n    event FactoryManagerUpdated(FactoryManager manager);\r\n\r\n    /**\r\n     * @notice Constructs a new AllowlistDraggableFactory\r\n     * @param _owner The address that will be set as the owner of the contract\r\n     */\r\n    constructor(address _owner) Ownable(_owner){}\r\n\r\n    /**\r\n     * @notice Creates a new AllowlistDraggableShares token\r\n     * @param tokenConfig The configuration for the new token\r\n     * @param tokenOwner The address that will own the new token\r\n     * @param token The address of the ERC20Permit token to be used\r\n     * @return IERC20Permit The address of the newly created AllowlistDraggableShares token\r\n     */\r\n    function createAllowlistDraggable(TokenConfig calldata tokenConfig, address tokenOwner, IERC20Permit token, string calldata _salt) external returns (IERC20Permit) {\r\n        bytes32 salt = bytes32(keccak256(abi.encodePacked(tokenConfig.symbol, token, _salt)));\r\n        DraggableParams memory params = DraggableParams(\r\n            token,\r\n            tokenConfig.quorumDrag,\r\n            tokenConfig.quorumMigration,\r\n            tokenConfig.votePeriod\r\n        );\r\n\r\n        return new AllowlistDraggableShares{salt: salt}(\r\n            tokenConfig.terms,\r\n            params, \r\n            manager.recoveryHub(),\r\n            manager.offerFactory(),\r\n            tokenOwner,\r\n            manager.permit2Hub()\r\n        );\r\n    }\r\n\r\n    function predictAllowlistDraggableAddress(TokenConfig calldata tokenConfig, address tokenOwner, IERC20Permit token, string calldata _salt) external view returns (address) {\r\n        bytes32 salt = bytes32(keccak256(abi.encodePacked(tokenConfig.symbol, token, _salt)));\r\n        DraggableParams memory params = DraggableParams(\r\n            token,\r\n            tokenConfig.quorumDrag,\r\n            tokenConfig.quorumMigration,\r\n            tokenConfig.votePeriod\r\n        );\r\n\r\n        bytes32 initCodeHash = keccak256(abi.encodePacked(type(AllowlistDraggableShares).creationCode, abi.encode(tokenConfig.terms, params, manager.recoveryHub(), manager.offerFactory(), tokenOwner, manager.permit2Hub())));\r\n        bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash));\r\n        return address(uint160(uint256(hashResult)));\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new factory manager\r\n     * @dev Can only be called by the contract owner\r\n     * @param _manager The address of the new factory manager\r\n     */\r\n    function setManager(FactoryManager _manager) external onlyOwner {\r\n        manager = _manager;\r\n        emit FactoryManagerUpdated(manager);\r\n    }\r\n\r\n}"
      },
      "project/contracts/utils/factory/FactoryManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport { IOfferFactory } from \"../../draggable/IOfferFactory.sol\";\r\nimport { MultiSigCloneFactory } from \"../../multisig/MultiSigCloneFactory.sol\";\r\nimport { Ownable } from \"../Ownable.sol\";\r\nimport { PaymentHub } from \"../../brokerbot/PaymentHub.sol\";\r\nimport { Permit2Hub } from \"../Permit2Hub.sol\";\r\nimport { RecoveryHub } from \"../../recovery/RecoveryHub.sol\";\r\n\r\n/**\r\n * @title Factory Mangager for common contracts\r\n * @author muratogat\r\n * \r\n */\r\ncontract FactoryManager is Ownable {\r\n\r\n  IOfferFactory public offerFactory;\r\n  MultiSigCloneFactory public multisigFactory;\r\n  PaymentHub public paymentHub;\r\n  RecoveryHub public recoveryHub;\r\n  Permit2Hub public permit2Hub;\r\n\r\n  event PaymentHubUpdated(PaymentHub indexed paymentHub);\r\n  event OfferFactoryUpdated(IOfferFactory indexed offerFactory);\r\n  event RecoveryHubUpdated(RecoveryHub indexed recoveryHub);\r\n  event Permit2HubUpdated(Permit2Hub indexed permit2Hub);\r\n  event MultiSigCloneFactoryUpdated(MultiSigCloneFactory indexed MultiSigCloneFactory);\r\n\r\n  constructor(address _owner) Ownable(_owner) {}\r\n\r\n\r\n  function setPaymentHub(PaymentHub _paymentHub) external onlyOwner() {\r\n    paymentHub = _paymentHub;\r\n    emit PaymentHubUpdated(paymentHub);\r\n  }\r\n\r\n  function setOfferFactory(IOfferFactory _offerFactory) external onlyOwner() {\r\n    offerFactory = _offerFactory;\r\n    emit OfferFactoryUpdated(offerFactory);\r\n  }\r\n\r\n  function setRecoveryHub(RecoveryHub _recoveryHub) external onlyOwner() {\r\n    recoveryHub = _recoveryHub;\r\n    emit RecoveryHubUpdated(recoveryHub);\r\n  }\r\n  \r\n  function setMultiSigCloneFactory(MultiSigCloneFactory _multisigFactory) external onlyOwner() {\r\n    multisigFactory = _multisigFactory;\r\n    emit MultiSigCloneFactoryUpdated(multisigFactory);\r\n  }\r\n\r\n  function setPermit2Hub(Permit2Hub _permit2Hub) external onlyOwner() {\r\n    permit2Hub = _permit2Hub;\r\n    emit Permit2HubUpdated(permit2Hub);\r\n  }\r\n}"
      },
      "project/contracts/utils/factory/FactoryStructs.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport { IERC20 } from \"../../ERC20/IERC20.sol\";\r\n\r\nstruct TokenConfig{\r\n  string name;\r\n  string symbol;\r\n  string terms;\r\n  bool draggable;\r\n  uint256 numberOfShares;\r\n  uint256 quorumDrag;\r\n  uint256 quorumMigration;\r\n  uint256 votePeriod;\r\n}\r\n\r\nstruct BrokerbotConfig {\r\n  uint256 price;\r\n  uint256 increment;\r\n  IERC20 baseCurrency;\r\n}"
      },
      "project/contracts/utils/factory/TokenFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nimport { AllowlistDraggableFactory } from \"./AllowlistDraggableFactory.sol\";\r\nimport { AllowlistShares, Shares } from \"../../shares/AllowlistShares.sol\";\r\nimport { FactoryManager } from \"./FactoryManager.sol\";\r\nimport { TokenConfig } from \"./FactoryStructs.sol\";\r\nimport { IERC20Permit } from \"../../ERC20/IERC20Permit.sol\";\r\nimport { Ownable } from \"../Ownable.sol\";\r\n\r\n/**\r\n * @title TokenFactory\r\n * @author muratogat\r\n * \r\n * @dev Factory to deploy shares contracts\r\n * @notice This contract allows the creation of share tokens with optional draggable functionality and allowlist features.\r\n */\r\ncontract TokenFactory is Ownable {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  \r\n  // Version history\r\n  // 1: Initial version\r\n  // 2: Allowlisting functionality always available\r\n  // 3: Token address prediction\r\n  uint8 public constant VERSION = 3;\r\n\r\n  /// @notice Factory manager contract\r\n  FactoryManager public manager;\r\n\r\n  /// @notice Allowlist draggable token factory contract\r\n  AllowlistDraggableFactory public allowlistDraggableFactory;\r\n\r\n  /// @dev Set of addresses for created share tokens\r\n  EnumerableSet.AddressSet private _sharesSet; \r\n\r\n  /// @dev Set of addresses for created draggable tokens\r\n  EnumerableSet.AddressSet private _draggableSet; \r\n\r\n  /// @notice Emitted when a base token is created\r\n  /// @param token The created token\r\n  /// @param owner The owner of the token\r\n  /// @param allowlist Indicates if the token has an allowlist\r\n  event BaseTokenCreated(IERC20Permit indexed token, address indexed owner, bool allowlist);\r\n\r\n  /// @notice Emitted when a draggable token is created\r\n  /// @param draggable The created draggable token\r\n  /// @param baseToken The base token associated with the draggable token\r\n  /// @param owner The owner of the draggable token\r\n  /// @param allowlist Indicates if the token has an allowlist\r\n  event DraggableTokenCreated(IERC20Permit indexed draggable, IERC20Permit indexed baseToken, address indexed owner, bool allowlist);\r\n\r\n  /// @notice Emitted when the factory manager is updated\r\n  /// @param manager The new factory manager\r\n  event FactoryManagerUpdated(address manager);\r\n\r\n  /// @notice Emitted when the allowlist draggable token factory is updated\r\n  /// @param factory The new allowlist draggable token factory\r\n  event AllowlistDraggableFactoryUpdated(AllowlistDraggableFactory factory);\r\n\r\n  /// @notice Error for invalid owner address\r\n  error InvalidOwner();\r\n\r\n  /**\r\n   * @notice Constructor for TokenFactory\r\n   * @param _owner The address of the contract owner\r\n   * @param _allowlistDraggableFactory The address of the allowlist draggable token factory\r\n   */\r\n  constructor(address _owner, AllowlistDraggableFactory _allowlistDraggableFactory) Ownable(_owner) {\r\n    allowlistDraggableFactory = _allowlistDraggableFactory;\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a new token\r\n   * @param tokenConfig Configuration of the token to be created\r\n   * @param tokenOwner The owner of the new token\r\n   * @return The address of the created token\r\n   */\r\n  function createToken(TokenConfig calldata tokenConfig, address tokenOwner, string calldata salt) external returns (IERC20Permit) {\r\n    if (tokenOwner == address(0)) revert InvalidOwner();\r\n    IERC20Permit token = _createBaseToken(tokenConfig, tokenOwner, salt);\r\n    if (tokenConfig.draggable) {\r\n      IERC20Permit draggable = _createDraggableToken(tokenConfig, tokenOwner, token, salt);\r\n      return draggable;\r\n    } else {\r\n      return token;\r\n    }\r\n  }\r\n\r\n  function predictTokenAddress(TokenConfig calldata tokenConfig, address tokenOwner, string calldata salt) external view returns (address baseToken, address draggableToken) {\r\n    bytes32 saltHash = bytes32(uint256(keccak256(abi.encodePacked(tokenConfig.symbol, salt))));\r\n    bytes32 initCodeHash = keccak256(abi.encodePacked(type(AllowlistShares).creationCode, abi.encode(tokenConfig.symbol, tokenConfig.name, tokenConfig.terms, tokenConfig.numberOfShares, manager.recoveryHub(), tokenOwner, manager.permit2Hub())));\r\n    bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), saltHash, initCodeHash));\r\n    address baseTokenAddress = address(uint160(uint256(hashResult)));\r\n\r\n    if (tokenConfig.draggable) {\r\n      address draggableTokenAddress = allowlistDraggableFactory.predictAllowlistDraggableAddress(tokenConfig, tokenOwner, IERC20Permit(baseTokenAddress), salt);\r\n      return (baseTokenAddress, draggableTokenAddress);\r\n    } else {\r\n      return (baseTokenAddress, address(0));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the factory manager\r\n   * @param _manager The new factory manager\r\n   */\r\n  function setManager(FactoryManager _manager) external onlyOwner() {\r\n    manager = _manager;\r\n    emit FactoryManagerUpdated(address(manager));\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the allowlist draggable token factory\r\n   * @param _allowlistDraggableFactory The new allowlist draggable token factory\r\n   */\r\n  function setAllowlistDraggableFactory(AllowlistDraggableFactory _allowlistDraggableFactory) external onlyOwner() {\r\n    allowlistDraggableFactory = _allowlistDraggableFactory;\r\n    emit AllowlistDraggableFactoryUpdated(allowlistDraggableFactory);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets all created share tokens\r\n   * @return An array of addresses of created share tokens\r\n   */\r\n  function getAllShares() external view returns (address[] memory) {\r\n    return _sharesSet.values();\r\n  }\r\n\r\n  /**\r\n   * @notice Gets all created draggable share tokens\r\n   * @return An array of addresses of created draggable share tokens\r\n   */\r\n  function getAllDraggableShares() external view returns (address[] memory) {\r\n    return _draggableSet.values();\r\n  }\r\n\r\n  function _createBaseToken(TokenConfig calldata tokenConfig, address tokenOwner, string calldata _salt) internal returns (IERC20Permit token) {\r\n    bytes32 salt = bytes32(uint256(keccak256(abi.encodePacked(tokenConfig.symbol, _salt))));\r\n    token = new AllowlistShares{salt: salt}(tokenConfig.symbol, tokenConfig.name, tokenConfig.terms, tokenConfig.numberOfShares, manager.recoveryHub(), tokenOwner, manager.permit2Hub());\r\n    _sharesSet.add(address(token));\r\n    emit BaseTokenCreated(token, tokenOwner, true);\r\n    return token;\r\n  }\r\n\r\n  function _createDraggableToken(TokenConfig calldata tokenConfig, address tokenOwner, IERC20Permit baseToken, string calldata _salt) internal returns (IERC20Permit draggable) {\r\n    draggable = allowlistDraggableFactory.createAllowlistDraggable(tokenConfig, tokenOwner, baseToken, _salt);\r\n    _draggableSet.add(address(draggable));\r\n    emit DraggableTokenCreated(draggable, baseToken, tokenOwner, true);\r\n    return draggable;\r\n  }\r\n}\r\n"
      },
      "project/contracts/utils/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n//\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\n//\r\n// Modifications:\r\n// - Replaced Context._msgSender() with msg.sender\r\n// - Made leaner\r\n// - Extracted interface\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    error Ownable_NotOwner(address sender);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor (address initialOwner) {\r\n        owner = initialOwner;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function _checkOwner() internal view {\r\n        if (msg.sender != owner) {\r\n            revert Ownable_NotOwner(msg.sender);\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/utils/Permit2Hub.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../utils/Ownable.sol\";\r\n\r\n/// @title Permit2Hub\r\n/// @dev This contract manages the Permit2 functionality and access control.\r\ncontract Permit2Hub is Ownable {\r\n  \r\n  /// @dev The address of the Permit2 contract.\r\n  address public immutable permit2;\r\n  /// @dev Flag to indicate whether Permit2 is disabled.\r\n  bool public permit2Disabled = false;\r\n\r\n  /// @dev Mapping to track addresses for which Permit2 is disabled.\r\n  mapping(address => bool) public permit2DisabledForAddress;\r\n\r\n  /// @dev Emitted when the Permit2 setting is changed.\r\n  event ChangedPermit2(bool newSetting);\r\n\r\n  /// @dev Initializes the Permit2Hub contract with the provided Permit2 address and owner address.\r\n  /// @param _permit2 The address of the Permit2 contract.\r\n  /// @param _owner The address of the owner.\r\n  constructor(address _permit2, address _owner) Ownable(_owner) {\r\n    permit2 = _permit2;\r\n  }\r\n\r\n  /// @dev Checks if Permit2 is enabled for the given owner and spender addresses.\r\n  /// @param owner The owner address.\r\n  /// @param spender The spender address, needs to be the permit2 contract.\r\n  /// @return A boolean indicating whether Permit2 is enabled.\r\n  function isPermit2Enabled(address owner, address spender) public view returns (bool){\r\n    return spender == permit2 && !permit2Disabled && !permit2DisabledForAddress[owner];\r\n  }\r\n\r\n  /// @dev Toggles the global Permit2 setting. Can only be called by the owner.\r\n  function togglePermit2() external onlyOwner {\r\n    permit2Disabled = !permit2Disabled;\r\n    emit ChangedPermit2(permit2Disabled);\r\n  }\r\n\r\n  /// @dev Sets the Permit2 status for a specific address.\r\n  /// @param enabled The status to set for the address.\r\n  function setPermit2(bool enabled) external {\r\n    permit2DisabledForAddress[msg.sender] = !enabled;\r\n  }\r\n}\r\n"
      },
      "project/contracts/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {IERC20} from \"../ERC20/IERC20.sol\";\r\nimport {IERC20Permit} from \"../ERC20/IERC20Permit.sol\";\r\nimport {Address} from \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        if (nonceAfter != nonceBefore + 1) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}"
      }
    }
  }
}