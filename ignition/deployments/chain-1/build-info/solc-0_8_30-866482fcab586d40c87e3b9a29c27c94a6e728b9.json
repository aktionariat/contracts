{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-866482fcab586d40c87e3b9a29c27c94a6e728b9",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/multisig/Rollout.sol": "project/contracts/multisig/Rollout.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "npm/@chainlink/contracts-ccip@1.6.0/:@chainlink/contracts/=npm/@chainlink/contracts@1.4.0/",
        "project/:@chainlink/contracts-ccip/=npm/@chainlink/contracts-ccip@1.6.0/",
        "project/:@chainlink/contracts-ccip/=npm/@chainlink/contracts-ccip@1.6.0/",
        "project/:@chainlink/contracts-ccip/=npm/@chainlink/contracts-ccip@1.6.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.3.0/"
      ]
    },
    "sources": {
      "npm/@chainlink/contracts-ccip@1.6.0/contracts/applications/CCIPReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from\n  \"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(\n    address router\n  ) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId.\n  /// @param interfaceId The interfaceId to check.\n  /// @return true if the interfaceId is supported.\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver.\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// - If this returns false or reverts, only tokens are transferred to the receiver.\n  /// - If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with it at the time of\n  /// execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage.\n  function _ccipReceive(\n    Client.Any2EVMMessage memory message\n  ) internal virtual;\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
      },
      "npm/@chainlink/contracts-ccip@1.6.0/contracts/interfaces/IAny2EVMMessageReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from  the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message. If this reverts, any token transfers also revert.\n  /// The message will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message.\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter.\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external;\n}\n"
      },
      "npm/@chainlink/contracts-ccip@1.6.0/contracts/interfaces/IRouterClient.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param destChainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(\n    uint64 destChainSelector\n  ) external view returns (bool supported);\n\n  /// @param destinationChainSelector The destination chainSelector.\n  /// @param message The cross-chain CCIP message including data and/or tokens.\n  /// @return fee returns execution fee for the message.\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain.\n  /// @param destinationChainSelector The destination chain ID.\n  /// @param message The cross-chain CCIP message including data and/or tokens.\n  /// @return messageId The message ID.\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept.\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
      },
      "npm/@chainlink/contracts-ccip@1.6.0/contracts/libraries/Client.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\n    bytes data; // Data payload.\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\n  }\n\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\n  // for a chain.\n  // Note: not available for Solana VM based chains.\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\n  /// enforced, meaning if the expected value is not set, the message request will revert.\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\n  struct GenericExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  // Extra args tag for chains that use the Solana VM.\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\n\n  struct SVMExtraArgsV1 {\n    uint32 computeUnits;\n    uint64 accountIsWritableBitmap;\n    bool allowOutOfOrderExecution;\n    bytes32 tokenReceiver;\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\n    bytes32[] accounts;\n  }\n\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\n\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\n    + 32 // token_address\n    + 4 // gas_amount\n    + 4 // extra_data overhead\n    + 32 // amount\n    + 32 // size of the token lookup table account\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\n    + 32 // per-chain token pool config, not included in the token lookup table\n    + 32 // per-chain token billing config, not always included in the token lookup table\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\n\n  /// @dev Number of overhead accounts needed for message execution on SVM.\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\n\n  /// @dev The size of each SVM account address in bytes.\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\n\n  function _argsToBytes(\n    GenericExtraArgsV2 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n\n  function _svmArgsToBytes(\n    SVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
      },
      "npm/@chainlink/contracts@1.4.0/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.3.0/proxy/Clones.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.3.0/utils/Create2.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.3.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "project/contracts/multisig/MultichainWallet.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/contracts/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol\";\nimport \"./MultiSigWallet.sol\";\n\ncontract MultichainWallet is CCIPReceiver, MultiSigWallet {\n\n    uint64 public constant MAINNET_CHAIN_SELECTOR = 5009297550715157269;\n\n    error InvalidSourceChain(uint64 selector);\n    error InvalidDestinationChain();\n    error InvalidSender(address sender);\n    error InsufficientNativeFeeToken(uint256 found, uint256 required);\n\n    event SyncSent(bytes32 msgId, uint64 chain, address signerList, uint8 power);\n    event SyncReceived(bytes32 msgId, address signerList, uint8 power);\n\n    constructor(IArgumentSource args) CCIPReceiver(args.router()){\n        // Must only be used to initialize immutables as clones won't inherit other state\n    }\n\n    function _ccipReceive(Client.Any2EVMMessage memory message) internal override {\n        if (block.chainid == 1) revert InvalidDestinationChain();\n        if (message.sourceChainSelector != MAINNET_CHAIN_SELECTOR) revert InvalidSourceChain(message.sourceChainSelector);\n        address decodedSender = abi.decode(message.sender, (address));\n        if (decodedSender != address(this)) revert InvalidSender(decodedSender);\n        \n        (address[] memory signerList, uint8[] memory powers) = abi.decode(message.data, (address[], uint8[]));\n        for (uint i=0; i<signerList.length; i++){\n            _setSigner(signerList[i], powers[i]);\n            emit SyncReceived(message.messageId, signerList[i], powers[i]);\n        }\n    }\n\n    function sync(uint64[] calldata targets, address[] calldata signerList, address feeToken_) external payable {\n        for (uint i=0; i<targets.length; i++){\n            sync(targets[i], signerList, feeToken_);\n        }\n    }\n\n    function sync(uint64 chain, address signer) public payable {\n        address[] memory signerList = new address[](1);\n        signerList[0] = signer;\n        sync(chain, signerList, address(0x0));\n    }\n\n    function sync(uint64 chain, address[] calldata signerList) public payable {\n        sync(chain, signerList, address(0x0));\n    }\n\n    function sync(uint64 chain, address[] memory signerList, address feeToken_) public payable {\n        uint8[] memory powers = new uint8[](signerList.length);\n        for (uint i=0; i<signerList.length; i++){\n            powers[i] = signers(signerList[i]);\n        }\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(address(this)), // ABI-encoded receiver address\n            data: abi.encode(signerList, powers), // ABI-encoded string\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(\n                Client.GenericExtraArgsV2({\n                    gasLimit: 100_000, // Gas limit for the callback on the destination chain, should be more than enough, typically 40'000\n                    allowOutOfOrderExecution: true // Should always be possible according to CCIP support\n                })\n            ),\n            // Set the feeToken  address, indicating LINK will be used for fees\n            feeToken: feeToken_\n        });\n        uint256 fee =  IRouterClient(getRouter()).getFee(chain, message);\n        bytes32 msgId;\n        if (feeToken_ != address(0x0)) {\n            IERC20(message.feeToken).transferFrom(msg.sender, address(this), fee);\n            IERC20(message.feeToken).approve(getRouter(), fee);\n            msgId = IRouterClient(getRouter()).ccipSend(chain, message);\n        } else {\n            if (msg.value < fee) revert InsufficientNativeFeeToken(msg.value, fee);\n            msgId = IRouterClient(getRouter()).ccipSend{value: fee}(chain, message);\n            // return overpaid fee to sender. We don't care about the success of this call.\n            if(msg.value - fee > 0) payable(msg.sender).call{value: msg.value - fee}(\"\");\n        }\n        for (uint i=0; i<signerList.length; i++){\n            emit SyncSent(msgId, chain, signerList[i], powers[i]);\n        }\n    }\n\n}\n\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IArgumentSource {\n    function router() external returns (address);\n}"
      },
      "project/contracts/multisig/MultichainWalletArgumentSource.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * If this contract is deterministically deployed across chains, it can\n * be used to initialize immutables in the MultiChain wallet, yielding\n * the same addresses even if the immutables differ across chains.\n */\n\ncontract MultichainWalletArgumentSource {\n\n    // Router\n    // Mainnet  : 0x80226fc0Ee2b096224EeAc085Bb9a8cba1146f7D\n    // Optimism : 0x3206695CaE29952f4b0c22a169725a865bc8Ce0f\n    // Polygon  : 0x849c5ED5a80F5B408Dd4969b78c2C8fdf0565Bfe\n\n    // See https://docs.chain.link/ccip/directory/mainnet\n\n    address public router;\n\n    function initialize(address router_) external {\n        if (router == address(0)){\n            router = router_;\n        }\n    }\n}"
      },
      "project/contracts/multisig/MultiSigCloneFactory.sol": {
        "content": "\n/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract MultiSigCloneFactory {\n\n  address immutable public IMPLEMENTATION;\n\n  event ContractCreated(address indexed contractAddress, string indexed typeName, bytes32 salt);\n\n  constructor(address master){\n    IMPLEMENTATION = master;\n  }\n\n  function predict(bytes32 salt) external view returns (address) {\n    return Clones.predictDeterministicAddress(IMPLEMENTATION, salt);\n  }\n\n  function create(address owner, bytes32 salt) external returns (address) {\n    address payable instance = payable(Clones.cloneDeterministic(IMPLEMENTATION, salt));\n    IMultisig(instance).initialize(block.chainid == 1 ? owner : address(0x0));\n    emit ContractCreated(instance, \"MultiSigWallet\", salt);\n    return instance;\n  }\n}\n\ninterface IMultisig {\n  function initialize(address owner) external;\n}"
      },
      "project/contracts/multisig/MultiSigWallet.sol": {
        "content": "/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../utils/Address.sol\";\nimport \"./RLPEncode.sol\";\nimport \"./Nonce.sol\";\n\ncontract MultiSigWallet is Nonce {\n\n  // Version history\n  // Version 4: added event for send value\n  // Version 5: added version field and changed chain id\n  // Version 6: fixed potential reentrancy in execute\n  // Version 7: support authorizations, moved initialization to subclass, enable itself as signer\n  // Version 8: multichain synchronization with CCIP\n  // Version 9: removes setSigner isContract check\n  uint8 public constant VERSION = 0x8;\n\n  mapping (address signer => uint8 power) internal power; // The addresses that can co-sign transactions and the number of signatures needed\n\n  uint16 public signerCount;\n\n  event SignerChange(\n    address indexed signer,\n    uint8 signaturesNeeded\n  );\n\n  event Transacted(\n    address indexed toAddress,  // The address the transaction was sent to\n    bytes4 selector, // selected operation\n    address[] signers // Addresses of the signers used to initiate the transaction\n  );\n\n  event Received(address indexed sender, uint amount);\n  event SentEth(address indexed target, uint amount);\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n\t//////////////////////////////////////////////////////////////*/\n  /// Call needs to provide signature data. \n  error Multisig_SignatureMissing();\n  /// Sinature data isn't valid for the transaction or insufficient signer have signed the transaction. \n  /// @param signer The ecrecover'd signer.\n  error Multisig_InvalidSignDataOrInsufficientCosigner(address signer);\n  /// Each signature data entry has to be from a unique address. \n  /// @param from The address which has produced more than one signature. \n  error Multisig_DuplicateSignature(address from);\n  /// Signer is a contract or the 0x0 address. \n  /// @param signer The address of the invalid signer. \n  error Multisig_InvalidSigner(address signer);\n  /// The multisig needs to have > 0 signers. \n  error Multisig_InsufficientSigners();\n  /// Sender has to be single signer or the multisig itself. \n  /// @param sender The msg.sender of the transaction. \n  error Multisig_UnauthorizedSender(address sender);\n  /// Migration can't override current signer. \n  /// param destination The address to which the signer rights should be migrated. \n  error Multisig_InvalidDestination(address destination);\n\n  // We use the gas price field to get a unique id into our transactions.\n  // Note that 32 bits do not guarantee that no one can generate a contract with the\n  // same id, but it practically rules out that someone accidentally creates two\n  // two multisig contracts with the same id, and that's all we need to prevent\n  // replay-attacks.\n  function contractId() public view returns (bytes memory) {\n    return toBytes(uint32(uint160(address(this))) ^ block.chainid);\n  }\n\n  /**\n   * It should be possible to store ether on this address.\n   */\n  receive() external payable {\n    emit Received(msg.sender, msg.value);\n  }\n\n  /**\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\n   */\n  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external view returns (address[] memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId(), to, value, data);\n    return verifySignatures(transactionHash, v, r, s);\n  }\n\n  /**\n   * Checks if the execution of a transaction would succeed if it was properly signed.\n   */\n  function checkExecution(address to, uint value, bytes calldata data) external {\n    Address.functionCallWithValue(to, data, value);\n    revert(\"Test passed. Reverting.\");\n  }\n\n  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external returns (bytes memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId(), to, value, data);\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\n    flagUsed(nonce);\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\n    emit Transacted(to, extractSelector(data), found);\n    if (value > 0) {emit SentEth(to, value);}\n    return returndata;\n  }\n\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\n    if (data.length < 4){\n      return bytes4(0);\n    } else {\n      return bytes4(data[0]) | (bytes4(data[1]) >> 8) | (bytes4(data[2]) >> 16) | (bytes4(data[3]) >> 24);\n    }\n  }\n\n  function toBytes (uint256 x) public pure returns (bytes memory result) {\n    uint l = 0;\n    uint xx = x;\n    if (x >= 0x100000000000000000000000000000000) { x >>= 128; l += 16; }\n    if (x >= 0x10000000000000000) { x >>= 64; l += 8; }\n    if (x >= 0x100000000) { x >>= 32; l += 4; }\n    if (x >= 0x10000) { x >>= 16; l += 2; }\n    if (x >= 0x100) { x >>= 8; l += 1; }\n    if (x > 0x0) { l += 1; }\n    assembly {\n      result := mload (0x40)\n      mstore (0x40, add (result, add (l, 0x20)))\n      mstore (add (result, l), xx)\n      mstore (result, l)\n    }\n  }\n\n  // Note: does not work with contract creation\n  function calculateTransactionHash(uint128 sequence, bytes memory id, address to, uint value, bytes calldata data)\n    internal view returns (bytes32){\n    bytes[] memory all = new bytes[](9);\n    all[0] = toBytes(sequence); // sequence number instead of nonce\n    all[1] = id; // contract id instead of gas price\n    all[2] = bytes(\"\\x82\\x52\\x08\"); // 21000 gas limitation, cannot be lower\n    all[3] = abi.encodePacked (bytes1 (0x94), to);\n    all[4] = toBytes(value);\n    all[5] = data;\n    all[6] = toBytes(block.chainid);\n    all[7] = new bytes(0);\n    for (uint i = 0; i<8; i++){\n      if (i != 2 && i!= 3) {\n        all[i] = RLPEncode.encodeBytes(all[i]);\n      }\n    }\n    all[8] = all[7];\n    return keccak256(RLPEncode.encodeList(all));\n  }\n\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\n    public view returns (address[] memory) {\n    address[] memory found = new address[](r.length);\n    if (r.length == 0 ) {\n      revert Multisig_SignatureMissing();\n    }\n    for (uint i = 0; i < r.length; i++) {\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\n      uint8 signaturesNeeded = signers(signer);\n      if (signaturesNeeded == 0 || signaturesNeeded > r.length) {\n        revert Multisig_InvalidSignDataOrInsufficientCosigner(signer);\n      }\n      found[i] = signer;\n    }\n    requireNoDuplicates(found);\n    return found;\n  }\n\n  /**\n   * Returns the signatory power of the signer.\n   * Function name is 'signers' to keep back-wards compatilibity with anyone that\n   * previously accessed the previously public array 'signers' (now 'power') using the automatically generated\n   * getter function.\n   */\n  function signers(address signer) public view returns (uint8) {\n    if (signer == address(this)){\n      return 1;\n    } else {\n      return power[signer];\n    }\n  }\n\n  function requireNoDuplicates(address[] memory found) private pure {\n    for (uint i = 0; i < found.length; i++) {\n      for (uint j = i+1; j < found.length; j++) {\n        if (found[i] == found[j]) {\n          revert Multisig_DuplicateSignature(found[i]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Call this method through execute\n   */\n  function setSigner(address signer, uint8 signaturesNeeded) external authorized {\n    _setSigner(signer, signaturesNeeded);\n    if (signerCount == 0) {\n      revert Multisig_InsufficientSigners();\n    }\n  }\n\n  function _setSigner(address signer, uint8 signaturesNeeded) internal {\n    if (signer == address(0x0) || signer == address(this)) {\n      revert Multisig_InvalidSigner(signer);\n    }\n    uint8 prevValue = power[signer];\n    power[signer] = signaturesNeeded;\n    if (prevValue > 0 && signaturesNeeded == 0){\n      signerCount--;\n    } else if (prevValue == 0 && signaturesNeeded > 0){\n      signerCount++;\n    }\n    emit SignerChange(signer, signaturesNeeded);\n  }\n\n  modifier authorized() {\n    if (signers(msg.sender) != 1) revert Multisig_UnauthorizedSender(msg.sender);\n    _;\n  }\n\n}"
      },
      "project/contracts/multisig/MultiSigWalletMaster.sol": {
        "content": "/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../utils/Initializable.sol\";\nimport \"./MultichainWallet.sol\";\n\ncontract MultiSigWalletMaster is MultichainWallet, Initializable {\n\n  // args must be the same address across all chains and only be used to initiate immutables, address used for deployment was 0xf6d96dD440D020022134b8d902bedC2a2249E041\n  constructor(IArgumentSource args) MultichainWallet(args){\n    // Must only be used to initialize immutables as clones won't inherit other state\n  }\n\n  function initialize(address owner) external initializer {\n    if (owner != address(0x0)) _setSigner(owner, 1); // set initial owner\n  }\n\n}"
      },
      "project/contracts/multisig/Nonce.sol": {
        "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity >=0.8.0 <0.9.0;\n\ncontract Nonce {\n\n    uint256 public constant MAX_INCREASE = 100;\n    uint128 private constant MASK = 1 << 127;\n    uint128 private constant UNMASK = MASK ^ type(uint128).max;\n    \n    uint128 private max; // highest nonce ever used\n    uint128 private reg;\n    \n    /**\n     * The next recommended nonce, which is the highest nonce ever used plus one.\n     * \n     * Starts with 1^127 to prevent replay attacks, i.e. multisig transactions being replayed on individual signer accounts.\n     */\n    function nextNonce() external view returns (uint128){\n        return (max + 1) | MASK;\n    }\n\n    /**\n     * Returns whether the provided nonce can be used.\n     * For the 100 nonces in the interval [nextNonce(), nextNonce + 99], this is always true.\n     * For the nonces in the interval [nextNonce() - 129, nextNonce() - 1], this is true for the nonces that have not been used yet.\n     */ \n    function isFree(uint128 nonce) external view returns (bool){\n        uint128 unmaskedNonce = UNMASK & nonce;\n        return isValidHighNonce(unmaskedNonce) || isValidLowNonce(unmaskedNonce);\n    }\n\n    /**\n     * Flags the given nonce as used.\n     * Reverts if the provided nonce is not free.\n     */\n    function flagUsed(uint128 nonce) internal {\n        uint128 unmaskedNonce = UNMASK & nonce;\n        if (isValidHighNonce(unmaskedNonce)){\n            reg = ((reg << 1) | 0x1) << (unmaskedNonce - max - 1);\n            max = unmaskedNonce;\n        } else if (isValidLowNonce(unmaskedNonce)){\n            reg = uint128(reg | 0x1 << (max - unmaskedNonce - 1));\n        } else {\n            revert(\"used\");\n        }\n    }\n    \n    function setBoth(uint128 max_, uint128 reg_) private {\n        max = max_;\n        reg = reg_;\n    }\n\n    function isValidHighNonce(uint128 nonce) private view returns (bool){\n        return nonce > max && nonce <= max + MAX_INCREASE;\n    }\n\n    function isValidLowNonce(uint128 nonce) private view returns (bool){\n        if (nonce < max){\n            uint256 diff = max - nonce;\n            return diff <= 128 && ((0x1 << (diff - 1)) & reg == 0);\n        } else {\n            return false;\n        }\n    }\n    \n}"
      },
      "project/contracts/multisig/RLPEncode.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n/**\n * @title RLPEncode\n * @dev A simple RLP encoding library.\n * @author Bakaoh\n */\nlibrary RLPEncode {\n    /*\n     * Internal functions\n     */\n\n    /**\n     * @dev RLP encodes a byte string.\n     * @param self The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        bytes memory encoded;\n        if (self.length == 1 && uint8(self[0]) < 128) {\n            encoded = self;\n        } else {\n            encoded = abi.encodePacked(encodeLength(self.length, 128), self);\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        bytes memory list = flatten(self);\n        return abi.encodePacked(encodeLength(list.length, 192), list);\n    }\n\n    /*\n     * Private functions\n     */\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint len, uint offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint lenLen;\n            uint i = 1;\n            while (len >= i) {\n                lenLen++;\n                i <<= 8;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen-i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function memcpy(uint _dest, uint _src, uint _len) private pure {\n        uint dest = _dest;\n        uint src = _src;\n        uint len = _len;\n\n        for(; len >= 32; len -= 32) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint mask = type(uint).max >> (len << 3);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint len;\n        uint i;\n        for (i = 0; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint flattenedPtr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n            \n            uint listPtr;\n            // solhint-disable-next-line no-inline-assembly\n            assembly { listPtr := add(item, 0x20)}\n\n            memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += item.length;\n        }\n\n        return flattened;\n    }\n\n}"
      },
      "project/contracts/multisig/Rollout.sol": {
        "content": "pragma solidity >=0.8.0 <0.9.0;\n\nimport \"./MultichainWalletArgumentSource.sol\";\nimport \"./MultiSigWalletMaster.sol\";\nimport \"./MultiSigCloneFactory.sol\";\n\ncontract Rollout {\n\n  bytes32 private constant _salt = bytes32(uint256(42));\n\n  function rollout(address cciprouter) external returns (address) {\n    MultichainWalletArgumentSource source = new MultichainWalletArgumentSource{salt: _salt}();\n    source.initialize(cciprouter);\n    MultiSigWalletMaster master = new MultiSigWalletMaster{salt: _salt}(IArgumentSource(address(source)));\n    MultiSigCloneFactory factory = new MultiSigCloneFactory{salt: _salt}(address(master));\n    return address(factory);\n  }\n\n}"
      },
      "project/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n// and modified it.\n\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary Address {\n\n    /// @param target Target address to call the function on.\n    error Address_NotTransferNorContract(address target);\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n        return account.code.length > 0;\n    }\n    \n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\n        if (data.length != 0 && !isContract(target)) {\n            revert Address_NotTransferNorContract(target);\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            assembly{\n                revert (add (returndata, 0x20), mload (returndata))\n            }\n        } else {\n           revert(\"failed\");\n        }\n    }\n}"
      },
      "project/contracts/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    error Initializable_AlreadyInitalized();\n\n    /**\n     * @dev Modifier to protect the initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        if (_initialized) {\n            revert Initializable_AlreadyInitalized();\n        }\n        _;\n        _initialized = true;\n    }\n\n}"
      }
    }
  }
}