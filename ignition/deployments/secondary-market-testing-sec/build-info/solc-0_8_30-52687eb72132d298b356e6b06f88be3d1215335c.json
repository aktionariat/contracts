{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-52687eb72132d298b356e6b06f88be3d1215335c",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/market/TradeReactor.sol": "project/contracts/market/TradeReactor.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ERC20/IERC20.sol": {
        "content": "/**\r\n* SPDX-License-Identifier: MIT\r\n*\r\n* Copyright (c) 2016-2019 zOS Global Limited\r\n*\r\n*/\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\n\r\ninterface IERC20 {\r\n\r\n    // Optional functions\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}"
      },
      "project/contracts/ERC20/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit is IERC20 {\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Custom errors\r\n\t//////////////////////////////////////////////////////////////*/\r\n    /// Block timestamp must to be before deadline.\r\n    /// @param deadline The deadline of the permit.\r\n    /// @param blockTimestamp The timestamp of the execution block.\r\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\r\n    /// Recovered address must be owner and not zero address.\r\n    /// @param signerAddress The recovered signer address.\r\n    error Permit_InvalidSigner(address signerAddress);\r\n\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}"
      },
      "project/contracts/market/IntentHash.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {IERC20} from \"../ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Intent\r\n * @author Luzius Meisser, luzius@aktionariat.com\r\n * @author Murat Ögat, murat@aktionariat.com\r\n *\r\n * The struct to be signed for submitting orders to the TradeReactor contract and its hashing per EIP-712.\r\n */\r\n\r\nstruct Intent {\r\n\taddress owner;\r\n\taddress filler;\r\n\taddress tokenOut; // The ERC20 token sent out\r\n\tuint160 amountOut; // The maximum amount\r\n\taddress tokenIn; // The ERC20 token received\r\n\tuint160 amountIn; // The amount received in exchange for the maximum of the sent token\r\n\tuint256 creation; // timestamp at which the intent was created\r\n\tuint256 expiration; // timestamp at which the intent expires\r\n\tbytes data;\r\n}\r\n\r\nlibrary IntentHash {\r\n\tbytes32 internal constant INTENT_TYPE_HASH = keccak256(\"Intent(address owner,address filler,address tokenOut,uint160 amountOut,address tokenIn,uint160 amountIn,uint256 creation,uint256 expiration,bytes data)\");\r\n\r\n\tfunction hash(Intent calldata intent) internal pure returns (bytes32) {\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encode(\r\n\t\t\t\t\tINTENT_TYPE_HASH,\r\n\t\t\t\t\tintent.owner,\r\n\t\t\t\t\tintent.filler,\r\n\t\t\t\t\tintent.tokenOut,\r\n\t\t\t\t\tintent.amountOut,\r\n\t\t\t\t\tintent.tokenIn,\r\n\t\t\t\t\tintent.amountIn,\r\n\t\t\t\t\tintent.creation,\r\n\t\t\t\t\tintent.expiration,\r\n\t\t\t\t\tkeccak256(intent.data)\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t}\r\n}\r\n"
      },
      "project/contracts/market/IntentVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {Intent, IntentHash} from \"./IntentHash.sol\";/**\r\n\r\n * @title IntentVerifier\r\n * @author Luzius Meisser, luzius@aktionariat.com\r\n * @author Murat Ögat, murat@aktionariat.com\r\n *\r\n * EIP-712 verifier, intended to be used with TradeReactor.sol to separate verifying logic from execution.\r\n * Recovers the signer from the signature of an Intent for secondary transaction and compares it to the intent owner.\r\n */\r\n\r\ncontract IntentVerifier {\r\n\r\n    using IntentHash for Intent;\r\n    \r\n    error InvalidSignatureLength();\r\n    error InvalidSignature();\r\n    error InvalidSigner();\r\n\r\n    // EIP-712 Domain Properties\r\n    // Name: \"TradeIntent\"\r\n    // Version: \"1\"\r\n    // Chain ID: current chain id\r\n    // Verifying Contract: this contract\r\n    // Salt: hash of \"aktionariat\" as bytes32\r\n\r\n    bytes32 private DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"),\r\n            keccak256(bytes(\"TradeIntent\")),\r\n            keccak256(bytes(\"1\")),\r\n            block.chainid,\r\n            address(this),\r\n            keccak256(bytes(\"aktionariat\"))\r\n    ));\r\n\r\n    function verifyIntentSignature(Intent calldata intent, bytes calldata sig) public view {\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            intent.hash()\r\n        ));\r\n\r\n        (uint8 v, bytes32 r, bytes32 s) = signatureToVRS(sig);\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n        if (recoveredAddress == address(0)) revert InvalidSignature();\r\n        if (recoveredAddress != intent.owner) revert InvalidSigner();\r\n    }\r\n\r\n    function signatureToVRS(bytes memory signature) private pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n        if (signature.length == 65) {\r\n            assembly {\r\n                r := mload(add(signature, 32))\r\n                s := mload(add(signature, 64))\r\n                v := and(mload(add(signature, 65)), 255)\r\n            }\r\n            if (v < 27) v += 27;\r\n        } else {\r\n            revert InvalidSignatureLength();\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/market/IReactor.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {Intent} from \"./IntentHash.sol\";\r\n\r\ninterface IReactor {\r\n\r\n    function verify(Intent calldata intent, bytes calldata sig) external view;\r\n    function signalIntent(Intent calldata intent, bytes calldata signature) external;\r\n    function getFilledAmount(Intent calldata intent) external view returns (uint160);\r\n    function getMaxValidAmount(Intent calldata sellerIntent, Intent calldata buyerIntent) external view returns (uint256);\r\n    function getTotalExecutionPrice(Intent calldata buyerIntent, Intent calldata sellerIntent, uint256 tradedAmount) external pure returns (uint256);\r\n    function process(Intent calldata sellerIntent, bytes calldata sellerSig, Intent calldata buyerIntent, bytes calldata buyerSig, uint256 tradedAmount, uint256 totalFee) external;\r\n\r\n}"
      },
      "project/contracts/market/TradeReactor.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {IERC20} from \"../ERC20/IERC20.sol\";\r\nimport {IntentVerifier} from \"./IntentVerifier.sol\";\r\nimport {Intent, IntentHash} from \"./IntentHash.sol\";\r\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\r\nimport {IReactor} from \"./IReactor.sol\";\r\n\r\n/**\r\n * @title TradeReactor Contract\r\n * @notice This contract handles the signaling and processing of trade intents between buyers and sellers.\r\n*/\r\ncontract TradeReactor is IReactor, IntentVerifier {\r\n\r\n    using IntentHash for Intent;\r\n    using SafeERC20 for IERC20;\r\n\r\n    mapping(bytes32 => uint160) public filledAmount;\r\n\r\n    /// @dev Emitted when an intent to trade is signaled.\r\n    /// @param owner The address of the intent owner.\r\n    /// @param filler The address of the filler, if any, that the intent is specifically directed to.\r\n    /// @param tokenOut The address of the token the owner wants to sell or exchange.\r\n    /// @param amountOut The amount of the tokenOut the owner wants to sell or exchange.\r\n    /// @param tokenIn The address of the token the owner wants to receive in exchange.\r\n    /// @param amountIn The amount of the tokenIn the owner wants to receive.\r\n    /// @param creation The creation time of the intent.\r\n    /// @param expiration The expiration time of the intent.\r\n    /// @param data Additional data that may be used in the trade execution.\r\n    /// @param signature The signature of the owner authorizing the intent.\r\n    event IntentSignal(address owner, address filler, address tokenOut, uint160 amountOut, address tokenIn, uint160 amountIn, uint256 creation, uint256 expiration, bytes data, bytes signature);\r\n\r\n    error OfferTooLow();\r\n    error InvalidFiller();\r\n    error TokenMismatch();\r\n    error SpreadTooLow(uint256 bid, uint256 ask, uint16 minSpread);\r\n    error OverFilled();\r\n    error IntentExpired(uint256 signatureDeadline);\r\n\r\n    /**\r\n     * @notice A function to publicly signal an intent to buy or sell a token so it can be picked up by the filler for processing.\r\n     * Alternaticely, the owner can directly communicate with the filler, without recording the intent on chain.\r\n     * @param intent The trade intent data structure. \r\n     * @param signature The signature of the intent owner.\r\n    */\r\n    function signalIntent(Intent calldata intent, bytes calldata signature) external {\r\n        verify(intent, signature);\r\n        emit IntentSignal(intent.owner, intent.filler, intent.tokenOut, intent.amountOut, intent.tokenIn, intent.amountIn, intent.creation, intent.expiration, intent.data, signature);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the asking price for a given amount of tokenOut.\r\n     * @dev Ideally called with an intent where tokenIn is a currency with many (e.g. 18) decimals.\r\n     * @dev TokenOut can have very few decimals.\r\n     * @param intent The trade intent data structure.\r\n     * @param amount The amount of tokenOut.\r\n     * @return The calculated asking price.\r\n     */\r\n    function getAsk(Intent calldata intent, uint256 amount) public pure returns (uint256) {\r\n        // We should make sure that the rounding is always for the benefit of the intent owner to prevent exploits\r\n        // Example: when the seller offers to sell 7 ABC for 10 CHF, the accurate price would be 4.2857....\r\n        // The naive approach to calculate the same price using integers would be 3 * 10 / 7 = 3\r\n        // But with the given approach, we get 10 - (7 - 3) * 10 / 7 = 5, which is higher than tha accurate price.\r\n        return intent.amountIn - intent.amountIn * (intent.amountOut - amount) / intent.amountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the bidding price for a given amount of tokenIn.\r\n     * @dev Ideally called with an intent where tokenOut is a currency with many (e.g. 18) decimals.\r\n     * @dev TokenIn can have very few decimals.\r\n     * @param intent The trade intent data structure.\r\n     * @param amount The amount of tokenIn.\r\n     * @return The calculated bidding price.\r\n     */\r\n    function getBid(Intent calldata intent, uint256 amount) public pure returns (uint256) {\r\n        // We should make sure that the rounding is always for the benefit of the intent owner to prevent exploits\r\n        // Example: when the buyer offers to buy 7 ABC for 10 CHF, but only 3 can be filled, the accurate price would be 4.2857....\r\n        // With this calculation, we get a rounded down bid of 10 * 3 / 7 = 4\r\n        return intent.amountOut * amount / intent.amountIn;\r\n    }\r\n\r\n    function verifyPriceMatch(Intent calldata buyerIntent, Intent calldata sellerIntent) public pure {\r\n        uint256 ask = getAsk(sellerIntent, 1);\r\n        uint256 bid = getBid(buyerIntent, 1);\r\n        if (bid < ask) revert OfferTooLow();\r\n    }\r\n\r\n    function getTotalExecutionPrice(Intent calldata buyerIntent, Intent calldata sellerIntent, uint256 tradedAmount) public pure returns (uint256) {\r\n        verifyPriceMatch(buyerIntent, sellerIntent);\r\n        uint256 executionPrice = (sellerIntent.creation >= buyerIntent.creation) ? getAsk(sellerIntent, tradedAmount) : getBid(buyerIntent, tradedAmount);\r\n        return executionPrice;\r\n    }\r\n\r\n    function getFilledAmount(Intent calldata intent) external view returns (uint160) {\r\n        return filledAmount[intent.hash()];\r\n    }\r\n\r\n    /**\r\n     * @notice Determines the maximum valid amount that can be traded based on seller and buyer intents.\r\n     * @param sellerIntent The seller's trade intent.\r\n     * @param buyerIntent The buyer's trade intent.\r\n     * @return The maximum valid trade amount.\r\n     */\r\n    function getMaxValidAmount(Intent calldata sellerIntent, Intent calldata buyerIntent) public view returns (uint256) {\r\n        verifyPriceMatch(buyerIntent, sellerIntent);\r\n\r\n        uint256 sellerUnfilled = sellerIntent.amountOut - filledAmount[sellerIntent.hash()];\r\n        uint256 buyerUnfilled = buyerIntent.amountIn - filledAmount[buyerIntent.hash()];\r\n        uint256 maxAmount = (sellerUnfilled > buyerUnfilled) ? buyerUnfilled : sellerUnfilled;\r\n\r\n        return maxAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Processes a trade between a seller and a buyer with the maximum valid amount.\r\n     * @param sellerIntent The seller's trade intent.\r\n     * @param sellerSig The seller's signature.\r\n     * @param buyerIntent The buyer's trade intent.\r\n     * @param buyerSig The buyer's signature.\r\n     */    \r\n    function process(Intent calldata sellerIntent, bytes calldata sellerSig, Intent calldata buyerIntent, bytes calldata buyerSig, uint256 totalFee) external {\r\n        process(sellerIntent, sellerSig, buyerIntent, buyerSig, getMaxValidAmount(sellerIntent, buyerIntent), totalFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Processes a trade between a seller and a buyer for a specified amount.\r\n     * @param sellerIntent The seller's trade intent.\r\n     * @param sellerSig The seller's signature.\r\n     * @param buyerIntent The buyer's trade intent.\r\n     * @param buyerSig The buyer's signature.\r\n     * @param tradedTokens The amount of the token to trade.\r\n     */\r\n    function process(Intent calldata sellerIntent, bytes calldata sellerSig, Intent calldata buyerIntent, bytes calldata buyerSig, uint256 tradedTokens, uint256 totalFee) public {\r\n        verify(sellerIntent, sellerSig);\r\n        verify(buyerIntent, buyerSig);\r\n        if (sellerIntent.tokenOut != buyerIntent.tokenIn) revert TokenMismatch();\r\n        if (sellerIntent.tokenIn != buyerIntent.tokenOut) revert TokenMismatch();\r\n        if (tradedTokens > (sellerIntent.amountOut - filledAmount[sellerIntent.hash()])) revert OverFilled();\r\n        if (tradedTokens > (buyerIntent.amountIn - filledAmount[buyerIntent.hash()])) revert OverFilled();\r\n\r\n        filledAmount[sellerIntent.hash()] += uint160(tradedTokens);\r\n        filledAmount[buyerIntent.hash()] += uint160(tradedTokens);\r\n\r\n        uint256 totalExecutionPrice = getTotalExecutionPrice(buyerIntent, sellerIntent, tradedTokens);\r\n\r\n        // Move tokens to reactor in order to implicitly allowlist the buyer in case TradeReactor is powerlisted\r\n        IERC20(sellerIntent.tokenOut).safeTransferFrom(sellerIntent.owner, address(this), tradedTokens);\r\n        IERC20(buyerIntent.tokenOut).safeTransferFrom(buyerIntent.owner, address(this), totalExecutionPrice);\r\n\r\n        // Distribute proceeds\r\n        IERC20(sellerIntent.tokenOut).safeTransfer(buyerIntent.owner, tradedTokens); // transfer sold tokens to buyer\r\n        IERC20(sellerIntent.tokenIn).safeTransfer(sellerIntent.owner, totalExecutionPrice - totalFee); // transfer net proceeds to seller\r\n        IERC20(sellerIntent.tokenIn).safeTransfer(msg.sender, totalFee); // collect fee to msg.sender\r\n\r\n        //leave it to the filler to emit an event with the fees correctly specified\r\n        //emit Trade(sellerIntent.owner, buyerIntent.owner, sellerIntent.tokenOut, amount, sellerIntent.tokenIn, ask, bid - ask);\r\n    }\r\n\r\n    function verify(Intent calldata intent, bytes calldata signature) public view {\r\n        verifyIntentSignature(intent, signature);\r\n        if (block.timestamp > intent.expiration) revert IntentExpired(intent.expiration);\r\n        if (intent.filler != msg.sender && intent.filler != address(0x0)) revert InvalidFiller();\r\n    }\r\n\r\n    function cleanupExpiredIntentData(Intent[] calldata intents) external {\r\n        for (uint i = 0; i < intents.length; i++) {\r\n            Intent calldata intent = intents[i];\r\n            if (block.timestamp > intent.expiration) {\r\n                delete filledAmount[intent.hash()];\r\n            }\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n// and modified it.\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nlibrary Address {\r\n\r\n    /// @param target Target address to call the function on.\r\n    error Address_NotTransferNorContract(address target);\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n        return account.code.length > 0;\r\n    }\r\n    \r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\r\n        if (data.length != 0 && !isContract(target)) {\r\n            revert Address_NotTransferNorContract(target);\r\n        }\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else if (returndata.length > 0) {\r\n            assembly{\r\n                revert (add (returndata, 0x20), mload (returndata))\r\n            }\r\n        } else {\r\n           revert(\"failed\");\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {IERC20} from \"../ERC20/IERC20.sol\";\r\nimport {IERC20Permit} from \"../ERC20/IERC20Permit.sol\";\r\nimport {Address} from \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        if (nonceAfter != nonceBefore + 1) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}"
      }
    }
  }
}