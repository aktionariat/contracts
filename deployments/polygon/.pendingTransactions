{
  "0x2dd2430d93e7969bde35244484d7d7695b6157690c9a10c112b733417e11dac1": {
    "name": "BrokerbotRegistry",
    "deployment": {
      "_format": "hh-sol-artifact-1",
      "contractName": "BrokerbotRegistry",
      "sourceName": "src/brokerbot/BrokerbotRegistry.sol",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            }
          ],
          "name": "Ownable_NotOwner",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousOwner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "OwnershipTransferred",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "contract IBrokerbot",
              "name": "brokerbot",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "contract IERC20",
              "name": "base",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "contract IERC20",
              "name": "token",
              "type": "address"
            }
          ],
          "name": "RegisterBrokerbot",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "contract IBrokerbot",
              "name": "brokerbot",
              "type": "address"
            }
          ],
          "name": "SyncBrokerbot",
          "type": "event"
        },
        {
          "inputs": [
            {
              "internalType": "contract IERC20",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "contract IERC20",
              "name": "",
              "type": "address"
            }
          ],
          "name": "getBrokerbot",
          "outputs": [
            {
              "internalType": "contract IBrokerbot",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract IBrokerbot",
              "name": "_brokerbot",
              "type": "address"
            },
            {
              "internalType": "contract IERC20",
              "name": "_base",
              "type": "address"
            },
            {
              "internalType": "contract IERC20",
              "name": "_token",
              "type": "address"
            }
          ],
          "name": "registerBrokerbot",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract IBrokerbot",
              "name": "_brokerbot",
              "type": "address"
            }
          ],
          "name": "syncBrokerbot",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "transferOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "bytecode": "0x608060405234801561001057600080fd5b506040516103f53803806103f583398101604081905261002f9161007e565b600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350506100ae565b60006020828403121561009057600080fd5b81516001600160a01b03811681146100a757600080fd5b9392505050565b610338806100bd6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806309f793711461005c57806376abbf0a146100715780638da5cb5b146100c15780639abad75e146100d4578063f2fde38b146100e7575b600080fd5b61006f61006a36600461025a565b6100fa565b005b6100a561007f3660046102a5565b60016020908152600092835260408084209091529082529020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6000546100a5906001600160a01b031681565b61006f6100e23660046102de565b610175565b61006f6100f53660046102de565b6101ac565b61010261020f565b6001600160a01b0382811660008181526001602090815260408083208686168085529083529281902080546001600160a01b03191695891695861790555193845290927f3cc22fa2b08c920913fb7245fcc72114373ad796b1be5d44ee1ff6ad60b3a65a910160405180910390a3505050565b6040516001600160a01b038216907f8709efa7ee1ccd26c55d0d4770969d05389572dec0bc4e3b34acfdf89f1b64f990600090a250565b6101b461020f565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b03163314610240576040516396a19be960e01b815233600482015260240160405180910390fd5b565b6001600160a01b038116811461025757600080fd5b50565b60008060006060848603121561026f57600080fd5b833561027a81610242565b9250602084013561028a81610242565b9150604084013561029a81610242565b809150509250925092565b600080604083850312156102b857600080fd5b82356102c381610242565b915060208301356102d381610242565b809150509250929050565b6000602082840312156102f057600080fd5b81356102fb81610242565b939250505056fea26469706673582212205b7e29f3d56ce9e9696aa8901cae24cdf99842d4135753964ace66f4ebdbdef564736f6c63430008150033",
      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806309f793711461005c57806376abbf0a146100715780638da5cb5b146100c15780639abad75e146100d4578063f2fde38b146100e7575b600080fd5b61006f61006a36600461025a565b6100fa565b005b6100a561007f3660046102a5565b60016020908152600092835260408084209091529082529020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6000546100a5906001600160a01b031681565b61006f6100e23660046102de565b610175565b61006f6100f53660046102de565b6101ac565b61010261020f565b6001600160a01b0382811660008181526001602090815260408083208686168085529083529281902080546001600160a01b03191695891695861790555193845290927f3cc22fa2b08c920913fb7245fcc72114373ad796b1be5d44ee1ff6ad60b3a65a910160405180910390a3505050565b6040516001600160a01b038216907f8709efa7ee1ccd26c55d0d4770969d05389572dec0bc4e3b34acfdf89f1b64f990600090a250565b6101b461020f565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b03163314610240576040516396a19be960e01b815233600482015260240160405180910390fd5b565b6001600160a01b038116811461025757600080fd5b50565b60008060006060848603121561026f57600080fd5b833561027a81610242565b9250602084013561028a81610242565b9150604084013561029a81610242565b809150509250925092565b600080604083850312156102b857600080fd5b82356102c381610242565b915060208301356102d381610242565b809150509250929050565b6000602082840312156102f057600080fd5b81356102fb81610242565b939250505056fea26469706673582212205b7e29f3d56ce9e9696aa8901cae24cdf99842d4135753964ace66f4ebdbdef564736f6c63430008150033",
      "linkReferences": {},
      "deployedLinkReferences": {},
      "devdoc": {
        "events": {
          "RegisterBrokerbot(address,address,address)": {
            "params": {
              "base": "The address of the base currency",
              "brokerbot": "The address of the brokerbot",
              "token": "The address of the share token"
            }
          },
          "SyncBrokerbot(address)": {
            "params": {
              "brokerbot": "The brokerbot address that is synced"
            }
          }
        },
        "kind": "dev",
        "methods": {
          "registerBrokerbot(address,address,address)": {
            "params": {
              "_base": "The contract of the base currency of the brokerbot.",
              "_brokerbot": "The brokerbot contract that should be registered.",
              "_token": "The contract of the share token of the brokerbot."
            }
          },
          "syncBrokerbot(address)": {
            "params": {
              "_brokerbot": "The brokerbot that should be synced"
            }
          },
          "transferOwnership(address)": {
            "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
          }
        },
        "stateVariables": {
          "getBrokerbot": {
            "details": "mapping is [base][token] = brokerbotAddress",
            "return": "brokerbot The brokerbot address",
            "returns": {
              "_0": "brokerbot The brokerbot address"
            }
          }
        },
        "title": "Brokerbot Registry",
        "version": 1
      },
      "evm": {
        "bytecode": {
          "functionDebugData": {
            "@_11445": {
              "entryPoint": null,
              "id": 11445,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@_2839": {
              "entryPoint": null,
              "id": 2839,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "abi_decode_tuple_t_address_fromMemory": {
              "entryPoint": 126,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nativeSrc": "0:306:52",
                "nodeType": "YulBlock",
                "src": "0:306:52",
                "statements": [
                  {
                    "nativeSrc": "6:3:52",
                    "nodeType": "YulBlock",
                    "src": "6:3:52",
                    "statements": []
                  },
                  {
                    "body": {
                      "nativeSrc": "95:209:52",
                      "nodeType": "YulBlock",
                      "src": "95:209:52",
                      "statements": [
                        {
                          "body": {
                            "nativeSrc": "141:16:52",
                            "nodeType": "YulBlock",
                            "src": "141:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "150:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "150:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "153:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "153:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "143:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "143:6:52"
                                  },
                                  "nativeSrc": "143:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "143:12:52"
                                },
                                "nativeSrc": "143:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "143:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nativeSrc": "116:7:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "116:7:52"
                                  },
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "125:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "125:9:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nativeSrc": "112:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "112:3:52"
                                },
                                "nativeSrc": "112:23:52",
                                "nodeType": "YulFunctionCall",
                                "src": "112:23:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "137:2:52",
                                "nodeType": "YulLiteral",
                                "src": "137:2:52",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nativeSrc": "108:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "108:3:52"
                            },
                            "nativeSrc": "108:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "108:32:52"
                          },
                          "nativeSrc": "105:52:52",
                          "nodeType": "YulIf",
                          "src": "105:52:52"
                        },
                        {
                          "nativeSrc": "166:29:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "166:29:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "185:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "185:9:52"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nativeSrc": "179:5:52",
                              "nodeType": "YulIdentifier",
                              "src": "179:5:52"
                            },
                            "nativeSrc": "179:16:52",
                            "nodeType": "YulFunctionCall",
                            "src": "179:16:52"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nativeSrc": "170:5:52",
                              "nodeType": "YulTypedName",
                              "src": "170:5:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nativeSrc": "258:16:52",
                            "nodeType": "YulBlock",
                            "src": "258:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "267:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "267:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "270:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "270:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "260:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "260:6:52"
                                  },
                                  "nativeSrc": "260:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "260:12:52"
                                },
                                "nativeSrc": "260:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "260:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nativeSrc": "217:5:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "217:5:52"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nativeSrc": "228:5:52",
                                        "nodeType": "YulIdentifier",
                                        "src": "228:5:52"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "kind": "number",
                                                "nativeSrc": "243:3:52",
                                                "nodeType": "YulLiteral",
                                                "src": "243:3:52",
                                                "type": "",
                                                "value": "160"
                                              },
                                              {
                                                "kind": "number",
                                                "nativeSrc": "248:1:52",
                                                "nodeType": "YulLiteral",
                                                "src": "248:1:52",
                                                "type": "",
                                                "value": "1"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "shl",
                                              "nativeSrc": "239:3:52",
                                              "nodeType": "YulIdentifier",
                                              "src": "239:3:52"
                                            },
                                            "nativeSrc": "239:11:52",
                                            "nodeType": "YulFunctionCall",
                                            "src": "239:11:52"
                                          },
                                          {
                                            "kind": "number",
                                            "nativeSrc": "252:1:52",
                                            "nodeType": "YulLiteral",
                                            "src": "252:1:52",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "sub",
                                          "nativeSrc": "235:3:52",
                                          "nodeType": "YulIdentifier",
                                          "src": "235:3:52"
                                        },
                                        "nativeSrc": "235:19:52",
                                        "nodeType": "YulFunctionCall",
                                        "src": "235:19:52"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nativeSrc": "224:3:52",
                                      "nodeType": "YulIdentifier",
                                      "src": "224:3:52"
                                    },
                                    "nativeSrc": "224:31:52",
                                    "nodeType": "YulFunctionCall",
                                    "src": "224:31:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nativeSrc": "214:2:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "214:2:52"
                                },
                                "nativeSrc": "214:42:52",
                                "nodeType": "YulFunctionCall",
                                "src": "214:42:52"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nativeSrc": "207:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "207:6:52"
                            },
                            "nativeSrc": "207:50:52",
                            "nodeType": "YulFunctionCall",
                            "src": "207:50:52"
                          },
                          "nativeSrc": "204:70:52",
                          "nodeType": "YulIf",
                          "src": "204:70:52"
                        },
                        {
                          "nativeSrc": "283:15:52",
                          "nodeType": "YulAssignment",
                          "src": "283:15:52",
                          "value": {
                            "name": "value",
                            "nativeSrc": "293:5:52",
                            "nodeType": "YulIdentifier",
                            "src": "293:5:52"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nativeSrc": "283:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "283:6:52"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address_fromMemory",
                    "nativeSrc": "14:290:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "61:9:52",
                        "nodeType": "YulTypedName",
                        "src": "61:9:52",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nativeSrc": "72:7:52",
                        "nodeType": "YulTypedName",
                        "src": "72:7:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nativeSrc": "84:6:52",
                        "nodeType": "YulTypedName",
                        "src": "84:6:52",
                        "type": ""
                      }
                    ],
                    "src": "14:290:52"
                  }
                ]
              },
              "contents": "{\n    { }\n    function abi_decode_tuple_t_address_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := mload(headStart)\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n        value0 := value\n    }\n}",
              "id": 52,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b506040516103f53803806103f583398101604081905261002f9161007e565b600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350506100ae565b60006020828403121561009057600080fd5b81516001600160a01b03811681146100a757600080fd5b9392505050565b610338806100bd6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806309f793711461005c57806376abbf0a146100715780638da5cb5b146100c15780639abad75e146100d4578063f2fde38b146100e7575b600080fd5b61006f61006a36600461025a565b6100fa565b005b6100a561007f3660046102a5565b60016020908152600092835260408084209091529082529020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6000546100a5906001600160a01b031681565b61006f6100e23660046102de565b610175565b61006f6100f53660046102de565b6101ac565b61010261020f565b6001600160a01b0382811660008181526001602090815260408083208686168085529083529281902080546001600160a01b03191695891695861790555193845290927f3cc22fa2b08c920913fb7245fcc72114373ad796b1be5d44ee1ff6ad60b3a65a910160405180910390a3505050565b6040516001600160a01b038216907f8709efa7ee1ccd26c55d0d4770969d05389572dec0bc4e3b34acfdf89f1b64f990600090a250565b6101b461020f565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b03163314610240576040516396a19be960e01b815233600482015260240160405180910390fd5b565b6001600160a01b038116811461025757600080fd5b50565b60008060006060848603121561026f57600080fd5b833561027a81610242565b9250602084013561028a81610242565b9150604084013561029a81610242565b809150509250925092565b600080604083850312156102b857600080fd5b82356102c381610242565b915060208301356102d381610242565b809150509250929050565b6000602082840312156102f057600080fd5b81356102fb81610242565b939250505056fea26469706673582212205b7e29f3d56ce9e9696aa8901cae24cdf99842d4135753964ace66f4ebdbdef564736f6c63430008150033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH2 0x3F5 CODESIZE SUB DUP1 PUSH2 0x3F5 DUP4 CODECOPY DUP2 ADD PUSH1 0x40 DUP2 SWAP1 MSTORE PUSH2 0x2F SWAP2 PUSH2 0x7E JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR DUP3 SSTORE PUSH1 0x40 MLOAD DUP4 SWAP3 SWAP1 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP1 DUP3 SWAP1 LOG3 POP POP PUSH2 0xAE JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x90 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0xA7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH2 0x338 DUP1 PUSH2 0xBD PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x57 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x9F79371 EQ PUSH2 0x5C JUMPI DUP1 PUSH4 0x76ABBF0A EQ PUSH2 0x71 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0xC1 JUMPI DUP1 PUSH4 0x9ABAD75E EQ PUSH2 0xD4 JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0xE7 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x6F PUSH2 0x6A CALLDATASIZE PUSH1 0x4 PUSH2 0x25A JUMP JUMPDEST PUSH2 0xFA JUMP JUMPDEST STOP JUMPDEST PUSH2 0xA5 PUSH2 0x7F CALLDATASIZE PUSH1 0x4 PUSH2 0x2A5 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x20 SWAP1 DUP2 MSTORE PUSH1 0x0 SWAP3 DUP4 MSTORE PUSH1 0x40 DUP1 DUP5 KECCAK256 SWAP1 SWAP2 MSTORE SWAP1 DUP3 MSTORE SWAP1 KECCAK256 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 SLOAD PUSH2 0xA5 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH2 0x6F PUSH2 0xE2 CALLDATASIZE PUSH1 0x4 PUSH2 0x2DE JUMP JUMPDEST PUSH2 0x175 JUMP JUMPDEST PUSH2 0x6F PUSH2 0xF5 CALLDATASIZE PUSH1 0x4 PUSH2 0x2DE JUMP JUMPDEST PUSH2 0x1AC JUMP JUMPDEST PUSH2 0x102 PUSH2 0x20F JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 DUP2 AND PUSH1 0x0 DUP2 DUP2 MSTORE PUSH1 0x1 PUSH1 0x20 SWAP1 DUP2 MSTORE PUSH1 0x40 DUP1 DUP4 KECCAK256 DUP7 DUP7 AND DUP1 DUP6 MSTORE SWAP1 DUP4 MSTORE SWAP3 DUP2 SWAP1 KECCAK256 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND SWAP6 DUP10 AND SWAP6 DUP7 OR SWAP1 SSTORE MLOAD SWAP4 DUP5 MSTORE SWAP1 SWAP3 PUSH32 0x3CC22FA2B08C920913FB7245FCC72114373AD796B1BE5D44EE1FF6AD60B3A65A SWAP2 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 POP POP POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP1 PUSH32 0x8709EFA7EE1CCD26C55D0D4770969D05389572DEC0BC4E3B34ACFDF89F1B64F9 SWAP1 PUSH1 0x0 SWAP1 LOG2 POP JUMP JUMPDEST PUSH2 0x1B4 PUSH2 0x20F JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND SWAP4 SWAP3 AND SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 LOG3 PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x240 JUMPI PUSH1 0x40 MLOAD PUSH4 0x96A19BE9 PUSH1 0xE0 SHL DUP2 MSTORE CALLER PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x257 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x26F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 CALLDATALOAD PUSH2 0x27A DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 ADD CALLDATALOAD PUSH2 0x28A DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP2 POP PUSH1 0x40 DUP5 ADD CALLDATALOAD PUSH2 0x29A DUP2 PUSH2 0x242 JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0x2B8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 CALLDATALOAD PUSH2 0x2C3 DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP2 POP PUSH1 0x20 DUP4 ADD CALLDATALOAD PUSH2 0x2D3 DUP2 PUSH2 0x242 JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x2F0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH2 0x2FB DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 JUMPDEST PUSH31 0x29F3D56CE9E9696AA8901CAE24CDF99842D4135753964ACE66F4EBDBDEF564 PUSH20 0x6F6C634300081500330000000000000000000000 ",
          "sourceMap": "725:1646:13:-:0;;;1529:46;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1101:5:49;:20;;-1:-1:-1;;;;;;1101:20:49;-1:-1:-1;;;;;1101:20:49;;;;;;;1136:39;;1101:20;;:5;1136:39;;1101:5;;1136:39;1056:126;1529:46:13;725:1646;;14:290:52;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:52;;214:42;;204:70;;270:1;267;260:12;204:70;293:5;14:290;-1:-1:-1;;;14:290:52:o;:::-;725:1646:13;;;;;;"
        },
        "deployedBytecode": {
          "functionDebugData": {
            "@_checkOwner_11485": {
              "entryPoint": 527,
              "id": 11485,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@getBrokerbot_2812": {
              "entryPoint": null,
              "id": 2812,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@owner_11416": {
              "entryPoint": null,
              "id": 11416,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@registerBrokerbot_2869": {
              "entryPoint": 250,
              "id": 2869,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "@syncBrokerbot_2881": {
              "entryPoint": 373,
              "id": 2881,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@transferOwnership_11470": {
              "entryPoint": 428,
              "id": 11470,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "abi_decode_tuple_t_address": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_contract$_IBrokerbot_$3681": {
              "entryPoint": 734,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_contract$_IBrokerbot_$3681t_contract$_IERC20_$1376t_contract$_IERC20_$1376": {
              "entryPoint": 602,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 3
            },
            "abi_decode_tuple_t_contract$_IERC20_$1376t_contract$_IERC20_$1376": {
              "entryPoint": 677,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "abi_encode_tuple_t_address__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_contract$_IBrokerbot_$3681__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "validator_revert_contract_IBrokerbot": {
              "entryPoint": 578,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nativeSrc": "0:2207:52",
                "nodeType": "YulBlock",
                "src": "0:2207:52",
                "statements": [
                  {
                    "nativeSrc": "6:3:52",
                    "nodeType": "YulBlock",
                    "src": "6:3:52",
                    "statements": []
                  },
                  {
                    "body": {
                      "nativeSrc": "71:86:52",
                      "nodeType": "YulBlock",
                      "src": "71:86:52",
                      "statements": [
                        {
                          "body": {
                            "nativeSrc": "135:16:52",
                            "nodeType": "YulBlock",
                            "src": "135:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "144:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "144:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "147:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "147:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "137:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "137:6:52"
                                  },
                                  "nativeSrc": "137:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "137:12:52"
                                },
                                "nativeSrc": "137:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "137:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nativeSrc": "94:5:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "94:5:52"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nativeSrc": "105:5:52",
                                        "nodeType": "YulIdentifier",
                                        "src": "105:5:52"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "kind": "number",
                                                "nativeSrc": "120:3:52",
                                                "nodeType": "YulLiteral",
                                                "src": "120:3:52",
                                                "type": "",
                                                "value": "160"
                                              },
                                              {
                                                "kind": "number",
                                                "nativeSrc": "125:1:52",
                                                "nodeType": "YulLiteral",
                                                "src": "125:1:52",
                                                "type": "",
                                                "value": "1"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "shl",
                                              "nativeSrc": "116:3:52",
                                              "nodeType": "YulIdentifier",
                                              "src": "116:3:52"
                                            },
                                            "nativeSrc": "116:11:52",
                                            "nodeType": "YulFunctionCall",
                                            "src": "116:11:52"
                                          },
                                          {
                                            "kind": "number",
                                            "nativeSrc": "129:1:52",
                                            "nodeType": "YulLiteral",
                                            "src": "129:1:52",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "sub",
                                          "nativeSrc": "112:3:52",
                                          "nodeType": "YulIdentifier",
                                          "src": "112:3:52"
                                        },
                                        "nativeSrc": "112:19:52",
                                        "nodeType": "YulFunctionCall",
                                        "src": "112:19:52"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nativeSrc": "101:3:52",
                                      "nodeType": "YulIdentifier",
                                      "src": "101:3:52"
                                    },
                                    "nativeSrc": "101:31:52",
                                    "nodeType": "YulFunctionCall",
                                    "src": "101:31:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nativeSrc": "91:2:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "91:2:52"
                                },
                                "nativeSrc": "91:42:52",
                                "nodeType": "YulFunctionCall",
                                "src": "91:42:52"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nativeSrc": "84:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "84:6:52"
                            },
                            "nativeSrc": "84:50:52",
                            "nodeType": "YulFunctionCall",
                            "src": "84:50:52"
                          },
                          "nativeSrc": "81:70:52",
                          "nodeType": "YulIf",
                          "src": "81:70:52"
                        }
                      ]
                    },
                    "name": "validator_revert_contract_IBrokerbot",
                    "nativeSrc": "14:143:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nativeSrc": "60:5:52",
                        "nodeType": "YulTypedName",
                        "src": "60:5:52",
                        "type": ""
                      }
                    ],
                    "src": "14:143:52"
                  },
                  {
                    "body": {
                      "nativeSrc": "315:461:52",
                      "nodeType": "YulBlock",
                      "src": "315:461:52",
                      "statements": [
                        {
                          "body": {
                            "nativeSrc": "361:16:52",
                            "nodeType": "YulBlock",
                            "src": "361:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "370:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "370:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "373:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "373:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "363:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "363:6:52"
                                  },
                                  "nativeSrc": "363:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "363:12:52"
                                },
                                "nativeSrc": "363:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "363:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nativeSrc": "336:7:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "336:7:52"
                                  },
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "345:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "345:9:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nativeSrc": "332:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "332:3:52"
                                },
                                "nativeSrc": "332:23:52",
                                "nodeType": "YulFunctionCall",
                                "src": "332:23:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "357:2:52",
                                "nodeType": "YulLiteral",
                                "src": "357:2:52",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nativeSrc": "328:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "328:3:52"
                            },
                            "nativeSrc": "328:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "328:32:52"
                          },
                          "nativeSrc": "325:52:52",
                          "nodeType": "YulIf",
                          "src": "325:52:52"
                        },
                        {
                          "nativeSrc": "386:36:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "386:36:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "412:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "412:9:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "399:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "399:12:52"
                            },
                            "nativeSrc": "399:23:52",
                            "nodeType": "YulFunctionCall",
                            "src": "399:23:52"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nativeSrc": "390:5:52",
                              "nodeType": "YulTypedName",
                              "src": "390:5:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nativeSrc": "468:5:52",
                                "nodeType": "YulIdentifier",
                                "src": "468:5:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "431:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "431:36:52"
                            },
                            "nativeSrc": "431:43:52",
                            "nodeType": "YulFunctionCall",
                            "src": "431:43:52"
                          },
                          "nativeSrc": "431:43:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "431:43:52"
                        },
                        {
                          "nativeSrc": "483:15:52",
                          "nodeType": "YulAssignment",
                          "src": "483:15:52",
                          "value": {
                            "name": "value",
                            "nativeSrc": "493:5:52",
                            "nodeType": "YulIdentifier",
                            "src": "493:5:52"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nativeSrc": "483:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "483:6:52"
                            }
                          ]
                        },
                        {
                          "nativeSrc": "507:47:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "507:47:52",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "539:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "539:9:52"
                                  },
                                  {
                                    "kind": "number",
                                    "nativeSrc": "550:2:52",
                                    "nodeType": "YulLiteral",
                                    "src": "550:2:52",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nativeSrc": "535:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "535:3:52"
                                },
                                "nativeSrc": "535:18:52",
                                "nodeType": "YulFunctionCall",
                                "src": "535:18:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "522:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "522:12:52"
                            },
                            "nativeSrc": "522:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "522:32:52"
                          },
                          "variables": [
                            {
                              "name": "value_1",
                              "nativeSrc": "511:7:52",
                              "nodeType": "YulTypedName",
                              "src": "511:7:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value_1",
                                "nativeSrc": "600:7:52",
                                "nodeType": "YulIdentifier",
                                "src": "600:7:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "563:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "563:36:52"
                            },
                            "nativeSrc": "563:45:52",
                            "nodeType": "YulFunctionCall",
                            "src": "563:45:52"
                          },
                          "nativeSrc": "563:45:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "563:45:52"
                        },
                        {
                          "nativeSrc": "617:17:52",
                          "nodeType": "YulAssignment",
                          "src": "617:17:52",
                          "value": {
                            "name": "value_1",
                            "nativeSrc": "627:7:52",
                            "nodeType": "YulIdentifier",
                            "src": "627:7:52"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nativeSrc": "617:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "617:6:52"
                            }
                          ]
                        },
                        {
                          "nativeSrc": "643:47:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "643:47:52",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "675:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "675:9:52"
                                  },
                                  {
                                    "kind": "number",
                                    "nativeSrc": "686:2:52",
                                    "nodeType": "YulLiteral",
                                    "src": "686:2:52",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nativeSrc": "671:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "671:3:52"
                                },
                                "nativeSrc": "671:18:52",
                                "nodeType": "YulFunctionCall",
                                "src": "671:18:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "658:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "658:12:52"
                            },
                            "nativeSrc": "658:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "658:32:52"
                          },
                          "variables": [
                            {
                              "name": "value_2",
                              "nativeSrc": "647:7:52",
                              "nodeType": "YulTypedName",
                              "src": "647:7:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value_2",
                                "nativeSrc": "736:7:52",
                                "nodeType": "YulIdentifier",
                                "src": "736:7:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "699:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "699:36:52"
                            },
                            "nativeSrc": "699:45:52",
                            "nodeType": "YulFunctionCall",
                            "src": "699:45:52"
                          },
                          "nativeSrc": "699:45:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "699:45:52"
                        },
                        {
                          "nativeSrc": "753:17:52",
                          "nodeType": "YulAssignment",
                          "src": "753:17:52",
                          "value": {
                            "name": "value_2",
                            "nativeSrc": "763:7:52",
                            "nodeType": "YulIdentifier",
                            "src": "763:7:52"
                          },
                          "variableNames": [
                            {
                              "name": "value2",
                              "nativeSrc": "753:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "753:6:52"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_IBrokerbot_$3681t_contract$_IERC20_$1376t_contract$_IERC20_$1376",
                    "nativeSrc": "162:614:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "265:9:52",
                        "nodeType": "YulTypedName",
                        "src": "265:9:52",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nativeSrc": "276:7:52",
                        "nodeType": "YulTypedName",
                        "src": "276:7:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nativeSrc": "288:6:52",
                        "nodeType": "YulTypedName",
                        "src": "288:6:52",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nativeSrc": "296:6:52",
                        "nodeType": "YulTypedName",
                        "src": "296:6:52",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nativeSrc": "304:6:52",
                        "nodeType": "YulTypedName",
                        "src": "304:6:52",
                        "type": ""
                      }
                    ],
                    "src": "162:614:52"
                  },
                  {
                    "body": {
                      "nativeSrc": "898:325:52",
                      "nodeType": "YulBlock",
                      "src": "898:325:52",
                      "statements": [
                        {
                          "body": {
                            "nativeSrc": "944:16:52",
                            "nodeType": "YulBlock",
                            "src": "944:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "953:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "953:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "956:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "956:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "946:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "946:6:52"
                                  },
                                  "nativeSrc": "946:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "946:12:52"
                                },
                                "nativeSrc": "946:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "946:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nativeSrc": "919:7:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "919:7:52"
                                  },
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "928:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "928:9:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nativeSrc": "915:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "915:3:52"
                                },
                                "nativeSrc": "915:23:52",
                                "nodeType": "YulFunctionCall",
                                "src": "915:23:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "940:2:52",
                                "nodeType": "YulLiteral",
                                "src": "940:2:52",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nativeSrc": "911:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "911:3:52"
                            },
                            "nativeSrc": "911:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "911:32:52"
                          },
                          "nativeSrc": "908:52:52",
                          "nodeType": "YulIf",
                          "src": "908:52:52"
                        },
                        {
                          "nativeSrc": "969:36:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "969:36:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "995:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "995:9:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "982:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "982:12:52"
                            },
                            "nativeSrc": "982:23:52",
                            "nodeType": "YulFunctionCall",
                            "src": "982:23:52"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nativeSrc": "973:5:52",
                              "nodeType": "YulTypedName",
                              "src": "973:5:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nativeSrc": "1051:5:52",
                                "nodeType": "YulIdentifier",
                                "src": "1051:5:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "1014:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "1014:36:52"
                            },
                            "nativeSrc": "1014:43:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1014:43:52"
                          },
                          "nativeSrc": "1014:43:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "1014:43:52"
                        },
                        {
                          "nativeSrc": "1066:15:52",
                          "nodeType": "YulAssignment",
                          "src": "1066:15:52",
                          "value": {
                            "name": "value",
                            "nativeSrc": "1076:5:52",
                            "nodeType": "YulIdentifier",
                            "src": "1076:5:52"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nativeSrc": "1066:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "1066:6:52"
                            }
                          ]
                        },
                        {
                          "nativeSrc": "1090:47:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "1090:47:52",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "1122:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "1122:9:52"
                                  },
                                  {
                                    "kind": "number",
                                    "nativeSrc": "1133:2:52",
                                    "nodeType": "YulLiteral",
                                    "src": "1133:2:52",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nativeSrc": "1118:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "1118:3:52"
                                },
                                "nativeSrc": "1118:18:52",
                                "nodeType": "YulFunctionCall",
                                "src": "1118:18:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "1105:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "1105:12:52"
                            },
                            "nativeSrc": "1105:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1105:32:52"
                          },
                          "variables": [
                            {
                              "name": "value_1",
                              "nativeSrc": "1094:7:52",
                              "nodeType": "YulTypedName",
                              "src": "1094:7:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value_1",
                                "nativeSrc": "1183:7:52",
                                "nodeType": "YulIdentifier",
                                "src": "1183:7:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "1146:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "1146:36:52"
                            },
                            "nativeSrc": "1146:45:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1146:45:52"
                          },
                          "nativeSrc": "1146:45:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "1146:45:52"
                        },
                        {
                          "nativeSrc": "1200:17:52",
                          "nodeType": "YulAssignment",
                          "src": "1200:17:52",
                          "value": {
                            "name": "value_1",
                            "nativeSrc": "1210:7:52",
                            "nodeType": "YulIdentifier",
                            "src": "1210:7:52"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nativeSrc": "1200:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "1200:6:52"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_IERC20_$1376t_contract$_IERC20_$1376",
                    "nativeSrc": "781:442:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "856:9:52",
                        "nodeType": "YulTypedName",
                        "src": "856:9:52",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nativeSrc": "867:7:52",
                        "nodeType": "YulTypedName",
                        "src": "867:7:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nativeSrc": "879:6:52",
                        "nodeType": "YulTypedName",
                        "src": "879:6:52",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nativeSrc": "887:6:52",
                        "nodeType": "YulTypedName",
                        "src": "887:6:52",
                        "type": ""
                      }
                    ],
                    "src": "781:442:52"
                  },
                  {
                    "body": {
                      "nativeSrc": "1348:102:52",
                      "nodeType": "YulBlock",
                      "src": "1348:102:52",
                      "statements": [
                        {
                          "nativeSrc": "1358:26:52",
                          "nodeType": "YulAssignment",
                          "src": "1358:26:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "1370:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "1370:9:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "1381:2:52",
                                "nodeType": "YulLiteral",
                                "src": "1381:2:52",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nativeSrc": "1366:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "1366:3:52"
                            },
                            "nativeSrc": "1366:18:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1366:18:52"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nativeSrc": "1358:4:52",
                              "nodeType": "YulIdentifier",
                              "src": "1358:4:52"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "1400:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "1400:9:52"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nativeSrc": "1415:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "1415:6:52"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nativeSrc": "1431:3:52",
                                            "nodeType": "YulLiteral",
                                            "src": "1431:3:52",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nativeSrc": "1436:1:52",
                                            "nodeType": "YulLiteral",
                                            "src": "1436:1:52",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nativeSrc": "1427:3:52",
                                          "nodeType": "YulIdentifier",
                                          "src": "1427:3:52"
                                        },
                                        "nativeSrc": "1427:11:52",
                                        "nodeType": "YulFunctionCall",
                                        "src": "1427:11:52"
                                      },
                                      {
                                        "kind": "number",
                                        "nativeSrc": "1440:1:52",
                                        "nodeType": "YulLiteral",
                                        "src": "1440:1:52",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nativeSrc": "1423:3:52",
                                      "nodeType": "YulIdentifier",
                                      "src": "1423:3:52"
                                    },
                                    "nativeSrc": "1423:19:52",
                                    "nodeType": "YulFunctionCall",
                                    "src": "1423:19:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nativeSrc": "1411:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "1411:3:52"
                                },
                                "nativeSrc": "1411:32:52",
                                "nodeType": "YulFunctionCall",
                                "src": "1411:32:52"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nativeSrc": "1393:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "1393:6:52"
                            },
                            "nativeSrc": "1393:51:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1393:51:52"
                          },
                          "nativeSrc": "1393:51:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "1393:51:52"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_contract$_IBrokerbot_$3681__to_t_address__fromStack_reversed",
                    "nativeSrc": "1228:222:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "1317:9:52",
                        "nodeType": "YulTypedName",
                        "src": "1317:9:52",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nativeSrc": "1328:6:52",
                        "nodeType": "YulTypedName",
                        "src": "1328:6:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nativeSrc": "1339:4:52",
                        "nodeType": "YulTypedName",
                        "src": "1339:4:52",
                        "type": ""
                      }
                    ],
                    "src": "1228:222:52"
                  },
                  {
                    "body": {
                      "nativeSrc": "1556:102:52",
                      "nodeType": "YulBlock",
                      "src": "1556:102:52",
                      "statements": [
                        {
                          "nativeSrc": "1566:26:52",
                          "nodeType": "YulAssignment",
                          "src": "1566:26:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "1578:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "1578:9:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "1589:2:52",
                                "nodeType": "YulLiteral",
                                "src": "1589:2:52",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nativeSrc": "1574:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "1574:3:52"
                            },
                            "nativeSrc": "1574:18:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1574:18:52"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nativeSrc": "1566:4:52",
                              "nodeType": "YulIdentifier",
                              "src": "1566:4:52"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "1608:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "1608:9:52"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nativeSrc": "1623:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "1623:6:52"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nativeSrc": "1639:3:52",
                                            "nodeType": "YulLiteral",
                                            "src": "1639:3:52",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nativeSrc": "1644:1:52",
                                            "nodeType": "YulLiteral",
                                            "src": "1644:1:52",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nativeSrc": "1635:3:52",
                                          "nodeType": "YulIdentifier",
                                          "src": "1635:3:52"
                                        },
                                        "nativeSrc": "1635:11:52",
                                        "nodeType": "YulFunctionCall",
                                        "src": "1635:11:52"
                                      },
                                      {
                                        "kind": "number",
                                        "nativeSrc": "1648:1:52",
                                        "nodeType": "YulLiteral",
                                        "src": "1648:1:52",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nativeSrc": "1631:3:52",
                                      "nodeType": "YulIdentifier",
                                      "src": "1631:3:52"
                                    },
                                    "nativeSrc": "1631:19:52",
                                    "nodeType": "YulFunctionCall",
                                    "src": "1631:19:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nativeSrc": "1619:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "1619:3:52"
                                },
                                "nativeSrc": "1619:32:52",
                                "nodeType": "YulFunctionCall",
                                "src": "1619:32:52"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nativeSrc": "1601:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "1601:6:52"
                            },
                            "nativeSrc": "1601:51:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1601:51:52"
                          },
                          "nativeSrc": "1601:51:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "1601:51:52"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address__to_t_address__fromStack_reversed",
                    "nativeSrc": "1455:203:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "1525:9:52",
                        "nodeType": "YulTypedName",
                        "src": "1525:9:52",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nativeSrc": "1536:6:52",
                        "nodeType": "YulTypedName",
                        "src": "1536:6:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nativeSrc": "1547:4:52",
                        "nodeType": "YulTypedName",
                        "src": "1547:4:52",
                        "type": ""
                      }
                    ],
                    "src": "1455:203:52"
                  },
                  {
                    "body": {
                      "nativeSrc": "1752:189:52",
                      "nodeType": "YulBlock",
                      "src": "1752:189:52",
                      "statements": [
                        {
                          "body": {
                            "nativeSrc": "1798:16:52",
                            "nodeType": "YulBlock",
                            "src": "1798:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "1807:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "1807:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "1810:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "1810:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "1800:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "1800:6:52"
                                  },
                                  "nativeSrc": "1800:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "1800:12:52"
                                },
                                "nativeSrc": "1800:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "1800:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nativeSrc": "1773:7:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "1773:7:52"
                                  },
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "1782:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "1782:9:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nativeSrc": "1769:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "1769:3:52"
                                },
                                "nativeSrc": "1769:23:52",
                                "nodeType": "YulFunctionCall",
                                "src": "1769:23:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "1794:2:52",
                                "nodeType": "YulLiteral",
                                "src": "1794:2:52",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nativeSrc": "1765:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "1765:3:52"
                            },
                            "nativeSrc": "1765:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1765:32:52"
                          },
                          "nativeSrc": "1762:52:52",
                          "nodeType": "YulIf",
                          "src": "1762:52:52"
                        },
                        {
                          "nativeSrc": "1823:36:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "1823:36:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "1849:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "1849:9:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "1836:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "1836:12:52"
                            },
                            "nativeSrc": "1836:23:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1836:23:52"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nativeSrc": "1827:5:52",
                              "nodeType": "YulTypedName",
                              "src": "1827:5:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nativeSrc": "1905:5:52",
                                "nodeType": "YulIdentifier",
                                "src": "1905:5:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "1868:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "1868:36:52"
                            },
                            "nativeSrc": "1868:43:52",
                            "nodeType": "YulFunctionCall",
                            "src": "1868:43:52"
                          },
                          "nativeSrc": "1868:43:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "1868:43:52"
                        },
                        {
                          "nativeSrc": "1920:15:52",
                          "nodeType": "YulAssignment",
                          "src": "1920:15:52",
                          "value": {
                            "name": "value",
                            "nativeSrc": "1930:5:52",
                            "nodeType": "YulIdentifier",
                            "src": "1930:5:52"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nativeSrc": "1920:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "1920:6:52"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_IBrokerbot_$3681",
                    "nativeSrc": "1663:278:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "1718:9:52",
                        "nodeType": "YulTypedName",
                        "src": "1718:9:52",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nativeSrc": "1729:7:52",
                        "nodeType": "YulTypedName",
                        "src": "1729:7:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nativeSrc": "1741:6:52",
                        "nodeType": "YulTypedName",
                        "src": "1741:6:52",
                        "type": ""
                      }
                    ],
                    "src": "1663:278:52"
                  },
                  {
                    "body": {
                      "nativeSrc": "2016:189:52",
                      "nodeType": "YulBlock",
                      "src": "2016:189:52",
                      "statements": [
                        {
                          "body": {
                            "nativeSrc": "2062:16:52",
                            "nodeType": "YulBlock",
                            "src": "2062:16:52",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nativeSrc": "2071:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "2071:1:52",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nativeSrc": "2074:1:52",
                                      "nodeType": "YulLiteral",
                                      "src": "2074:1:52",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nativeSrc": "2064:6:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "2064:6:52"
                                  },
                                  "nativeSrc": "2064:12:52",
                                  "nodeType": "YulFunctionCall",
                                  "src": "2064:12:52"
                                },
                                "nativeSrc": "2064:12:52",
                                "nodeType": "YulExpressionStatement",
                                "src": "2064:12:52"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nativeSrc": "2037:7:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "2037:7:52"
                                  },
                                  {
                                    "name": "headStart",
                                    "nativeSrc": "2046:9:52",
                                    "nodeType": "YulIdentifier",
                                    "src": "2046:9:52"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nativeSrc": "2033:3:52",
                                  "nodeType": "YulIdentifier",
                                  "src": "2033:3:52"
                                },
                                "nativeSrc": "2033:23:52",
                                "nodeType": "YulFunctionCall",
                                "src": "2033:23:52"
                              },
                              {
                                "kind": "number",
                                "nativeSrc": "2058:2:52",
                                "nodeType": "YulLiteral",
                                "src": "2058:2:52",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nativeSrc": "2029:3:52",
                              "nodeType": "YulIdentifier",
                              "src": "2029:3:52"
                            },
                            "nativeSrc": "2029:32:52",
                            "nodeType": "YulFunctionCall",
                            "src": "2029:32:52"
                          },
                          "nativeSrc": "2026:52:52",
                          "nodeType": "YulIf",
                          "src": "2026:52:52"
                        },
                        {
                          "nativeSrc": "2087:36:52",
                          "nodeType": "YulVariableDeclaration",
                          "src": "2087:36:52",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nativeSrc": "2113:9:52",
                                "nodeType": "YulIdentifier",
                                "src": "2113:9:52"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nativeSrc": "2100:12:52",
                              "nodeType": "YulIdentifier",
                              "src": "2100:12:52"
                            },
                            "nativeSrc": "2100:23:52",
                            "nodeType": "YulFunctionCall",
                            "src": "2100:23:52"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nativeSrc": "2091:5:52",
                              "nodeType": "YulTypedName",
                              "src": "2091:5:52",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nativeSrc": "2169:5:52",
                                "nodeType": "YulIdentifier",
                                "src": "2169:5:52"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_IBrokerbot",
                              "nativeSrc": "2132:36:52",
                              "nodeType": "YulIdentifier",
                              "src": "2132:36:52"
                            },
                            "nativeSrc": "2132:43:52",
                            "nodeType": "YulFunctionCall",
                            "src": "2132:43:52"
                          },
                          "nativeSrc": "2132:43:52",
                          "nodeType": "YulExpressionStatement",
                          "src": "2132:43:52"
                        },
                        {
                          "nativeSrc": "2184:15:52",
                          "nodeType": "YulAssignment",
                          "src": "2184:15:52",
                          "value": {
                            "name": "value",
                            "nativeSrc": "2194:5:52",
                            "nodeType": "YulIdentifier",
                            "src": "2194:5:52"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nativeSrc": "2184:6:52",
                              "nodeType": "YulIdentifier",
                              "src": "2184:6:52"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address",
                    "nativeSrc": "1946:259:52",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nativeSrc": "1982:9:52",
                        "nodeType": "YulTypedName",
                        "src": "1982:9:52",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nativeSrc": "1993:7:52",
                        "nodeType": "YulTypedName",
                        "src": "1993:7:52",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nativeSrc": "2005:6:52",
                        "nodeType": "YulTypedName",
                        "src": "2005:6:52",
                        "type": ""
                      }
                    ],
                    "src": "1946:259:52"
                  }
                ]
              },
              "contents": "{\n    { }\n    function validator_revert_contract_IBrokerbot(value)\n    {\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_contract$_IBrokerbot_$3681t_contract$_IERC20_$1376t_contract$_IERC20_$1376(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 96) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_contract_IBrokerbot(value)\n        value0 := value\n        let value_1 := calldataload(add(headStart, 32))\n        validator_revert_contract_IBrokerbot(value_1)\n        value1 := value_1\n        let value_2 := calldataload(add(headStart, 64))\n        validator_revert_contract_IBrokerbot(value_2)\n        value2 := value_2\n    }\n    function abi_decode_tuple_t_contract$_IERC20_$1376t_contract$_IERC20_$1376(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_contract_IBrokerbot(value)\n        value0 := value\n        let value_1 := calldataload(add(headStart, 32))\n        validator_revert_contract_IBrokerbot(value_1)\n        value1 := value_1\n    }\n    function abi_encode_tuple_t_contract$_IBrokerbot_$3681__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_encode_tuple_t_address__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_decode_tuple_t_contract$_IBrokerbot_$3681(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_contract_IBrokerbot(value)\n        value0 := value\n    }\n    function abi_decode_tuple_t_address(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_contract_IBrokerbot(value)\n        value0 := value\n    }\n}",
              "id": 52,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "immutableReferences": {},
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b50600436106100575760003560e01c806309f793711461005c57806376abbf0a146100715780638da5cb5b146100c15780639abad75e146100d4578063f2fde38b146100e7575b600080fd5b61006f61006a36600461025a565b6100fa565b005b6100a561007f3660046102a5565b60016020908152600092835260408084209091529082529020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6000546100a5906001600160a01b031681565b61006f6100e23660046102de565b610175565b61006f6100f53660046102de565b6101ac565b61010261020f565b6001600160a01b0382811660008181526001602090815260408083208686168085529083529281902080546001600160a01b03191695891695861790555193845290927f3cc22fa2b08c920913fb7245fcc72114373ad796b1be5d44ee1ff6ad60b3a65a910160405180910390a3505050565b6040516001600160a01b038216907f8709efa7ee1ccd26c55d0d4770969d05389572dec0bc4e3b34acfdf89f1b64f990600090a250565b6101b461020f565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b03163314610240576040516396a19be960e01b815233600482015260240160405180910390fd5b565b6001600160a01b038116811461025757600080fd5b50565b60008060006060848603121561026f57600080fd5b833561027a81610242565b9250602084013561028a81610242565b9150604084013561029a81610242565b809150509250925092565b600080604083850312156102b857600080fd5b82356102c381610242565b915060208301356102d381610242565b809150509250929050565b6000602082840312156102f057600080fd5b81356102fb81610242565b939250505056fea26469706673582212205b7e29f3d56ce9e9696aa8901cae24cdf99842d4135753964ace66f4ebdbdef564736f6c63430008150033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x57 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x9F79371 EQ PUSH2 0x5C JUMPI DUP1 PUSH4 0x76ABBF0A EQ PUSH2 0x71 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0xC1 JUMPI DUP1 PUSH4 0x9ABAD75E EQ PUSH2 0xD4 JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0xE7 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x6F PUSH2 0x6A CALLDATASIZE PUSH1 0x4 PUSH2 0x25A JUMP JUMPDEST PUSH2 0xFA JUMP JUMPDEST STOP JUMPDEST PUSH2 0xA5 PUSH2 0x7F CALLDATASIZE PUSH1 0x4 PUSH2 0x2A5 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x20 SWAP1 DUP2 MSTORE PUSH1 0x0 SWAP3 DUP4 MSTORE PUSH1 0x40 DUP1 DUP5 KECCAK256 SWAP1 SWAP2 MSTORE SWAP1 DUP3 MSTORE SWAP1 KECCAK256 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 SLOAD PUSH2 0xA5 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH2 0x6F PUSH2 0xE2 CALLDATASIZE PUSH1 0x4 PUSH2 0x2DE JUMP JUMPDEST PUSH2 0x175 JUMP JUMPDEST PUSH2 0x6F PUSH2 0xF5 CALLDATASIZE PUSH1 0x4 PUSH2 0x2DE JUMP JUMPDEST PUSH2 0x1AC JUMP JUMPDEST PUSH2 0x102 PUSH2 0x20F JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 DUP2 AND PUSH1 0x0 DUP2 DUP2 MSTORE PUSH1 0x1 PUSH1 0x20 SWAP1 DUP2 MSTORE PUSH1 0x40 DUP1 DUP4 KECCAK256 DUP7 DUP7 AND DUP1 DUP6 MSTORE SWAP1 DUP4 MSTORE SWAP3 DUP2 SWAP1 KECCAK256 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND SWAP6 DUP10 AND SWAP6 DUP7 OR SWAP1 SSTORE MLOAD SWAP4 DUP5 MSTORE SWAP1 SWAP3 PUSH32 0x3CC22FA2B08C920913FB7245FCC72114373AD796B1BE5D44EE1FF6AD60B3A65A SWAP2 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 POP POP POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP1 PUSH32 0x8709EFA7EE1CCD26C55D0D4770969D05389572DEC0BC4E3B34ACFDF89F1B64F9 SWAP1 PUSH1 0x0 SWAP1 LOG2 POP JUMP JUMPDEST PUSH2 0x1B4 PUSH2 0x20F JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND SWAP4 SWAP3 AND SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 LOG3 PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x240 JUMPI PUSH1 0x40 MLOAD PUSH4 0x96A19BE9 PUSH1 0xE0 SHL DUP2 MSTORE CALLER PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x257 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x26F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 CALLDATALOAD PUSH2 0x27A DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 ADD CALLDATALOAD PUSH2 0x28A DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP2 POP PUSH1 0x40 DUP5 ADD CALLDATALOAD PUSH2 0x29A DUP2 PUSH2 0x242 JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0x2B8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 CALLDATALOAD PUSH2 0x2C3 DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP2 POP PUSH1 0x20 DUP4 ADD CALLDATALOAD PUSH2 0x2D3 DUP2 PUSH2 0x242 JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x2F0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH2 0x2FB DUP2 PUSH2 0x242 JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 JUMPDEST PUSH31 0x29F3D56CE9E9696AA8901CAE24CDF99842D4135753964ACE66F4EBDBDEF564 PUSH20 0x6F6C634300081500330000000000000000000000 ",
          "sourceMap": "725:1646:13:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1879:207;;;;;;:::i;:::-;;:::i;:::-;;985:68;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;985:68:13;;;;;;-1:-1:-1;;;;;1411:32:52;;;1393:51;;1381:2;1366:18;985:68:13;;;;;;;798:20:49;;;;;-1:-1:-1;;;;;798:20:49;;;2272:96:13;;;;;;:::i;:::-;;:::i;1399:149:49:-;;;;;;:::i;:::-;;:::i;1879:207:13:-;1219:13:49;:11;:13::i;:::-;-1:-1:-1;;;;;1986:19:13;;::::1;;::::0;;;:12:::1;:19;::::0;;;;;;;:27;;::::1;::::0;;;;;;;;;;:40;;-1:-1:-1;;;;;;1986:40:13::1;::::0;;::::1;::::0;;::::1;::::0;;2037:44;1393:51:52;;;1986:27:13;;2037:44:::1;::::0;1366:18:52;2037:44:13::1;;;;;;;1879:207:::0;;;:::o;2272:96::-;2338:25;;-1:-1:-1;;;;;2338:25:13;;;;;;;;2272:96;:::o;1399:149:49:-;1219:13;:11;:13::i;:::-;1499:5:::1;::::0;;1478:37:::1;::::0;-1:-1:-1;;;;;1478:37:49;;::::1;::::0;1499:5;::::1;::::0;1478:37:::1;::::0;::::1;1525:5;:16:::0;;-1:-1:-1;;;;;;1525:16:49::1;-1:-1:-1::0;;;;;1525:16:49;;;::::1;::::0;;;::::1;::::0;;1399:149::o;1554:138::-;1619:5;;-1:-1:-1;;;;;1619:5:49;1605:10;:19;1601:85;;1647:28;;-1:-1:-1;;;1647:28:49;;1664:10;1647:28;;;1393:51:52;1366:18;;1647:28:49;;;;;;;1601:85;1554:138::o;14:143:52:-;-1:-1:-1;;;;;101:31:52;;91:42;;81:70;;147:1;144;137:12;81:70;14:143;:::o;162:614::-;288:6;296;304;357:2;345:9;336:7;332:23;328:32;325:52;;;373:1;370;363:12;325:52;412:9;399:23;431:43;468:5;431:43;:::i;:::-;493:5;-1:-1:-1;550:2:52;535:18;;522:32;563:45;522:32;563:45;:::i;:::-;627:7;-1:-1:-1;686:2:52;671:18;;658:32;699:45;658:32;699:45;:::i;:::-;763:7;753:17;;;162:614;;;;;:::o;781:442::-;879:6;887;940:2;928:9;919:7;915:23;911:32;908:52;;;956:1;953;946:12;908:52;995:9;982:23;1014:43;1051:5;1014:43;:::i;:::-;1076:5;-1:-1:-1;1133:2:52;1118:18;;1105:32;1146:45;1105:32;1146:45;:::i;:::-;1210:7;1200:17;;;781:442;;;;;:::o;1663:278::-;1741:6;1794:2;1782:9;1773:7;1769:23;1765:32;1762:52;;;1810:1;1807;1800:12;1762:52;1849:9;1836:23;1868:43;1905:5;1868:43;:::i;:::-;1930:5;1663:278;-1:-1:-1;;;1663:278:52:o"
        },
        "gasEstimates": {
          "creation": {
            "codeDepositCost": "164800",
            "executionCost": "infinite",
            "totalCost": "infinite"
          },
          "external": {
            "getBrokerbot(address,address)": "infinite",
            "owner()": "2347",
            "registerBrokerbot(address,address,address)": "infinite",
            "syncBrokerbot(address)": "1509",
            "transferOwnership(address)": "30449"
          }
        },
        "methodIdentifiers": {
          "getBrokerbot(address,address)": "76abbf0a",
          "owner()": "8da5cb5b",
          "registerBrokerbot(address,address,address)": "09f79371",
          "syncBrokerbot(address)": "9abad75e",
          "transferOwnership(address)": "f2fde38b"
        }
      },
      "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Ownable_NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IBrokerbot\",\"name\":\"brokerbot\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"RegisterBrokerbot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IBrokerbot\",\"name\":\"brokerbot\",\"type\":\"address\"}],\"name\":\"SyncBrokerbot\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getBrokerbot\",\"outputs\":[{\"internalType\":\"contract IBrokerbot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBrokerbot\",\"name\":\"_brokerbot\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"registerBrokerbot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBrokerbot\",\"name\":\"_brokerbot\",\"type\":\"address\"}],\"name\":\"syncBrokerbot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"RegisterBrokerbot(address,address,address)\":{\"params\":{\"base\":\"The address of the base currency\",\"brokerbot\":\"The address of the brokerbot\",\"token\":\"The address of the share token\"}},\"SyncBrokerbot(address)\":{\"params\":{\"brokerbot\":\"The brokerbot address that is synced\"}}},\"kind\":\"dev\",\"methods\":{\"registerBrokerbot(address,address,address)\":{\"params\":{\"_base\":\"The contract of the base currency of the brokerbot.\",\"_brokerbot\":\"The brokerbot contract that should be registered.\",\"_token\":\"The contract of the share token of the brokerbot.\"}},\"syncBrokerbot(address)\":{\"params\":{\"_brokerbot\":\"The brokerbot that should be synced\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"stateVariables\":{\"getBrokerbot\":{\"details\":\"mapping is [base][token] = brokerbotAddress\",\"return\":\"brokerbot The brokerbot address\",\"returns\":{\"_0\":\"brokerbot The brokerbot address\"}}},\"title\":\"Brokerbot Registry\",\"version\":1},\"userdoc\":{\"events\":{\"RegisterBrokerbot(address,address,address)\":{\"notice\":\"Emitted when brokerbot is registered.\"},\"SyncBrokerbot(address)\":{\"notice\":\"Emmitted when calling syncBrokerbot function\"}},\"kind\":\"user\",\"methods\":{\"getBrokerbot(address,address)\":{\"notice\":\"Returns the brokerbot address for a given pair base and share token, or address 0 if it does not exist\"},\"registerBrokerbot(address,address,address)\":{\"notice\":\"Per network only one active brokerbot should exist per base/share pair\"},\"syncBrokerbot(address)\":{\"notice\":\"This event is usful for indexers/subgraphs to update token balances which are not tracked with other events\"}},\"notice\":\"Holds a registry from all deployed active brokerbots\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/brokerbot/BrokerbotRegistry.sol\":\"BrokerbotRegistry\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/ERC20/IERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\",\"keccak256\":\"0x2224189bcdeb28cbadfdb8d126c278df60ec39875c7929e7ffa9e2055cded960\",\"license\":\"MIT\"},\"src/ERC20/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n\\t//////////////////////////////////////////////////////////////*/\\n    /// Block timestamp must to be before deadline.\\n    /// @param deadline The deadline of the permit.\\n    /// @param blockTimestamp The timestamp of the execution block.\\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\\n    /// Recovered address must be owner and not zero address.\\n    /// @param signerAddress The recovered signer address.\\n    error Permit_InvalidSigner(address signerAddress);\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\",\"keccak256\":\"0x9c6c4c49deffc8176f13b34150dd580526b45dd85ce1b71fe2ed340ff0489ebd\",\"license\":\"MIT\"},\"src/brokerbot/BrokerbotRegistry.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* Proprietary License\\n*\\n* This code cannot be used without an explicit permission from the copyright holder.\\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com), All rights reserved.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/// @title Brokerbot Registry\\n/// @notice Holds a registry from all deployed active brokerbots\\ncontract BrokerbotRegistry is Ownable {\\n  /// @notice Returns the brokerbot address for a given pair base and share token, or address 0 if it does not exist\\n  /// @dev mapping is [base][token] = brokerbotAddress\\n  /// @return brokerbot The brokerbot address\\n  mapping(IERC20 => mapping(IERC20 => IBrokerbot)) public getBrokerbot;\\n\\n  /// @notice Emitted when brokerbot is registered.\\n  /// @param brokerbot The address of the brokerbot\\n  /// @param base The address of the base currency\\n  /// @param token The address of the share token\\n  event RegisterBrokerbot(IBrokerbot brokerbot, IERC20 indexed base, IERC20 indexed token);\\n\\n  /// @notice Emmitted when calling syncBrokerbot function\\n  /// @param brokerbot The brokerbot address that is synced\\n  event SyncBrokerbot(IBrokerbot indexed brokerbot);\\n\\n  constructor(address _owner) Ownable(_owner) {}\\n\\n  /// @notice Per network only one active brokerbot should exist per base/share pair\\n  /// @param _brokerbot The brokerbot contract that should be registered.\\n  /// @param _base The contract of the base currency of the brokerbot.\\n  /// @param _token The contract of the share token of the brokerbot.\\n  function registerBrokerbot(IBrokerbot _brokerbot, IERC20 _base, IERC20 _token ) external onlyOwner() {\\n    getBrokerbot[_base][_token] = _brokerbot;\\n    emit RegisterBrokerbot(_brokerbot, _base, _token);\\n  }\\n\\n  /// @notice This event is usful for indexers/subgraphs to update token balances which are not tracked with other events\\n  /// @param _brokerbot The brokerbot that should be synced\\n  function syncBrokerbot(IBrokerbot _brokerbot) external {\\n    emit SyncBrokerbot(_brokerbot);\\n  }\\n\\n}\",\"keccak256\":\"0xd58d816746540b20822823f97e360df6b1204ce7395556338757eb2e6e965553\",\"license\":\"LicenseRef-Aktionariat\"},\"src/brokerbot/IBrokerbot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\n\\ninterface IBrokerbot {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n  //////////////////////////////////////////////////////////////*/\\n  error Brokerbot_BuyingDisabled();\\n  error Brokerbot_SellingDisabled();\\n  /// Sender(msg.sender) has to be incoming token or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_InvalidSender(address sender);\\n  /// target.call() wasn't successful.\\n  /// @param target The receiver of the Eth.\\n  /// @param amount The withdraw amount.\\n  error Brokerbot_WithdrawFailed(address target, uint256 amount);\\n  /// Sender(msg.sender) needs to be owner or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_NotAuthorized(address sender);\\n\\n  function paymenthub() external view returns (address);\\n\\n  function base() external view returns (IERC20);\\n\\n  function token() external view returns (IERC20Permit);\\n  \\n  function settings() external view returns (uint256);\\n\\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\\n\\n  function getBuyPrice(uint256 shares) external view returns (uint256);\\n\\n  function getSellPrice(uint256 shares) external view returns (uint256);\\n\\n}\",\"keccak256\":\"0xb41ad02c5b587309ecd6c84d4677d457e4cdb9f993447e97a605b10ec24de7b5\",\"license\":\"MIT\"},\"src/utils/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n//\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n//\\n// Modifications:\\n// - Replaced Context._msgSender() with msg.sender\\n// - Made leaner\\n// - Extracted interface\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    error Ownable_NotOwner(address sender);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor (address initialOwner) {\\n        owner = initialOwner;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function _checkOwner() internal view {\\n        if (msg.sender != owner) {\\n            revert Ownable_NotOwner(msg.sender);\\n        }\\n    }\\n}\",\"keccak256\":\"0x9057578671d192c7891a59854cf8bab2698450c5b271f21e0696036fb65cae3b\",\"license\":\"MIT\"}},\"version\":1}",
      "storageLayout": {
        "storage": [
          {
            "astId": 11416,
            "contract": "src/brokerbot/BrokerbotRegistry.sol:BrokerbotRegistry",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2812,
            "contract": "src/brokerbot/BrokerbotRegistry.sol:BrokerbotRegistry",
            "label": "getBrokerbot",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_contract(IERC20)1376,t_mapping(t_contract(IERC20)1376,t_contract(IBrokerbot)3681))"
          }
        ],
        "types": {
          "t_address": {
            "encoding": "inplace",
            "label": "address",
            "numberOfBytes": "20"
          },
          "t_contract(IBrokerbot)3681": {
            "encoding": "inplace",
            "label": "contract IBrokerbot",
            "numberOfBytes": "20"
          },
          "t_contract(IERC20)1376": {
            "encoding": "inplace",
            "label": "contract IERC20",
            "numberOfBytes": "20"
          },
          "t_mapping(t_contract(IERC20)1376,t_contract(IBrokerbot)3681)": {
            "encoding": "mapping",
            "key": "t_contract(IERC20)1376",
            "label": "mapping(contract IERC20 => contract IBrokerbot)",
            "numberOfBytes": "32",
            "value": "t_contract(IBrokerbot)3681"
          },
          "t_mapping(t_contract(IERC20)1376,t_mapping(t_contract(IERC20)1376,t_contract(IBrokerbot)3681))": {
            "encoding": "mapping",
            "key": "t_contract(IERC20)1376",
            "label": "mapping(contract IERC20 => mapping(contract IERC20 => contract IBrokerbot))",
            "numberOfBytes": "32",
            "value": "t_mapping(t_contract(IERC20)1376,t_contract(IBrokerbot)3681)"
          }
        }
      },
      "userdoc": {
        "events": {
          "RegisterBrokerbot(address,address,address)": {
            "notice": "Emitted when brokerbot is registered."
          },
          "SyncBrokerbot(address)": {
            "notice": "Emmitted when calling syncBrokerbot function"
          }
        },
        "kind": "user",
        "methods": {
          "getBrokerbot(address,address)": {
            "notice": "Returns the brokerbot address for a given pair base and share token, or address 0 if it does not exist"
          },
          "registerBrokerbot(address,address,address)": {
            "notice": "Per network only one active brokerbot should exist per base/share pair"
          },
          "syncBrokerbot(address)": {
            "notice": "This event is usful for indexers/subgraphs to update token balances which are not tracked with other events"
          }
        },
        "notice": "Holds a registry from all deployed active brokerbots",
        "version": 1
      },
      "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\n    },\n    \"src/brokerbot/Brokerbot.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* Proprietary License\\n*\\n* This code cannot be used without an explicit permission from the copyright holder.\\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\\n*\\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com), All rights reserved.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\nimport \\\"../ERC20/IERC677Receiver.sol\\\";\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract Brokerbot is IBrokerbot, Ownable {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address public override paymenthub;\\n\\n    IERC20 public override immutable base;  // ERC-20 currency\\n    IERC20Permit public override immutable token; // ERC-20 share token\\n\\n    uint256 private price; // current offer price in base currency, without drift\\n    uint256 public increment; // increment step the price in/decreases when buying/selling\\n\\n    uint256 public driftStart;\\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\\n    int256 public driftIncrement;\\n\\n    // Note that these settings might be hard-coded in various places, so better not change these values.\\n    uint8 private constant BUYING_ENABLED = 0x1;\\n    uint8 private constant SELLING_ENABLED = 0x2;\\n    // note that in the UI, we call the setting \\\"convert ether\\\", which is the opposite\\n    uint8 private constant KEEP_ETHER = 0x4;\\n\\n    // Version history\\n    // Version 2: added ability to process bank orders even if buying disabled\\n    // Version 3: added various events, removed license fee\\n    // Version 4: made version field public so it is actually usable    \\n    // Version 5: added target address for withdrawEther\\n    // Version 6: added costs field to notifyTrade\\n    // Version 7: added withdraw eth event\\n    // Version 8: use SafeERC20\\n    uint8 public constant VERSION = 0x8;\\n\\n    // more bits to be used by payment hub\\n    uint256 public override settings = BUYING_ENABLED | SELLING_ENABLED;\\n\\n    event Trade(IERC20Permit indexed token, address who, bytes ref, int amount, IERC20 base, uint totPrice, uint fee, uint newprice);\\n    event PaymentHubUpdate(address indexed paymentHub);\\n    event PriceSet(uint256 price, uint256 increment);\\n    event DriftSet(uint256 timeToDrift, int256 driftIncrement);\\n    event SettingsChange(uint256 setting);\\n    // ETH in/out events\\n    event Received(address indexed from, uint amountETH, uint amountBase);\\n    event Withdrawn(address indexed target, uint amountETH);\\n    \\n    constructor(\\n        IERC20Permit _token,\\n        uint256 _price,\\n        uint256 _increment,\\n        IERC20 _base,\\n        address _owner,\\n        address _paymentHub\\n    )\\n        Ownable(_owner)\\n    {\\n        base = _base;\\n        token = _token;\\n        price = _price;\\n        increment = _increment;\\n        paymenthub = _paymentHub;\\n        // Should we disabled recoverability in the recovery hub here?\\n        // No, if someone attacks us, we can always trigger a transfer and recover the tokens as well as the collateral.\\n    }\\n\\n    function setPrice(uint256 _price, uint256 _increment) external onlyOwner {\\n        anchorPrice(_price);\\n        increment = _increment;\\n        emit PriceSet(_price, _increment);\\n    }\\n\\n    function hasDrift() public view returns (bool) {\\n        return timeToDrift != 0;\\n    }\\n\\n    // secondsPerStep should be negative for downwards drift\\n    function setDrift(uint256 secondsPerStep, int256 _driftIncrement) external onlyOwner {\\n        anchorPrice(getPrice());\\n        timeToDrift = secondsPerStep;\\n        driftIncrement = _driftIncrement;\\n        emit DriftSet(secondsPerStep, _driftIncrement);\\n    }\\n\\n    function anchorPrice(uint256 currentPrice) private {\\n        price = currentPrice;\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        driftStart = block.timestamp;\\n    }\\n\\n    function getPrice() public view returns (uint256) {\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        return getPriceAtTime(block.timestamp);\\n    }\\n\\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\\n        if (hasDrift()){\\n            uint256 passed = timestamp - driftStart;\\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\\n            int256 driftedPrice = int256(price) + drifted;\\n            if (driftedPrice < 0){\\n                return 0;\\n            } else {\\n                return uint256(driftedPrice);\\n            }\\n        } else {\\n            return price;\\n        }\\n    }\\n\\n    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\\n        if (!hasSetting(BUYING_ENABLED)) {\\n            revert Brokerbot_BuyingDisabled();\\n        }\\n        uint shares = getShares(paid);\\n        uint costs = getBuyPrice(shares);\\n        notifyTraded(from, shares, costs, ref);\\n        if (costs < paid){\\n            base.safeTransfer(from, paid - costs);\\n        }\\n        IERC20(token).safeTransfer(from, shares);\\n        return shares;\\n    }\\n\\n    // Callers must verify that (hasSetting(BUYING_ENABLED) || msg.sender == owner) holds!\\n    function notifyTraded(address from, uint256 shares, uint256 costs, bytes calldata ref) internal returns (uint256) {\\n        // disabling the requirement below for efficiency as this always holds once we reach this point\\n        // require(hasSetting(BUYING_ENABLED) || msg.sender == owner, \\\"buying disabled\\\");\\n        price = price + (shares * increment);\\n        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\\n        return costs;\\n    }\\n\\n    function notifyTrade(address buyer, uint256 shares, uint256 costs, bytes calldata ref) external onlyOwner {\\n        notifyTraded(buyer, shares, costs, ref);\\n    }\\n\\n    function notifyTradeAndTransfer(address buyer, uint256 shares, uint256 costs, bytes calldata ref) public onlyOwner {\\n        notifyTraded(buyer, shares, costs, ref);\\n        IERC20(token).safeTransfer(buyer, shares);\\n    }\\n\\n    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, uint256[] calldata costs, bytes[] calldata ref) external onlyOwner {\\n        for (uint i = 0; i < buyers.length; i++) {\\n            notifyTraded(buyers[i], shares[i], costs[i], ref[i]);\\n        }\\n    }\\n\\n    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, uint256[] calldata costs, bytes[] calldata ref) external onlyOwner {\\n        for (uint i = 0; i < buyers.length; i++) {\\n            notifyTradeAndTransfer(buyers[i], shares[i], costs[i], ref[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Payment hub might actually have sent another accepted token, including Ether.\\n     * @dev Is either called from payment hub or from transferAndCall of the share token (via onTokenTransfer).\\n     * @param incomingAsset the erc20 address of either base currency or the share token.\\n     * @param from Who iniciated the sell/buy.\\n     * @param amount The amount of shares the are sold / The base amount paid to buy sharees.\\n     * @param ref Reference data blob.\\n     * @return The amount of shares bought / The amount received for selling the shares. \\n     */\\n    function processIncoming(IERC20 incomingAsset, address from, uint256 amount, bytes calldata ref) public override payable returns (uint256) {\\n        if (msg.sender != address(incomingAsset) && msg.sender != paymenthub) {\\n            revert Brokerbot_InvalidSender(msg.sender);\\n        }\\n        if(msg.value > 0) {\\n            emit Received(from, msg.value, amount);\\n        }\\n        if (incomingAsset == token){\\n            return sell(from, amount, ref);\\n        } else if (incomingAsset == base){\\n            return buy(from, amount, ref);\\n        } else {\\n            revert(\\\"invalid token\\\");\\n        }\\n    }\\n\\n    // ERC-677 recipient\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) external returns (bool) {\\n        processIncoming(IERC20(msg.sender), from, amount, ref);\\n        return true;\\n    }\\n\\n    function hasSetting(uint256 setting) private view returns (bool) {\\n        return settings & setting == setting;\\n    }\\n\\n    /**\\n     * ref 0x01 or old format sells shares for base currency.\\n     * ref 0x02 indicates a sell via bank transfer.\\n     */\\n    function isDirectSale(bytes calldata ref) internal pure returns (bool) {\\n        if (ref.length == 0 || ref.length == 20) {\\n            return true; // old format\\n        } else {\\n            if (ref[0] == bytes1(0x01)){\\n                return true;\\n            } else if (ref[0] == bytes1(0x02)) {\\n                return false;\\n            } else {\\n                revert(\\\"unknown ref\\\");\\n            }\\n        }\\n    }\\n\\n\\n    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\\n        if (!hasSetting(SELLING_ENABLED)) {\\n            revert Brokerbot_SellingDisabled();\\n        }\\n        uint256 totPrice = getSellPrice(amount);\\n        price -= amount * increment;\\n        if (isDirectSale(ref)){\\n            base.safeTransfer(recipient, totPrice);\\n        }\\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, 0, getPrice());\\n        return totPrice;\\n    }\\n\\n    function getSellPrice(uint256 shares) public view override returns (uint256) {\\n        return getPrice(getPrice() - (shares * increment), shares);\\n    }\\n\\n    function getBuyPrice(uint256 shares) public view override returns (uint256) {\\n        return getPrice(getPrice(), shares);\\n    }\\n\\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\\n        if (shares == 0) {\\n            return 0;\\n        } else {\\n            uint256 highest = lowest + (shares - 1) * increment;\\n            return ((lowest + highest) / 2) * shares;\\n        }\\n    }\\n\\n    function getShares(uint256 money) public view returns (uint256) {\\n        uint256 currentPrice = getPrice();\\n        uint256 min = 0;\\n        uint256 max = money / currentPrice;\\n        while (min < max){\\n            uint256 middle = (min + max)/2;\\n            uint256 totalPrice = getPrice(currentPrice, middle);\\n            if (money > totalPrice){\\n                min = middle + 1;\\n            } else {\\n                max = middle;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    function withdrawEther(address target, uint256 amount) public ownerOrHub() {\\n        (bool success, ) = payable(target).call{value:amount}(\\\"\\\");\\n        if (!success) {\\n            revert Brokerbot_WithdrawFailed(target, amount);\\n        }\\n        emit Withdrawn(target, amount);\\n    }\\n\\n    function withdrawEther(uint256 amount) external ownerOrHub() {\\n        withdrawEther(msg.sender, amount);\\n    }\\n\\n    function approve(address erc20, address who, uint256 amount) external onlyOwner() {\\n        IERC20(erc20).approve(who, amount);\\n    }\\n\\n    function withdraw(IERC20 ercAddress, address to, uint256 amount) external ownerOrHub() {\\n        ercAddress.safeTransfer(to, amount);\\n    }\\n\\n    function setPaymentHub(address hub) external onlyOwner() {\\n        paymenthub = hub;\\n        emit PaymentHubUpdate(paymenthub);\\n    }\\n\\n    function setSettings(uint256 _settings) public onlyOwner() {\\n        settings = _settings;\\n        emit SettingsChange(_settings);\\n    }\\n\\n    function setEnabled(bool _buyingEnabled, bool _sellingEnabled) external onlyOwner() {\\n        uint256 _settings = settings;\\n        if (_buyingEnabled != hasSetting(BUYING_ENABLED)){\\n            _settings ^= BUYING_ENABLED;\\n        }\\n        if (_sellingEnabled != hasSetting(SELLING_ENABLED)){\\n            _settings ^= SELLING_ENABLED;\\n        }\\n        setSettings(_settings);\\n    }\\n    \\n    modifier ownerOrHub() {\\n        if (owner != msg.sender && paymenthub != msg.sender) {\\n            revert Brokerbot_NotAuthorized(msg.sender);\\n        }\\n        _;\\n    }\\n}\\n\"\n    },\n    \"src/brokerbot/BrokerbotQuoter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IUniswapV3.sol\\\";\\nimport \\\"../utils/Path.sol\\\";\\nimport \\\"./BrokerbotRegistry.sol\\\";\\nimport \\\"../utils/BrokerbotLib.sol\\\";\\n/**\\n * @title Brokerbot Swap Quoter\\n * @author Bernhard Ruf, bernhard@aktionariat.com \\n */ \\ncontract BrokerbotQuoter is IQuoter {\\n\\tusing Path for bytes;\\n\\n\\taddress private immutable weth;\\n\\tIQuoter private immutable uniswapQuoter;\\n\\tBrokerbotRegistry private immutable brokerbotRegistry;\\n\\n\\tconstructor(address _weth,  IQuoter _Quoter, BrokerbotRegistry _registry) {\\n\\t\\tweth = _weth;\\n\\t\\tuniswapQuoter = _Quoter;\\n\\t\\tbrokerbotRegistry = _registry;\\n\\t}\\n\\n\\t/// @inheritdoc IQuoter\\n\\t/// @dev only used for buying shares with base currency\\n\\tfunction quoteExactOutputSingle(\\n\\t\\taddress tokenIn,\\n\\t\\taddress tokenOut,\\n\\t\\tuint24 /*fee*/,\\n\\t\\tuint256 amountOut,\\n\\t\\tuint160 /*sqrtPriceLimitX96*/\\n\\t) external view override returns (uint256 amountIn) {\\n\\t\\t(IBrokerbot brokerbot, ) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(tokenIn), IERC20(tokenOut));\\n\\t\\tamountIn = brokerbot.getBuyPrice(amountOut);\\n\\t}\\n\\n\\t/// @inheritdoc IQuoter\\n\\tfunction quoteExactOutput(bytes memory path, uint256 amountOut) external override returns (uint256 amountIn) {\\n\\t\\t(address shareToken, address baseToken, ) = path.decodeFirstPool();\\n\\t\\t(IBrokerbot brokerbot, ) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(baseToken), IERC20(shareToken));\\n\\t\\t// get price from brokerbot\\n\\t\\tamountIn = brokerbot.getBuyPrice(amountOut);\\n\\t\\tif (path.hasMultiplePools()) {\\n\\t\\t\\tpath = path.skipToken();\\n\\t\\t\\tamountIn = uniswapQuoter.quoteExactOutput(path, amountIn);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @inheritdoc IQuoter\\n\\tfunction quoteExactInput(bytes memory path, uint256 amountIn) external override returns (uint256 amountOut) {\\n\\t\\t(address shareToken, address baseToken, ) = path.decodeFirstPool();\\n\\t\\t(IBrokerbot brokerbot, ) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(baseToken), IERC20(shareToken));\\n\\t\\tamountOut = brokerbot.getSellPrice(amountIn);\\n\\t\\tif (path.hasMultiplePools()) {\\n\\t\\t\\tpath = path.skipToken();\\n\\t\\t\\tamountOut = uniswapQuoter.quoteExactInput(path, amountOut);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @inheritdoc IQuoter\\n\\t/// @dev only used for selling shares for base currency\\n\\tfunction quoteExactInputSingle(\\n\\t\\t\\taddress tokenIn,\\n\\t\\t\\taddress tokenOut,\\n\\t\\t\\tuint24 /*fee*/,\\n\\t\\t\\tuint256 amountIn,\\n\\t\\t\\tuint160 /*sqrtPriceLimitX96*/\\n\\t) public view override returns (uint256 amountOut) {\\n\\t\\t(IBrokerbot brokerbot, ) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(tokenOut), IERC20(tokenIn));\\n\\t\\tamountOut = brokerbot.getSellPrice(amountIn);\\n\\t}\\n\\n\\tfunction WETH9() external view override returns (address) {\\n        return weth;\\n    }\\n}\"\n    },\n    \"src/brokerbot/BrokerbotRegistry.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* Proprietary License\\n*\\n* This code cannot be used without an explicit permission from the copyright holder.\\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com), All rights reserved.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/// @title Brokerbot Registry\\n/// @notice Holds a registry from all deployed active brokerbots\\ncontract BrokerbotRegistry is Ownable {\\n  /// @notice Returns the brokerbot address for a given pair base and share token, or address 0 if it does not exist\\n  /// @dev mapping is [base][token] = brokerbotAddress\\n  /// @return brokerbot The brokerbot address\\n  mapping(IERC20 => mapping(IERC20 => IBrokerbot)) public getBrokerbot;\\n\\n  /// @notice Emitted when brokerbot is registered.\\n  /// @param brokerbot The address of the brokerbot\\n  /// @param base The address of the base currency\\n  /// @param token The address of the share token\\n  event RegisterBrokerbot(IBrokerbot brokerbot, IERC20 indexed base, IERC20 indexed token);\\n\\n  /// @notice Emmitted when calling syncBrokerbot function\\n  /// @param brokerbot The brokerbot address that is synced\\n  event SyncBrokerbot(IBrokerbot indexed brokerbot);\\n\\n  constructor(address _owner) Ownable(_owner) {}\\n\\n  /// @notice Per network only one active brokerbot should exist per base/share pair\\n  /// @param _brokerbot The brokerbot contract that should be registered.\\n  /// @param _base The contract of the base currency of the brokerbot.\\n  /// @param _token The contract of the share token of the brokerbot.\\n  function registerBrokerbot(IBrokerbot _brokerbot, IERC20 _base, IERC20 _token ) external onlyOwner() {\\n    getBrokerbot[_base][_token] = _brokerbot;\\n    emit RegisterBrokerbot(_brokerbot, _base, _token);\\n  }\\n\\n  /// @notice This event is usful for indexers/subgraphs to update token balances which are not tracked with other events\\n  /// @param _brokerbot The brokerbot that should be synced\\n  function syncBrokerbot(IBrokerbot _brokerbot) external {\\n    emit SyncBrokerbot(_brokerbot);\\n  }\\n\\n}\"\n    },\n    \"src/brokerbot/BrokerbotRouter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IUniswapV3.sol\\\";\\nimport \\\"./Brokerbot.sol\\\";\\nimport \\\"./PaymentHub.sol\\\";\\nimport \\\"./BrokerbotRegistry.sol\\\";\\nimport \\\"../ERC20/IERC677.sol\\\";\\nimport \\\"../utils/Path.sol\\\";\\nimport \\\"../utils/BrokerbotLib.sol\\\";\\n/**\\n * @title Brokerbot Swap Router\\n * @author Bernhard Ruf, bernhard@aktionariat.com \\n */ \\ncontract BrokerbotRouter is ISwapRouter {\\n\\tusing Path for bytes;\\n\\tusing SafeERC20 for IERC20;\\n\\n\\tBrokerbotRegistry public immutable brokerbotRegistry;\\n\\n\\terror Brokerbot_Deadline_Reached();\\n\\n\\tconstructor(BrokerbotRegistry _registry) {\\n\\t\\tbrokerbotRegistry = _registry;\\n\\t}\\n\\n\\tmodifier checkDeadline(uint256 deadline) {\\n\\t\\tif (deadline < block.timestamp) revert Brokerbot_Deadline_Reached();\\n  \\t_;\\n\\t}\\n\\n\\t// solhint-disable-next-line no-empty-blocks\\n\\treceive() external payable {\\n\\t\\t\\t// Important to receive ETH refund from PaymentHub\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buy share tokens with base currency.\\n\\t * @dev not usable to sell shares for excact output, as shares is not divisible (decimals is 0).\\n\\t * @dev Single swap with ETH works, but base currency address has to be provided as tokenIn.\\n\\t * @param params Params struct for swap. See @ISwapRouter for struct definition.\\n\\t */\\n\\tfunction exactOutputSingle(\\n\\t\\tExactOutputSingleParams calldata params\\n\\t) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\\n\\t\\t(IBrokerbot brokerbot, PaymentHub paymentHub) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(params.tokenIn), IERC20(params.tokenOut));\\n\\t\\tif (msg.value > 0) {\\n\\t\\t\\tamountIn = _buyWithEther(brokerbot, paymentHub, params.amountOut, msg.value);\\n\\t\\t\\trefundETH();\\n\\t\\t} else {\\n\\t\\t\\tamountIn = _exactOutputInternalPrepare(brokerbot, paymentHub, params.amountOut, params.amountInMaximum, IERC20(params.tokenIn));\\n\\t\\t\\t// call paymenthub to buy shares with base currency\\n\\t\\t\\tpaymentHub.payAndNotify(brokerbot, amountIn,  bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\trefundERC20(IERC20(params.tokenIn));\\n\\t\\t}\\n\\t\\tIERC20(params.tokenOut).safeTransfer(msg.sender, params.amountOut);\\n  }\\n\\n\\t/**\\n\\t * @notice Buy share tokens with any erc20 by given a uniswap routing path\\n\\t * @dev If ETH is sent this function will try to swap ETH for share tokens directly and will ignore the path.\\n\\t * @param params Params struct for swap. See @ISwapRouter for struct definition.\\n\\t * @return amountIn The amountIn actually spent.\\n\\t */\\n\\tfunction exactOutput(ExactOutputParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\\n\\t\\tbytes memory modifiedPath = params.path;\\n\\t\\t(address shareToken, address baseToken, ) = params.path.decodeFirstPool();\\n\\t\\t(, address firstTokenIn, ) = params.path.getLastPool().decodeFirstPool();\\n\\t\\t(IBrokerbot brokerbot, PaymentHub paymentHub) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(baseToken), IERC20(shareToken));\\n\\t\\tif (msg.value > 0) {\\n\\t\\t\\tamountIn = _buyWithEther(brokerbot, paymentHub, params.amountOut, msg.value);\\n\\t\\t\\trefundETH();\\n\\t\\t} else {\\n\\t\\t\\tamountIn = _exactOutputInternalPrepare(brokerbot, paymentHub, params.amountOut, params.amountInMaximum, IERC20(firstTokenIn));\\n\\t\\t\\tif (params.path.hasMultiplePools()) {\\n\\t\\t\\t\\tmodifiedPath = params.path.skipToken();\\n\\t\\t\\t\\t(amountIn, ) = paymentHub.payFromERC20AndNotify(brokerbot, amountIn, firstTokenIn, params.amountInMaximum, modifiedPath, bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpaymentHub.payAndNotify(brokerbot, params.amountInMaximum,  bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\t}\\n\\t\\t\\trefundERC20(IERC20(firstTokenIn));\\n\\t\\t}\\n\\t\\tIERC20(shareToken).safeTransfer(params.recipient, params.amountOut);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sell `amountIn` of share tokens for base currency.\\n\\t * @dev Only use it for selling shares, else there will be no brokerbot found. Output can't be ETH you have to swap WETH to ETH on your integration.\\n\\t * @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata.\\n\\t * @return amountOut The amountOut actually received.\\n\\t */\\n\\tfunction exactInputSingle(\\n\\t\\tExactInputSingleParams calldata params\\n\\t) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\\n\\t\\t(IBrokerbot brokerbot,) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(params.tokenOut), IERC20(params.tokenIn));\\n\\t\\tIERC20(params.tokenIn).safeTransferFrom(msg.sender, address(this), params.amountIn); // transfer shares into this contract\\n\\t\\t// send shares to brokerbot to sell them against base currency\\n\\t\\tIERC677(params.tokenIn).transferAndCall(address(brokerbot), params.amountIn, bytes(\\\"\\\\x01\\\"));\\n\\t\\t// transfer base currency to recipient\\n\\t\\tamountOut = IERC20(params.tokenOut).balanceOf(address(this));\\n\\t\\tIERC20(params.tokenOut).safeTransfer(params.recipient, amountOut);\\n\\t}\\n\\n  /**\\n\\t* @notice Sell `amountIn` of share tokens for as much as possible of another along the specified path\\n    * @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    * @return amountOut The amount of the received token\\n\\t*/\\n\\tfunction exactInput(ExactInputParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\\n\\t\\t(address shareToken, address baseToken,) = params.path.decodeFirstPool();\\n\\t\\t(IBrokerbot brokerbot, PaymentHub paymentHub) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(baseToken), IERC20(shareToken));\\n\\n\\t\\tIERC20(shareToken).safeTransferFrom(msg.sender, address(this), params.amountIn); // transfer shares into this contract\\n\\t\\tif (IERC20(shareToken).allowance(address(this), address(paymentHub)) == 0){\\n\\t\\t\\t// max is fine as the router shouldn't hold any funds, so this should be ever only needed to be set once per token/paymenthub\\n\\t\\t\\tIERC20(shareToken).approve(address(paymentHub), type(uint256).max); \\n\\t\\t}\\n\\t\\tif (params.path.hasMultiplePools()) {\\n\\t\\t\\tExactInputParams memory modifiedParams = params;\\n\\t\\t\\tmodifiedParams.path = params.path.skipToken();\\n\\t\\t\\tamountOut = paymentHub.sellSharesAndSwap(brokerbot, IERC20(shareToken), params.amountIn, bytes(\\\"\\\\x01\\\"), modifiedParams, false);\\n\\t\\t} else {\\n\\t\\t\\tIERC677(shareToken).transferAndCall(address(brokerbot), params.amountIn, bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\t// transfer base currency to recipient\\n\\t\\t\\tamountOut = IERC20(baseToken).balanceOf(address(this));\\n\\t\\t\\tIERC20(baseToken).safeTransfer(params.recipient, amountOut);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Remember to call this function if you make a swap with ETH.\\n\\t */\\n\\tfunction refundETH() public payable override {\\n\\t\\tif(address(this).balance > 0) {\\n\\t\\t\\t(bool success, ) = msg.sender.call{value: address(this).balance}(new bytes(0));\\n\\t\\t\\trequire(success, 'STF');\\n\\t\\t}\\n\\t}\\n\\n\\tfunction refundERC20(IERC20 token) public {\\n\\t\\tuint256 erc20Balance = token.balanceOf(address(this));\\n\\t\\tif(erc20Balance > 0) {\\n\\t\\t\\ttoken.safeTransfer(msg.sender, erc20Balance);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _buyWithEther(IBrokerbot brokerbot, PaymentHub paymentHub, uint256 shareAmount, uint256 ethAmount) internal returns (uint256 amountIn) {\\n\\t\\tuint256 baseAmount = brokerbot.getBuyPrice(shareAmount);\\n\\t\\t(amountIn,) = paymentHub.payFromEtherAndNotify{value: ethAmount}(brokerbot, baseAmount, bytes(\\\"\\\\x01\\\"));\\t\\n    }\\n\\n\\tfunction _exactOutputInternalPrepare(IBrokerbot brokerbot, PaymentHub paymentHub, uint256 amountShares, uint256 amountInMaximum, IERC20 tokenIn) internal  returns (uint256 amountIn) {\\n\\t\\tamountIn = brokerbot.getBuyPrice(amountShares); // get current price, so nothing needs to be refunded\\n\\t\\ttokenIn.transferFrom(msg.sender, address(this), amountInMaximum); // transfer base currency into this contract\\n        if (tokenIn.allowance(address(this), address(paymentHub)) == 0){\\n\\t\\t\\t// max is fine as the router shouldn't hold any funds, so this should be ever only needed to be set once per token/paymenthub\\n\\t\\t\\ttokenIn.approve(address(paymentHub), type(uint256).max); \\n\\t\\t}\\n\\t}\\n}\"\n    },\n    \"src/brokerbot/IBrokerbot.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\n\\ninterface IBrokerbot {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n  //////////////////////////////////////////////////////////////*/\\n  error Brokerbot_BuyingDisabled();\\n  error Brokerbot_SellingDisabled();\\n  /// Sender(msg.sender) has to be incoming token or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_InvalidSender(address sender);\\n  /// target.call() wasn't successful.\\n  /// @param target The receiver of the Eth.\\n  /// @param amount The withdraw amount.\\n  error Brokerbot_WithdrawFailed(address target, uint256 amount);\\n  /// Sender(msg.sender) needs to be owner or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_NotAuthorized(address sender);\\n\\n  function paymenthub() external view returns (address);\\n\\n  function base() external view returns (IERC20);\\n\\n  function token() external view returns (IERC20Permit);\\n  \\n  function settings() external view returns (uint256);\\n\\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\\n\\n  function getBuyPrice(uint256 shares) external view returns (uint256);\\n\\n  function getSellPrice(uint256 shares) external view returns (uint256);\\n\\n}\"\n    },\n    \"src/brokerbot/IUniswapV3.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copied from \\n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\\n// https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IQuoter {\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n    \\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH9() external view returns (address);\\n}\\n\\ninterface ISwapRouter {\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n    \\n    function refundETH() external payable;\\n}\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\"\n    },\n    \"src/brokerbot/PaymentHub.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\nimport \\\"./IUniswapV3.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\n/**\\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\\n * Instead, an allowance needs to be set only once, namely for this contract.\\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap or the reception of Ether\\n * using the current exchange rate as found in the chainlink oracle.\\n */\\ncontract PaymentHub {\\n\\n    using SafeERC20 for IERC20;\\n\\n    // Version history\\n    // Version 4: added path to pay with any ecr20 via uniswap\\n    // Version 5: added sell via permit\\n    // Version 6: added transferEther function\\n    // Version 7: added sell against eth and erc20, version, add permitinfo/swapinfo struct\\n    // Version 8: use SafeERC20 for transfers\\n    uint8 public constant VERSION = 0x8;\\n\\n    address public trustedForwarder;\\n\\n    uint24 private constant DEFAULT_FEE = 3000;\\n    uint256 private constant DENOMINATOR = 1e8;\\n    address private constant CHF_TOKEN = 0xB4272071eCAdd69d933AdcD19cA99fe80664fc08;\\n\\n    uint8 private constant KEEP_ETHER = 0x4; // copied from brokerbot\\n    \\n    IQuoter private immutable uniswapQuoter;\\n    ISwapRouter private immutable uniswapRouter;\\n\\n    struct PermitInfo {\\n        uint256 exFee;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    // event to when new forwarder is set\\n    event ForwarderChanged(address indexed _oldForwarder, address indexed _newForwarder);\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n    //////////////////////////////////////////////////////////////*/\\n    /// Failguard when an erc20 transfer returns false. \\n    error PaymentHub_TransferFailed();\\n    /// Sender not trusted.\\n    /// @param sender The msg.sender of this transaction.\\n    error PaymentHub_InvalidSender(address sender);\\n    /// swap with less base token as required.\\n    /// @param amountBase Required amount.\\n    /// @param swappedAmount Swapped amount.\\n    error PaymentHub_SwapError(uint256 amountBase, uint256 swappedAmount);\\n\\n    constructor(address _trustedForwarder, IQuoter _quoter, ISwapRouter swapRouter) {\\n        trustedForwarder = _trustedForwarder;\\n        uniswapQuoter = _quoter;\\n        uniswapRouter = swapRouter;\\n    }\\n\\n    modifier onlySellerAndForwarder(address seller) {\\n        if (msg.sender != trustedForwarder && msg.sender != seller) {\\n            revert PaymentHub_InvalidSender(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyForwarder() {\\n        if (msg.sender != trustedForwarder) {\\n            revert PaymentHub_InvalidSender(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Change the trusted forwarder.\\n     * @param newForwarder The new trusted forwarder.\\n     */\\n     function changeForwarder(address newForwarder) external onlyForwarder {\\n        trustedForwarder = newForwarder;\\n        emit ForwarderChanged(msg.sender, newForwarder);\\n    }\\n\\n    /**  \\n     * Get price in ERC20\\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\\n     * @param amountInBase The amount of the base currency for the exact output.\\n     * @param path The encoded path of the swap from erc20 to base.\\n     * @return amount quoted to pay\\n     */\\n    function getPriceInERC20(uint256 amountInBase, bytes memory path) public returns (uint256) {\\n        return getPriceERC20(amountInBase, path, true);\\n    }\\n    \\n    /**\\n     * @notice Get price for given amount and path swapped via uniswap. \\n     * @param amount The exact amount which you want get out (exactOutput) or you put in (exactInput).\\n     * @param path The path of the swap (inreverse order for exactOutput).\\n     * @param exactOutput True if exactOutput should be used or false if exactInput should be used.\\n     */\\n    function getPriceERC20(uint256 amount, bytes memory path, bool exactOutput) public returns (uint256) {\\n        if (exactOutput) {\\n            return uniswapQuoter.quoteExactOutput(\\n                path,\\n                amount\\n            );\\n        } else {\\n            return uniswapQuoter.quoteExactInput(\\n                path,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Get price in Ether depding on brokerbot setting.\\n     * If keep ETH is set price is from oracle.\\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\\n     * @return The price in wei.\\n     */\\n    function getPriceInEther(uint256 amountInBase, IBrokerbot brokerBot) public returns (uint256) {\\n        return uniswapQuoter.quoteExactOutputSingle(uniswapQuoter.WETH9(), address(brokerBot.base()), DEFAULT_FEE, amountInBase, 0);\\n    }\\n\\n    /**\\n     * Convenience method to swap ether into base and pay a target address\\n     */\\n    function payFromEther(address recipient, uint256 amountInBase, IERC20 base) public payable returns (uint256 amountIn) {\\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\\n            // rely on time stamp is ok, no exact time stamp needed\\n            // solhint-disable-next-line not-rely-on-time\\n            uniswapQuoter.WETH9(), address(base), DEFAULT_FEE, recipient, block.timestamp, amountInBase, msg.value, 0);\\n\\n        ISwapRouter swapRouter = uniswapRouter;\\n        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.\\n        amountIn = swapRouter.exactOutputSingle{value: msg.value}(params);\\n\\n        // For exact output swaps, the amountInMaximum may not have all been spent.\\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\\n        if (amountIn < msg.value) {\\n            swapRouter.refundETH();\\n            (bool success, ) = msg.sender.call{value:msg.value - amountIn}(\\\"\\\"); // return change\\n            if (!success) {\\n                revert PaymentHub_TransferFailed();\\n            }\\n        }\\n    }\\n\\n    /// @dev The calling address must approve this contract to spend its ERC20 for this function to succeed. As the amount of input ERC20 is variable,\\n    /// the calling address will need to approve for a slightly higher or infinit amount, anticipating some variance.\\n    /// @param amountOut The desired amount of baseCurrency.\\n    /// @param amountInMaximum The maximum amount of ERC20 willing to be swapped for the specified amountOut of baseCurrency.\\n    /// @param erc20In The address of the erc20 token to pay with.\\n    /// @param path The encoded path of the swap from erc20 to base.\\n    /// @param recipient The reciving address - brokerbot.\\n    /// @return amountIn The amountIn of ERC20 actually spent to receive the desired amountOut.\\n    function payFromERC20(uint256 amountOut, uint256 amountInMaximum, address erc20In, bytes memory path, address recipient) public returns (uint256 amountIn) {\\n        ISwapRouter swapRouter = uniswapRouter;\\n        // Transfer the specified `amountInMaximum` to this contract.\\n        IERC20(erc20In).safeTransferFrom(msg.sender, address(this), amountInMaximum);\\n\\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\\n        ISwapRouter.ExactOutputParams memory params =\\n            ISwapRouter.ExactOutputParams({\\n                path: path,\\n                recipient: recipient,\\n                // solhint-disable-next-line not-rely-on-time\\n                deadline: block.timestamp,\\n                amountOut: amountOut,\\n                amountInMaximum: amountInMaximum\\n            });\\n\\n        // Executes the swap, returning the amountIn actually spent.\\n        amountIn = swapRouter.exactOutput(params);\\n\\n        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.\\n        if (amountIn < amountInMaximum) {\\n            IERC20(erc20In).safeTransfer(msg.sender, amountInMaximum - amountIn);\\n        }\\n    }\\n\\n    ///This function appoves infinite allowance for Uniswap, this is safe as the paymenthub should never hold any token (see also recover() ).\\n    ///@dev This function needs to be called before using the PaymentHub the first time with a new ERC20 token.\\n    ///@param erc20In The erc20 addresse to approve.\\n    function approveERC20(address erc20In) external {\\n        IERC20(erc20In).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    function multiPay(IERC20 token, address[] calldata recipients, uint256[] calldata amounts) public {\\n        for (uint i=0; i<recipients.length; i++) {\\n            IERC20(token).safeTransferFrom(msg.sender, recipients[i], amounts[i]);\\n        }\\n    }\\n\\n    /**\\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\\n     */\\n    function multiPayAndNotify(IERC20 token, IBrokerbot[] calldata brokerbots, uint256[] calldata amounts, bytes calldata ref) external {\\n        for (uint i=0; i<brokerbots.length; i++) {\\n            payAndNotify(token, brokerbots[i], amounts[i], ref);\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows to make a base currency payment from the sender to the brokerbot, given an allowance to this contract.\\n     * @dev Equivalent to xchf.transferAndCall(brokerbot, amountInBase)\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountInBase The amount of base currency used to buy shares.\\n     * @param ref The reference data blob.\\n     * @return The amount of shares bought\\n     */\\n    function payAndNotify(IBrokerbot brokerbot, uint256 amountInBase, bytes calldata ref) external returns (uint256) {\\n        return payAndNotify(brokerbot.base(), brokerbot, amountInBase, ref);\\n    }\\n\\n    function payAndNotify(IERC20 token, IBrokerbot brokerbot, uint256 amount, bytes calldata ref) public returns (uint256) {\\n        token.safeTransferFrom(msg.sender, address(brokerbot), amount);\\n        return brokerbot.processIncoming(token, msg.sender, amount, ref);\\n    }\\n\\n    /**\\n     * @notice Pay with Ether to buy shares.\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountInBase The amount of base currency used to buy shares.\\n     * @param ref The reference data blob.\\n     * @return priceInEther The amount of Ether spent.\\n     * @return sharesOut The amount of shares bought.\\n     */\\n    function payFromEtherAndNotify(IBrokerbot brokerbot, uint256 amountInBase, bytes calldata ref) external payable returns (uint256 priceInEther, uint256 sharesOut) {\\n        IERC20 base = brokerbot.base();\\n        priceInEther = payFromEther(address(brokerbot), amountInBase, base);\\n        sharesOut = brokerbot.processIncoming(base, msg.sender, amountInBase, ref);\\n    }\\n\\n    /***\\n     * @notice Pay from any ERC20 token (which has Uniswapv3 ERC20-ETH pool) and send swapped base currency to brokerbot.\\n     * @notice The needed amount needs to be approved at the ERC20 contract beforehand\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountBase The amount of base currency used to buy shares.\\n     * @param erc20 The address of the ERC20 token to pay.\\n     * @param amountInMaximum The maximum amount of the ERC20 to pay (should include some slippage).\\n     * @param path The encoded path of the swap from erc20 to base currency.\\n     * @param ref Reference data blob.\\n     * @return amountIn The amount erc20 spent to buy shares.\\n     * @return amountOut The amount of shares received by the brokerbot.\\n     */\\n    function payFromERC20AndNotify(IBrokerbot brokerbot, uint256 amountBase, address erc20, uint256 amountInMaximum, bytes memory path, bytes calldata ref) external returns (uint256 amountIn, uint256 amountOut) {\\n        IERC20 base = brokerbot.base();\\n        uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\\n        amountIn = payFromERC20(amountBase, amountInMaximum, erc20, path, address(brokerbot));\\n        uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\\n        if (amountBase != (balanceAfter - balanceBefore)) {\\n            revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\\n        }        \\n        amountOut = brokerbot.processIncoming(base, msg.sender, balanceAfter - balanceBefore, ref);\\n    }\\n\\n    /**\\n     * @notice Sell shares with permit\\n     * @param brokerbot The brokerbot to recive the shares.\\n     * @param seller The address of the seller.\\n     * @param recipient The address of the recipient of the sell preceeds.\\n     * @param amountToSell The amount the seller wants to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param permitInfo Information about the permit.\\n     * @return The base currency amount for the selling of the shares.\\n     */\\n    function sellSharesWithPermit(IBrokerbot brokerbot, IERC20Permit shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo) public onlySellerAndForwarder(seller) returns (uint256) {\\n        // Call permit to set allowance\\n        shares.permit(seller, address(this), amountToSell, permitInfo.deadline, permitInfo.v, permitInfo.r,permitInfo.s);\\n        // process sell\\n        if (permitInfo.exFee > 0){\\n            uint256 proceeds = _sellShares(brokerbot, shares, seller, address(this), amountToSell, ref);\\n            IERC20 currency = brokerbot.base();\\n            currency.safeTransfer(msg.sender, permitInfo.exFee);\\n            currency.safeTransfer(recipient, proceeds - permitInfo.exFee);\\n            return proceeds - permitInfo.exFee;\\n        } else {\\n            return _sellShares(brokerbot, shares, seller, recipient, amountToSell, ref);\\n        }\\n    }\\n\\n    /**\\n     * @notice With this function a user can sell shares with permit and swap them to a desired token.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param seller The seller address.\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param permitInfo Information about the permit.\\n     * @param params Information about the swap.\\n     * @return The output amount of the swap to the desired token.\\n     */\\n    function sellSharesWithPermitAndSwap(IBrokerbot brokerbot, IERC20Permit shares, address seller,  uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external onlySellerAndForwarder(seller) returns (uint256) {\\n        params.amountIn = sellSharesWithPermit(brokerbot, shares, seller, address(this), amountToSell, ref, permitInfo);\\n        return _swap(params, unwrapWeth);\\n    }\\n\\n    /**\\n     * @notice With this function a user can sell shares and swap them to a desired token. The user has to approve the paymenthub before on the shares contract.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param params Information about the swap.\\n     * @return The output amount of the swap to the desired token.\\n     */\\n    function sellSharesAndSwap(IBrokerbot brokerbot, IERC20 shares, uint256 amountToSell,  bytes calldata ref, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external returns (uint256) {\\n        params.amountIn = _sellShares(brokerbot, shares, msg.sender, address(this), amountToSell, ref);\\n        return _swap(params, unwrapWeth);\\n    }\\n\\n    /**\\n     * @notice Transfers shares to brokerbot and executes the selling.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param seller The seller address.\\n     * @param recipient The recipient of the base currency tokens. (this can be a 3rd party to off-ramp or the paymenthub itself if a swap will be done direct after)\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @return The base currency amount for the selling of the shares.\\n     */ \\n    function _sellShares(IBrokerbot brokerbot, IERC20 shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref ) internal returns (uint256) {\\n        // send shares token to brokerbot\\n        shares.safeTransferFrom(seller, address(brokerbot), amountToSell);\\n        // process sell on brokerbot\\n        return brokerbot.processIncoming(shares, recipient, amountToSell, ref);\\n    }\\n\\n    /**\\n     * @notice Swap (base currency) token according to given path and unwrap weth if needed.\\n     * @param params Information about the swap (includes path).\\n     * @return amountOut The output amount of the swap to the desired token.\\n     */\\n    function _swap(ISwapRouter.ExactInputParams memory params, bool unwrapWeth) internal returns(uint256 amountOut) {\\n        // if weth should be unwrapped, swap recipient is this contract and eth is send to seller\\n        if (unwrapWeth){\\n            address seller = params.recipient;\\n            params.recipient = address(this);\\n            amountOut = _swapToERC20(params);\\n            IWETH9(uniswapQuoter.WETH9()).withdraw(amountOut);\\n            (bool success, ) = payable(seller).call{value:amountOut}(\\\"\\\");\\n            if (!success) revert PaymentHub_TransferFailed();\\n        } else {\\n            amountOut = _swapToERC20(params);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calls the Uniswap router to swap tokens according to given path.\\n     * @param params Information about the swap (includes path).\\n     * @return amountOut The output amount of the swap to the desired token.\\n     */\\n    function _swapToERC20(ISwapRouter.ExactInputParams memory params) internal returns(uint256 amountOut) {\\n        amountOut = uniswapRouter.exactInput(params);\\n        if (amountOut < params.amountOutMinimum){\\n            revert PaymentHub_SwapError(params.amountOutMinimum, amountOut);\\n        }\\n    }\\n\\n    /**\\n     * Checks if the brokerbot has setting enabled to keep ether\\n     */\\n    function hasSettingKeepEther(IBrokerbot brokerbot) public view returns (bool) {\\n        return brokerbot.settings() & KEEP_ETHER == KEEP_ETHER;\\n    }\\n\\n    /**\\n     * @notice In case tokens have been accidentally sent directly to this contract. Only Forwarder can withdraw, else a MEV bot will intercept it.\\n     * @param ercAddress The erc20 address.\\n     * @param to The address to transfer tokens to.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function recover(IERC20 ercAddress, address to, uint256 amount) external onlyForwarder {\\n        ercAddress.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer ether to a given address. Only Forwarder can withdraw, else a MEV bot will intercept it.\\n     * @param to The address to transfer ether to.\\n     */\\n    function withdrawEther(address to, uint256 amount) external onlyForwarder {\\n        (bool success, ) = payable(to).call{value:amount}(\\\"\\\");\\n        if (!success) {\\n            revert PaymentHub_TransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer ether to a given address.\\n     * @dev Used with the mutlisigwallet.\\n     * @param to The address to transfer ether to.\\n     */\\n    function transferEther(address to) external payable {\\n        (bool success, ) = payable(to).call{value:msg.value}(\\\"\\\");\\n        if (!success) {\\n            revert PaymentHub_TransferFailed();\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {\\n        // Important to receive ETH refund from Uniswap\\n    }\\n}\\n\"\n    },\n    \"src/draggable/ERC20Draggable.sol\": {\n      \"content\": \"/**\\n * SPDX-License-Identifier: LicenseRef-Aktionariat\\n *\\n * MIT License with Automated License Fee Payments\\n *\\n * Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n *\\n * Permission is hereby granted to any person obtaining a copy of this software\\n * and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n * without restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n * Software, and to permit persons to whom the Software is furnished to do so,\\n * subject to the following conditions:\\n *\\n * - The above copyright notice and this permission notice shall be included in\\n *   all copies or substantial portions of the Software.\\n * - All automated license fee payments integrated into this and related Software\\n *   are preserved.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC-20 tokens subject to a drag-along agreement\\n * @author Luzius Meisser, luzius@aktionariat.com\\n *\\n * This is an ERC-20 token that is bound to a shareholder or other agreement that contains\\n * a drag-along clause. The smart contract can help enforce this drag-along clause in case\\n * an acquirer makes an offer using the provided functionality. If a large enough quorum of\\n * token holders agree, the remaining token holders can be automatically \\\"dragged along\\\" or\\n * squeezed out. For shares non-tokenized shares, the contract relies on an external Oracle\\n * to provide the votes of those.\\n *\\n * Subclasses should provide a link to a human-readable form of the agreement.\\n */\\n\\nimport \\\"./IDraggable.sol\\\";\\nimport \\\"../ERC20/ERC20Flaggable.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC677Receiver.sol\\\";\\nimport \\\"./IOffer.sol\\\";\\nimport \\\"./IOfferFactory.sol\\\";\\nimport \\\"../shares/IShares.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\nabstract contract ERC20Draggable is IERC677Receiver, IDraggable, ERC20Flaggable {\\n\\n\\tusing SafeERC20 for IERC20;\\n    \\n\\t// If flag is not present, one can be sure that the address did not vote. If the \\n\\t// flag is present, the address might have voted and one needs to check with the\\n\\t// current offer (if any) when transferring tokens.\\n\\tuint8 private constant FLAG_VOTE_HINT = 1;\\n\\n\\tIERC20 public override wrapped; // The wrapped contract\\n\\tIOfferFactory public immutable factory;\\n\\n\\t// If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\\n\\tuint256 public unwrapConversionFactor = 0;\\n\\n\\t// The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\\n\\tIOffer public override offer;\\n\\n\\tuint256 private constant QUORUM_MULTIPLIER = 10000;\\n\\n\\tuint256 public immutable quorumMigration; // used for contract migartion, in BPS (out of 10'000)\\n\\tuint256 public immutable quorum; // used for drag-along at acquisition offers, in BPS (out of 10'000)\\n\\tuint256 public immutable votePeriod; // In seconds\\n\\n\\taddress public override oracle;\\n\\n\\tevent MigrationSucceeded(address newContractAddress, uint256 yesVotes, uint256 oracleVotes, uint256 totalVotingPower);\\n\\tevent ChangeOracle(address oracle);\\n\\n    /**\\n\\t * Note that the Brokerbot only supports tokens that revert on failure and where transfer never returns false.\\n     */\\n\\tconstructor(\\n\\t\\tIERC20 _wrappedToken,\\n\\t\\tuint256 _quorum,\\n\\t\\tuint256 _quorumMigration,\\n\\t\\tuint256 _votePeriod,\\n\\t\\tIOfferFactory _offerFactory,\\n\\t\\taddress _oracle\\n\\t) \\n\\t\\tERC20Flaggable(0)\\n\\t{\\n\\t\\twrapped = _wrappedToken;\\n\\t\\tquorum = _quorum;\\n\\t\\tquorumMigration = _quorumMigration;\\n\\t\\tvotePeriod = _votePeriod;\\n\\t\\tfactory = _offerFactory;\\n\\t\\toracle = _oracle;\\n\\t}\\n\\n\\tmodifier onlyOracle {\\n\\t\\t_checkSender(oracle);\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyWrappedToken {\\n\\t\\t_checkSender(address(wrapped));\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyOffer(){\\n\\t\\t_checkSender(address(offer));\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier checkBinding(bool expected) {\\n\\t\\tif (expected != isBinding()) {\\n\\t\\t\\tif(expected) {\\n\\t\\t\\t\\trevert Draggable_NotBinding();\\n\\t\\t\\t}\\n\\t\\t\\tif(!expected) {\\n\\t\\t\\t\\trevert Draggable_IsBinding();\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t_;\\n\\t}\\n\\n\\tfunction onTokenTransfer(\\n\\t\\taddress from, \\n\\t\\tuint256 amount, \\n\\t\\tbytes calldata\\n\\t) external override onlyWrappedToken returns (bool) {\\n\\t\\t_mint(from, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/** Wraps additional tokens, thereby creating more ERC20Draggable tokens. */\\n\\tfunction wrap(address shareholder, uint256 amount) external {\\n\\t\\twrapped.safeTransferFrom(msg.sender, address(this), amount);\\n\\t\\t_mint(shareholder, amount);\\n\\t}\\n\\n\\t/**\\n\\t * Indicates that the token holders are bound to the token terms and that:\\n\\t * - Conversion back to the wrapped token (unwrap) is not allowed\\n\\t * - A drag-along can be performed by making an according offer\\n\\t * - They can be migrated to a new version of this contract in accordance with the terms\\n\\t */\\n\\tfunction isBinding() public view returns (bool) {\\n\\t\\treturn unwrapConversionFactor == 0;\\n\\t}\\n\\n    /**\\n\\t * Current recommended naming convention is to add the postfix \\\"SHA\\\" to the plain shares\\n\\t * in order to indicate that this token represents shares bound to a shareholder agreement.\\n\\t */\\n\\tfunction name() public view override returns (string memory) {\\n\\t\\tstring memory wrappedName = wrapped.name();\\n\\t\\tif (isBinding()) {\\n\\t\\t\\treturn string(abi.encodePacked(wrappedName, \\\" SHA\\\"));\\n\\t\\t} else {\\n\\t\\t\\treturn string(abi.encodePacked(wrappedName, \\\" (Wrapped)\\\"));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction symbol() public view override returns (string memory) {\\n\\t\\t// ticker should be less dynamic than name\\n\\t\\treturn string(abi.encodePacked(wrapped.symbol(), \\\"S\\\"));\\n\\t}\\n\\n\\t/**\\n\\t * Deactivates the drag-along mechanism and enables the unwrap function.\\n\\t */\\n\\tfunction _deactivate(uint256 factor) internal {\\n\\t\\tif (factor == 0) {\\n\\t\\t\\trevert Draggable_FactorZero();\\n\\t\\t}\\n\\t\\tunwrapConversionFactor = factor;\\n\\t}\\n\\n\\t/** Decrease the number of drag-along tokens. The user gets back their shares in return */\\n\\tfunction unwrap(uint256 amount) external override checkBinding(false) {\\n\\t\\t_unwrap(msg.sender, amount, unwrapConversionFactor);\\n\\t}\\n\\n\\tfunction _unwrap(address owner, uint256 amount, uint256 factor) internal {\\n\\t\\t_burn(owner, amount);\\n\\t\\twrapped.safeTransfer(owner, amount * factor);\\n\\t}\\n\\n\\t/**\\n\\t * Burns both the token itself as well as the wrapped token!\\n\\t * If you want to get out of the shareholder agreement, use unwrap after it has been\\n\\t * deactivated by a majority vote or acquisition.\\n\\t *\\n\\t * Burning only works if wrapped token supports burning. Also, the exact meaning of this\\n\\t * operation might depend on the circumstances. Burning and reussing the wrapped token\\n\\t * does not free the sender from the legal obligations of the shareholder agreement.\\n\\t */\\n\\tfunction burn(uint256 amount) external {\\n\\t\\t_burn(msg.sender, amount);\\n\\t\\tIShares(address(wrapped)).burn(isBinding() ? amount : amount * unwrapConversionFactor);\\n\\t}\\n\\n\\tfunction makeAcquisitionOffer(\\n\\t\\tbytes32 salt, \\n\\t\\tuint256 pricePerShare, \\n\\t\\tIERC20 currency\\n\\t) external payable checkBinding(true) {\\n\\t\\tIOffer newOffer = factory.create{value: msg.value}(\\n\\t\\t\\tsalt, msg.sender, pricePerShare, currency, quorum, votePeriod);\\n\\n\\t\\tif (offerExists()) {\\n\\t\\t\\toffer.makeCompetingOffer(newOffer);\\n\\t\\t}\\n\\t\\toffer = newOffer;\\n\\t}\\n\\n\\tfunction drag(address buyer, IERC20 currency) external override onlyOffer {\\n\\t\\t_unwrap(buyer, balanceOf(buyer), 1);\\n\\t\\t_replaceWrapped(currency, buyer);\\n\\t}\\n\\n\\tfunction notifyOfferEnded() external override onlyOffer {\\n\\t\\toffer = IOffer(address(0));\\n\\t}\\n\\n\\tfunction _replaceWrapped(IERC20 newWrapped, address oldWrappedDestination) internal checkBinding(true) {\\n\\t\\t// Free all old wrapped tokens we have\\n\\t\\twrapped.safeTransfer(oldWrappedDestination, wrapped.balanceOf(address(this)));\\n\\t\\t// Count the new wrapped tokens\\n\\t\\twrapped = newWrapped;\\n\\t\\tif (totalSupply() > 0) // if there are no tokens, no need to deactivate\\n\\t\\t\\t_deactivate(newWrapped.balanceOf(address(this)) / totalSupply());\\n\\t\\temit NameChanged(name(), symbol());\\n\\t}\\n\\n\\tfunction setOracle(address newOracle) external override onlyOracle {\\n\\t\\toracle = newOracle;\\n\\t\\temit ChangeOracle(oracle);\\n\\t}\\n\\n\\tfunction migrateWithExternalApproval(address successor, uint256 additionalVotes) external override onlyOracle {\\n\\t\\t// Additional votes cannot be higher than the votes not represented by these tokens.\\n\\t\\t// The assumption here is that more shareholders are bound to the shareholder agreement\\n\\t\\t// that this contract helps enforce and a vote among all parties is necessary to change\\n\\t\\t// it, with an oracle counting and reporting the votes of the others.\\n\\t\\tif (totalSupply() + additionalVotes > totalVotingTokens()) {\\n\\t\\t\\trevert Draggable_TooManyVotes(totalVotingTokens(), totalSupply() + additionalVotes);\\n\\t\\t}\\n\\t\\tmigrate(successor, additionalVotes);\\n\\t}\\n\\n\\tfunction migrate() external override {\\n\\t\\tmigrate(msg.sender, 0);\\n\\t}\\n\\n\\tfunction migrate(address successor, uint256 additionalVotes) internal {\\n\\t\\tuint256 yesVotes = additionalVotes + balanceOf(successor);\\n\\t\\tuint256 totalVotes = totalVotingTokens();\\n\\t\\tif (yesVotes > totalVotes) {\\n\\t\\t\\trevert Draggable_TooManyVotes(totalVotes, yesVotes);\\n\\t\\t}\\n\\t\\tif (offerExists()) {\\n\\t\\t\\t// if you have the quorum, you can cancel the offer first if necessary\\n\\t\\t\\trevert Draggable_OpenOffer();\\n\\t\\t}\\n\\t\\tif (yesVotes * QUORUM_MULTIPLIER < totalVotes * quorum) {\\n\\t\\t\\trevert Draggable_QuorumNotReached(totalVotes * quorum, yesVotes * QUORUM_MULTIPLIER);\\n\\t\\t}\\n\\t\\t_replaceWrapped(IERC20(successor), successor);\\n\\t\\temit MigrationSucceeded(successor, yesVotes, additionalVotes, totalVotes);\\n\\t}\\n\\n\\tfunction votingPower(address voter) external view override returns (uint256) {\\n\\t\\treturn balanceOf(voter);\\n\\t}\\n\\n\\tfunction totalVotingTokens() public view override returns (uint256) {\\n\\t\\treturn IShares(address(wrapped)).totalShares();\\n\\t}\\n\\n\\tfunction hasVoted(address voter) internal view returns (bool) {\\n\\t\\treturn hasFlagInternal(voter, FLAG_VOTE_HINT);\\n\\t}\\n\\n\\tfunction notifyVoted(address voter) external override onlyOffer {\\n\\t\\tsetFlag(voter, FLAG_VOTE_HINT, true);\\n\\t}\\n\\n\\tfunction _beforeTokenTransfer(address from, address to,\\tuint256 amount) internal virtual override {\\n\\t\\tif (hasVoted(from) || hasVoted(to)) {\\n\\t\\t\\tif (offerExists()) {\\n\\t\\t\\t\\toffer.notifyMoved(from, to, amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsetFlag(from, FLAG_VOTE_HINT, false);\\n\\t\\t\\t\\tsetFlag(to, FLAG_VOTE_HINT, false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsuper._beforeTokenTransfer(from, to, amount);\\n\\t}\\n\\n\\tfunction offerExists() internal view returns (bool) {\\n\\t\\treturn address(offer) != address(0);\\n\\t}\\n}\\n\"\n    },\n    \"src/draggable/IDraggable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"./IOffer.sol\\\";\\ninterface IDraggable is IERC20 {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n    //////////////////////////////////////////////////////////////*/\\n    /// conversion factor has to be > 0 for this transaction.\\n    error Draggable_NotBinding();\\n    /// conversion factor has to be = 0 for this transaction.\\n    error Draggable_IsBinding();\\n    /// conversion factor can't be 0 if binding gets deactivated.\\n    error Draggable_FactorZero();\\n    /// the reported votes can't be > max voting tokens.\\n    /// @param maxVotes The max voting tokens.\\n    /// @param reportedVotes The actual reported votes.\\n    error Draggable_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\\n    /// there is still an open offer that has to be canceled first\\n    error Draggable_OpenOffer();\\n    /// For migration the quorum needs to be reached.\\n    /// @param needed The needed quorum.\\n    /// @param actual The current yes votes.\\n    error Draggable_QuorumNotReached(uint256 needed, uint256 actual);\\n    \\n    function wrapped() external view returns (IERC20);\\n    function unwrap(uint256 amount) external;\\n    function offer() external view returns (IOffer);\\n    function oracle() external view returns (address);\\n    function drag(address buyer, IERC20 currency) external;\\n    function notifyOfferEnded() external;\\n    function votingPower(address voter) external returns (uint256);\\n    function totalVotingTokens() external view returns (uint256);\\n    function notifyVoted(address voter) external;\\n    function migrate() external;\\n    function setOracle(address newOracle) external;\\n    function migrateWithExternalApproval(address successor, uint256 additionalVotes) external;\\n    function setTerms(string calldata _terms) external;\\n\\n\\n}\\n\"\n    },\n    \"src/draggable/IOffer.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IOffer {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n  //////////////////////////////////////////////////////////////*/\\n\\t/// Invalid msg.sender.\\n\\t/// @param sender The msg.sender of the transaction.\\n\\terror Offer_InvalidSender(address sender);\\n\\t/// Offer needs to be still open.\\n\\terror Offer_AlreadyAccepted();\\n\\t/// Offer needs to be not accepted yet.\\n\\terror Offer_NotAccepted();\\n\\t/// Sender of the offer needs to have needed funds in his account.\\n\\terror Offer_NotWellFunded();\\n\\t/// New offer not valid. `newPrice` needs to be higher than `oldPrice`.\\n\\t/// @param oldPrice Price of the old offer.\\n\\t/// @param newPrice Price of the new offer.\\n\\terror Offer_OldOfferBetter(uint256 oldPrice, uint256 newPrice);\\n\\t/// Voting needs to be still open.\\n\\terror Offer_VotingEnded();\\n\\t/// Too many (External) reported votes. `reportedVotes` needs to be less or equal to `maxVotes`.\\n\\t/// @param maxVotes The max possible votes for the token.\\n\\t/// @param reportedVotes The external reported votes + circulating supply of the token.\\n\\terror Offer_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\\n\\t/// Competing offer needs to be in the same currency.\\n\\terror Offer_OfferInWrongCurrency();\\n\\n\\tfunction makeCompetingOffer(IOffer newOffer) external;\\n\\n\\t// if there is a token transfer while an offer is open, the votes get transfered too\\n\\tfunction notifyMoved(address from, address to, uint256 value) external;\\n\\n\\tfunction currency() external view returns (IERC20);\\n\\n\\tfunction price() external view returns (uint256);\\n\\n\\tfunction isWellFunded() external view returns (bool);\\n\\n\\tfunction voteYes() external;\\n\\n\\tfunction voteNo() external;\\n}\"\n    },\n    \"src/draggable/IOfferFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"./IOffer.sol\\\";\\n\\ninterface IOfferFactory {\\n\\n\\tfunction create(\\n\\t\\tbytes32 salt, address buyer, uint256 pricePerShare,\\tIERC20 currency,\\tuint256 quorum,\\tuint256 votePeriod\\n\\t) external payable returns (IOffer);\\n}\"\n    },\n    \"src/draggable/Offer.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"./IDraggable.sol\\\";\\nimport \\\"./IOffer.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n/**\\n * @title A public offer to acquire all tokens\\n * @author Luzius Meisser, luzius@aktionariat.com\\n */\\n\\ncontract Offer is IOffer {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address private constant LICENSE_FEE_ADDRESS = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D;\\n\\n    uint256 private constant AQUISITION_GRACE_PERIOD = 30 days;     // buyer has thirty days to complete acquisition after voting ends\\n    \\n    uint256 private constant BPS_MUL = 10000;           // basis point multiplier to be used with quorum\\n\\n    uint256 public immutable quorum;                    // Percentage of votes needed to start drag-along process in BPS, i.e. 10'000 = 100%\\n\\n    IDraggable public immutable token;\\n    address public immutable buyer;                     // who made the offer\\n    \\n    IERC20 override public immutable currency;\\n    uint256 override public immutable price;            // the price offered per share\\n\\n    enum Vote { NONE, YES, NO }                         // Used internally, represents not voted yet or yes/no vote.\\n    mapping (address => Vote) private votes;            // Who votes what\\n    uint256 public yesVotes;                            // total number of yes votes, including external votes\\n    uint256 public noVotes;                             // total number of no votes, including external votes\\n    uint256 public noExternal;                          // number of external no votes reported by oracle\\n    uint256 public yesExternal;                         // number of external yes votes reported by oracle\\n\\n    uint256 public immutable voteEnd;                   // end of vote period in block time (seconds after 1.1.1970)\\n\\n    event VotesChanged(uint256 yesVotes, uint256 noVotes);\\n    event OfferCreated(address indexed buyer, IDraggable indexed token, uint256 pricePerShare, IERC20 indexed currency);\\n    event OfferEnded(address indexed buyer, bool success, string message); // not sure if it makes sense to index success here\\n\\n    // Not checked here, but buyer should make sure it is well funded from the beginning\\n    constructor(\\n        address _buyer,\\n        IDraggable _token,\\n        uint256 _price,\\n        IERC20 _currency,\\n        uint256 _quorum,\\n        uint256 _votePeriod\\n    ) \\n        payable \\n    {\\n        buyer = _buyer;\\n        token = _token;\\n        currency = _currency;\\n        price = _price;\\n        quorum = _quorum;\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        voteEnd = block.timestamp + _votePeriod;\\n        emit OfferCreated(_buyer, _token, _price, _currency);\\n        // License Fee to Aktionariat AG, also ensures that offer is serious.\\n        // Any circumvention of this license fee payment is a violation of the copyright terms.\\n        payable(LICENSE_FEE_ADDRESS).transfer(3 ether);\\n    }\\n\\n    modifier onlyBuyer {\\n        _checkSender(buyer);\\n        _;\\n    }\\n\\n    modifier onlyToken {\\n        _checkSender(address(token));\\n        _;\\n    }\\n\\n    modifier onlyOracle {\\n        _checkSender(token.oracle());\\n        _;\\n    }\\n\\n    modifier votingOpen {\\n        if (!isVotingOpen()) {\\n            revert Offer_VotingEnded();\\n        }\\n        _;\\n    }\\n\\n    function makeCompetingOffer(IOffer betterOffer) external override onlyToken {\\n        if (isAccepted()) {\\n            revert Offer_AlreadyAccepted();\\n        }\\n        uint256 newPrice = betterOffer.price();\\n        if (newPrice <= price) {\\n            revert Offer_OldOfferBetter(price, newPrice);\\n        }\\n        if (currency != betterOffer.currency()) {\\n            revert Offer_OfferInWrongCurrency();\\n        }\\n        if (!betterOffer.isWellFunded()) {\\n            revert Offer_NotWellFunded();\\n        }\\n        kill(false, \\\"replaced\\\");\\n    }\\n\\n    function hasExpired() internal view returns (bool) {\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        return block.timestamp > voteEnd + AQUISITION_GRACE_PERIOD; \\n    }\\n\\n    function contest() external {\\n        if (hasExpired()) {\\n            kill(false, \\\"expired\\\");\\n        } else if (isDeclined()) {\\n            kill(false, \\\"declined\\\");\\n        } else if (!isWellFunded()) {\\n            kill(false, \\\"lack of funds\\\");\\n        }\\n    }\\n\\n    function cancel() external onlyBuyer {\\n        kill(false, \\\"cancelled\\\");\\n    }\\n\\n    function execute() external onlyBuyer {\\n        if (!isAccepted()) {\\n            revert Offer_NotAccepted();\\n        }\\n        uint256 totalPrice = getTotalPrice();\\n        currency.safeTransferFrom(buyer, address(token), totalPrice);\\n        token.drag(buyer, currency);\\n        kill(true, \\\"success\\\");\\n    }\\n\\n    function getTotalPrice() internal view returns (uint256) {\\n        IERC20 tok = IERC20(address(token));\\n        return (tok.totalSupply() - tok.balanceOf(buyer)) * price;\\n    }\\n\\n    function isWellFunded() public view override returns (bool) {\\n        uint256 buyerBalance = currency.balanceOf(buyer);\\n        uint256 totalPrice = getTotalPrice();\\n        return totalPrice <= buyerBalance;\\n    }\\n\\n    function isAccepted() public view returns (bool) {\\n        if (isVotingOpen()) {\\n            // is it already clear that more than the quorum requiered will vote yes even though the vote is not over yet?\\n            return yesVotes * BPS_MUL  >= quorum * token.totalVotingTokens();\\n        } else {\\n            // did more than the quorum requiered votes say 'yes'?\\n            return yesVotes * BPS_MUL >= quorum * (yesVotes + noVotes);\\n        }\\n    }\\n\\n    function isDeclined() public view returns (bool) {\\n        if (isVotingOpen()) {\\n            // is it already clear that 25% will vote no even though the vote is not over yet?\\n            uint256 supply = token.totalVotingTokens();\\n            return (supply - noVotes) * BPS_MUL < quorum * supply;\\n        } else {\\n            // did quorum% of all cast votes say 'no'?\\n            return BPS_MUL * yesVotes < quorum * (yesVotes + noVotes);\\n        }\\n    }\\n\\n    function notifyMoved(address from, address to, uint256 value) external override onlyToken {\\n        if (isVotingOpen()) {\\n            Vote fromVoting = votes[from];\\n            Vote toVoting = votes[to];\\n            update(fromVoting, toVoting, value);\\n        }\\n    }\\n\\n    function update(Vote previousVote, Vote newVote, uint256 votes_) internal {\\n        if (previousVote != newVote) {\\n            if (previousVote == Vote.NO) {\\n                noVotes -= votes_;\\n            } else if (previousVote == Vote.YES) {\\n                yesVotes -= votes_;\\n            }\\n            if (newVote == Vote.NO) {\\n                noVotes += votes_;\\n            } else if (newVote == Vote.YES) {\\n                yesVotes += votes_;\\n            }\\n            emit VotesChanged(yesVotes, noVotes);\\n        }\\n    }\\n\\n    function isVotingOpen() public view returns (bool) {\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        return block.timestamp <= voteEnd;\\n    }\\n\\n    /**\\n     * Function to allow the oracle to report the votes of external votes (e.g. shares tokenized on other blockchains).\\n     * This functions is idempotent and sets the number of external yes and no votes. So when more votes come in, the\\n     * oracle should always report the total number of yes and no votes. Abstentions are not counted.\\n     */\\n    function reportExternalVotes(uint256 yes, uint256 no) external onlyOracle votingOpen {\\n        uint256 maxVotes = token.totalVotingTokens();\\n        uint256 reportingVotes = yes + no + IERC20(address(token)).totalSupply();\\n        if (reportingVotes > maxVotes) {\\n            revert Offer_TooManyVotes(maxVotes, reportingVotes);\\n        }\\n        // adjust total votes taking into account that the oralce might have reported different counts before\\n        yesVotes = yesVotes - yesExternal + yes;\\n        noVotes = noVotes - noExternal + no;\\n        // remember how the oracle voted in case the oracle later reports updated numbers\\n        yesExternal = yes;\\n        noExternal = no;\\n    }\\n\\n    function voteYes() external override{\\n        vote(Vote.YES);\\n    }\\n\\n    function voteNo() external override{ \\n        vote(Vote.NO);\\n    }\\n\\n    function vote(Vote newVote) internal votingOpen {\\n        Vote previousVote = votes[msg.sender];\\n        votes[msg.sender] = newVote;\\n        if(previousVote == Vote.NONE){\\n            token.notifyVoted(msg.sender);\\n        }\\n        update(previousVote, newVote, token.votingPower(msg.sender));\\n    }\\n\\n    function hasVotedYes(address voter) external view returns (bool) {\\n        return votes[voter] == Vote.YES;\\n    }\\n\\n    function hasVotedNo(address voter) external view returns (bool) {\\n        return votes[voter] == Vote.NO;\\n    }\\n\\n    function kill(bool success, string memory message) internal {\\n        emit OfferEnded(buyer, success, message);\\n        token.notifyOfferEnded();\\n        selfdestruct(payable(buyer));\\n    }\\n\\n    /**\\n     * Checks if msg.sender is an authorized address.\\n     * @param validSender The authorized address.\\n     */\\n    function _checkSender(address validSender) internal view {\\n        if (msg.sender != validSender) {\\n            revert Offer_InvalidSender(msg.sender);\\n        }\\n    }\\n\\n}\"\n    },\n    \"src/draggable/OfferFactory.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Offer.sol\\\";\\nimport \\\"./IOffer.sol\\\";\\nimport \\\"./IOfferFactory.sol\\\";\\n\\ncontract OfferFactory is IOfferFactory{\\n\\n    // It must be possible to predict the address of the offer so one can pre-fund the allowance.\\n    function predictOfferAddress(bytes32 salt, address buyer, IDraggable token, uint256 pricePerShare, IERC20 currency, uint256 quorum, uint256 votePeriod) external view returns (address) {\\n        bytes32 initCodeHash = keccak256(abi.encodePacked(type(Offer).creationCode, abi.encode(buyer, token, pricePerShare, currency, quorum, votePeriod)));\\n        bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash));\\n        return address(uint160(uint256(hashResult)));\\n    }\\n\\n    // Do not call directly, msg.sender must be the token to be acquired\\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, IERC20 currency, uint256 quorum, uint256 votePeriod) override external payable returns (IOffer) {\\n        IOffer offer = new Offer{value: msg.value, salt: salt}(buyer, IDraggable(msg.sender), pricePerShare, currency, quorum, votePeriod);\\n        return offer;\\n    }\\n}\"\n    },\n    \"src/ERC20/ERC20Allowlistable.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"./ERC20Flaggable.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * A very flexible and efficient form to subject ERC-20 tokens to an allowlisting.\\n * See ../../doc/allowlist.md for more information.\\n */\\nabstract contract ERC20Allowlistable is ERC20Flaggable, Ownable {\\n\\n  uint8 private constant TYPE_DEFAULT = 0x0;\\n  uint8 private constant TYPE_ALLOWLISTED = 0x1;\\n  uint8 private constant TYPE_FORBIDDEN = 0x2;\\n  uint8 private constant TYPE_POWERLISTED = 0x4;\\n  // I think TYPE_POWERLISTED should have been 0x3. :) But MOP was deployed like this so we keep it. Does not hurt.\\n\\n  uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\\n  uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\\n  uint8 private constant FLAG_INDEX_POWERLIST = 22;\\n\\n  event AddressTypeUpdate(address indexed account, uint8 addressType);\\n\\n  /// Receiver has flag forbidden.\\n  /// @param receiver the address of the forbidden receiver.\\n  error Allowlist_ReceiverIsForbidden(address receiver);\\n  /// Sender has flag forbidden.\\n  /// @param sender the address of the forbidden sender.\\n  error Allowlist_SenderIsForbidden(address sender);\\n  /// Receiver has no allowlist flag.\\n  /// @param receiver the address which isn't allowlisted.\\n  error Allowlist_ReceiverNotAllowlisted(address receiver);\\n\\n  bool public restrictTransfers;\\n\\n  constructor(){\\n    setApplicableInternal(true);\\n  }\\n\\n  /**\\n   * Configures whether the allowlisting is applied.\\n   * Also sets the powerlist and allowlist flags on the null address accordingly.\\n   * It is recommended to also deactivate the powerlist flag on other addresses.\\n   */\\n  function setApplicable(bool transferRestrictionsApplicable) external onlyOwner {\\n    setApplicableInternal(transferRestrictionsApplicable);\\n  }\\n\\n  function setApplicableInternal(bool transferRestrictionsApplicable) internal {\\n    restrictTransfers = transferRestrictionsApplicable;\\n    // if transfer restrictions are applied, we guess that should also be the case for newly minted tokens\\n    // if the admin disagrees, it is still possible to change the type of the null address\\n    if (transferRestrictionsApplicable){\\n      setTypeInternal(address(0x0), TYPE_POWERLISTED);\\n    } else {\\n      setTypeInternal(address(0x0), TYPE_DEFAULT);\\n    }\\n  }\\n\\n  function setType(address account, uint8 typeNumber) public onlyOwner {\\n    setTypeInternal(account, typeNumber);\\n  }\\n\\n  /**\\n   * If TYPE_DEFAULT all flags are set to 0\\n   */\\n  function setTypeInternal(address account, uint8 typeNumber) internal {\\n    setFlag(account, FLAG_INDEX_ALLOWLIST, typeNumber == TYPE_ALLOWLISTED);\\n    setFlag(account, FLAG_INDEX_FORBIDDEN, typeNumber == TYPE_FORBIDDEN);\\n    setFlag(account, FLAG_INDEX_POWERLIST, typeNumber == TYPE_POWERLISTED);\\n    emit AddressTypeUpdate(account, typeNumber);\\n  }\\n\\n  function setType(address[] calldata addressesToAdd, uint8 value) public onlyOwner {\\n    for (uint i=0; i<addressesToAdd.length; i++){\\n      setType(addressesToAdd[i], value);\\n    }\\n  }\\n\\n  /**\\n   * If true, this address is allowlisted and can only transfer tokens to other allowlisted addresses.\\n   */\\n  function canReceiveFromAnyone(address account) public view returns (bool) {\\n    return hasFlagInternal(account, FLAG_INDEX_ALLOWLIST) || hasFlagInternal(account, FLAG_INDEX_POWERLIST);\\n  }\\n\\n  /**\\n   * If true, this address can only transfer tokens to allowlisted addresses and not receive from anyone.\\n   */\\n  function isForbidden(address account) public view returns (bool){\\n    return hasFlagInternal(account, FLAG_INDEX_FORBIDDEN);\\n  }\\n\\n  /**\\n   * If true, this address can automatically allowlist target addresses if necessary.\\n   */\\n  function isPowerlisted(address account) public view returns (bool) {\\n    return hasFlagInternal(account, FLAG_INDEX_POWERLIST);\\n  }\\n\\n  function _beforeTokenTransfer(address from, address to, uint256 amount) override virtual internal {\\n    super._beforeTokenTransfer(from, to, amount);\\n    // empty block for gas saving fall through\\n    // solhint-disable-next-line no-empty-blocks\\n    if (canReceiveFromAnyone(to)){\\n      // ok, transfers to allowlisted addresses are always allowed\\n    } else if (isForbidden(to)){\\n      // Target is forbidden, but maybe restrictions have been removed and we can clean the flag\\n      if (restrictTransfers) {\\n        revert Allowlist_ReceiverIsForbidden(to);\\n      }\\n      setFlag(to, FLAG_INDEX_FORBIDDEN, false);\\n    } else {\\n      if (isPowerlisted(from)){\\n        // it is not allowlisted, but we can make it so\\n        // we know the recipient is neither forbidden, allowlisted or powerlisted, so we can set flag directly\\n        setFlag(to, FLAG_INDEX_ALLOWLIST, true);\\n        emit AddressTypeUpdate(to, TYPE_ALLOWLISTED);\\n      }\\n      // if we made it to here, the target must be a free address and we are not powerlisted\\n      else if (hasFlagInternal(from, FLAG_INDEX_ALLOWLIST)){\\n        // We cannot send to free addresses, but maybe the restrictions have been removed and we can clean the flag?\\n        if (restrictTransfers) {\\n          revert Allowlist_ReceiverNotAllowlisted(to);\\n        }\\n        setFlag(from, FLAG_INDEX_ALLOWLIST, false);\\n      } else if (isForbidden(from)){\\n        if (restrictTransfers) {\\n          revert Allowlist_SenderIsForbidden(from);\\n        }\\n        setFlag(from, FLAG_INDEX_FORBIDDEN, false);\\n      }\\n    }\\n  }\\n\\n}\\n\"\n    },\n    \"src/ERC20/ERC20Errors.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @title Standard ERC20 Errors\\n/// @dev See https://eips.ethereum.org/EIPS/eip-20\\n///  https://eips.ethereum.org/EIPS/eip-6093\\ninterface ERC20Errors {\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n    error ERC20InvalidSender(address sender);\\n    error ERC20InvalidReceiver(address receiver);\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n    error ERC20InvalidApprover(address approver);\\n    error ERC20InvalidSpender(address spender);\\n}\"\n    },\n    \"src/ERC20/ERC20Flaggable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copied and adjusted from OpenZeppelin\\n// Adjustments:\\n// - modifications to support ERC-677\\n// - removed unnecessary require statements\\n// - removed GSN Context\\n// - upgraded to 0.8 to drop SafeMath\\n// - let name() and symbol() be implemented by subclass\\n// - infinite allowance support, with 2^255 and above considered infinite\\n// - use upper 32 bits of balance for flags\\n// - add a global settings variable\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ERC20Errors.sol\\\";\\nimport \\\"./IERC677Receiver.sol\\\";\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\n\\nabstract contract ERC20Flaggable is IERC20, ERC20Errors {\\n\\n    // as Documented in /doc/infiniteallowance.md\\n    // 0x8000000000000000000000000000000000000000000000000000000000000000\\n    uint256 constant private INFINITE_ALLOWANCE = 2**255;\\n\\n    uint256 private constant FLAGGING_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\\n\\n    // Documentation of flags used by subclasses:\\n    // NOTE: flags denote the bit number that is being used and must be smaller than 32\\n    // ERC20Draggable: uint8 private constant FLAG_INDEX_VOTED = 1;\\n    // ERC20Recoverable: uint8 private constant FLAG_INDEX_CLAIM_PRESENT = 10;\\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_POWERLIST = 22;\\n\\n    mapping (address => uint256) private _balances; // upper 32 bits reserved for flags\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    uint8 public override decimals;\\n\\n    event NameChanged(string name, string symbol);\\n\\n    /// Overflow on minting, transfer. \\n    /// @param receiver The address were the balance overflows. \\n    /// @param balance The current balance of the receiver. \\n    /// @param amount The amount added, which result in the overflow. \\n    error ERC20BalanceOverflow(address receiver, uint256 balance, uint256 amount);\\n\\n    constructor(uint8 _decimals) {\\n        decimals = _decimals;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return uint224 (_balances [account]);\\n    }\\n\\n    function hasFlag(address account, uint8 number) external view returns (bool) {\\n        return hasFlagInternal(account, number);\\n    }\\n\\n    function setFlag(address account, uint8 index, bool value) internal {\\n        uint256 flagMask = 1 << (index + 224);\\n        uint256 balance = _balances [account];\\n        if ((balance & flagMask == flagMask) != value) {\\n            _balances [account] = balance ^ flagMask;\\n        }\\n    }\\n\\n    function hasFlagInternal(address account, uint8 number) internal view returns (bool) {\\n        uint256 flag = 0x1 << (number + 224);\\n        return _balances[account] & flag == flag;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        if (currentAllowance < INFINITE_ALLOWANCE){\\n            // Only decrease the allowance if it was not set to 'infinite'\\n            // Documented in /doc/infiniteallowance.md\\n            _allowances[sender][msg.sender] = currentAllowance - amount;\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        decreaseBalance(sender, amount);\\n        increaseBalance(recipient, amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external virtual returns (bool) {\\n        return transfer (recipient, amount) \\n            && IERC677Receiver (recipient).onTokenTransfer (msg.sender, amount, data);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address recipient, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), recipient, amount);\\n        _totalSupply += amount;\\n        increaseBalance(recipient, amount);\\n        emit Transfer(address(0), recipient, amount);\\n    }\\n\\n    function increaseBalance(address recipient, uint256 amount) private {\\n        if (recipient == address(0x0)) {\\n            revert ERC20InvalidReceiver(recipient); //use burn instead\\n        }\\n        uint256 oldBalance = _balances[recipient];\\n        uint256 newBalance = oldBalance + amount;\\n        if (oldBalance & FLAGGING_MASK != newBalance & FLAGGING_MASK) {\\n            revert ERC20BalanceOverflow(recipient, oldBalance, amount);\\n        }\\n        _balances[recipient] = newBalance;\\n    }\\n\\n     /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _totalSupply -= amount;\\n        decreaseBalance(account, amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function decreaseBalance(address sender, uint256 amount) private {\\n        uint256 oldBalance = _balances[sender];\\n        uint256 newBalance = oldBalance - amount;\\n        if (oldBalance & FLAGGING_MASK != newBalance & FLAGGING_MASK) {\\n            revert ERC20InsufficientBalance(sender, balanceOf(sender), amount);\\n        }\\n        _balances[sender] = newBalance;\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n     // solhint-disable-next-line no-empty-blocks\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\\n        // intentionally left blank\\n    }\\n\\n    /**\\n     * Checks if msg.sender is an authorized address.\\n     * @param validSender The authorized address.\\n     */\\n    function _checkSender(address validSender) internal view {\\n        if (msg.sender != validSender) {\\n            revert ERC20InvalidSender(msg.sender);\\n        }\\n    }\\n\\n}\"\n    },\n    \"src/ERC20/ERC20Named.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20Flaggable.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\ncontract ERC20Named is ERC20Flaggable, Ownable {\\n\\n    string public override name;\\n    string public override symbol;\\n\\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, address _admin) ERC20Flaggable(_decimals) Ownable(_admin) {\\n        setNameInternal(_symbol, _name);\\n    }\\n\\n    function setName(string memory _symbol, string memory _name) external onlyOwner {\\n        setNameInternal(_symbol, _name);\\n    }\\n\\n    function setNameInternal(string memory _symbol, string memory _name) internal {\\n        symbol = _symbol;\\n        name = _name;\\n        emit NameChanged(_name, _symbol);\\n    }\\n\\n}\"\n    },\n    \"src/ERC20/ERC20PermitLight.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\\n// and modified it.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20Flaggable.sol\\\";\\nimport \\\"./IERC20Permit.sol\\\";\\nabstract contract ERC20PermitLight is ERC20Flaggable, IERC20Permit {\\n\\n   /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public override nonces;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public override {\\n        if (deadline < block.timestamp) {\\n            revert Permit_DeadlineExpired(deadline, block.timestamp);\\n        }\\n\\n        unchecked { // unchecked to save a little gas with the nonce increment...\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"),\\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            if (recoveredAddress == address(0) || recoveredAddress != owner) {\\n                revert Permit_InvalidSigner(recoveredAddress);\\n            }\\n            _approve(recoveredAddress, spender, value);\\n        }\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    //keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\");\\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n}\"\n    },\n    \"src/ERC20/IERC20.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\"\n    },\n    \"src/ERC20/IERC20Permit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n\\t//////////////////////////////////////////////////////////////*/\\n    /// Block timestamp must to be before deadline.\\n    /// @param deadline The deadline of the permit.\\n    /// @param blockTimestamp The timestamp of the execution block.\\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\\n    /// Recovered address must be owner and not zero address.\\n    /// @param signerAddress The recovered signer address.\\n    error Permit_InvalidSigner(address signerAddress);\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"\n    },\n    \"src/ERC20/IERC677.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\\ninterface IERC677 {\\n   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool success);\\n}\"\n    },\n    \"src/ERC20/IERC677Receiver.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\\ninterface IERC677Receiver {\\n\\n    error IERC677_OnTokenTransferFailed();\\n    \\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\\n\\n}\"\n    },\n    \"src/interfaces/kyber/IDMMExchangeRouter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @dev an simple interface for integration dApp to swap\\ninterface IDMMExchangeRouter {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n}\"\n    },\n    \"src/interfaces/kyber/IDMMFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDMMFactory {\\n    function createPool(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint32 ampBps\\n    ) external returns (address pool);\\n\\n    function setFeeConfiguration(address feeTo, uint16 governmentFeeBps) external;\\n\\n    function setFeeToSetter(address) external;\\n\\n    function getFeeConfiguration() external view returns (address feeTo, uint16 governmentFeeBps);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function allPools(uint256) external view returns (address pool);\\n\\n    function allPoolsLength() external view returns (uint256);\\n\\n    function getUnamplifiedPool(IERC20 token0, IERC20 token1) external view returns (address);\\n\\n    function getPools(IERC20 token0, IERC20 token1)\\n        external\\n        view\\n        returns (address[] memory _tokenPools);\\n\\n    function isPool(\\n        IERC20 token0,\\n        IERC20 token1,\\n        address pool\\n    ) external view returns (bool);\\n}\"\n    },\n    \"src/interfaces/kyber/IDMMLiquidityRouter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @dev an simple interface for integration dApp to contribute liquidity\\ninterface IDMMLiquidityRouter {\\n    /**\\n     * @param tokenA address of token in the pool\\n     * @param tokenB address of token in the pool\\n     * @param pool the address of the pool\\n     * @param amountADesired the amount of tokenA users want to add to the pool\\n     * @param amountBDesired the amount of tokenB users want to add to the pool\\n     * @param amountAMin bounds to the extents to which amountB/amountA can go up\\n     * @param amountBMin bounds to the extents to which amountB/amountA can go down\\n     * @param vReserveRatioBounds bounds to the extents to which vReserveB/vReserveA can go (precision: 2 ** 112)\\n     * @param to Recipient of the liquidity tokens.\\n     * @param deadline Unix timestamp after which the transaction will revert.\\n     */\\n    function addLiquidity(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        address pool,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256[2] calldata vReserveRatioBounds,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityNewPool(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        uint32 ampBps,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityNewPoolETH(\\n        IERC20 token,\\n        uint32 ampBps,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    /**\\n     * @param token address of token in the pool\\n     * @param pool the address of the pool\\n     * @param amountTokenDesired the amount of token users want to add to the pool\\n     * @dev   msg.value equals to amountEthDesired\\n     * @param amountTokenMin bounds to the extents to which WETH/token can go up\\n     * @param amountETHMin bounds to the extents to which WETH/token can go down\\n     * @param vReserveRatioBounds bounds to the extents to which vReserveB/vReserveA can go (precision: 2 ** 112)\\n     * @param to Recipient of the liquidity tokens.\\n     * @param deadline Unix timestamp after which the transaction will revert.\\n     */\\n    function addLiquidityETH(\\n        IERC20 token,\\n        address pool,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        uint256[2] calldata vReserveRatioBounds,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    /**\\n     * @param tokenA address of token in the pool\\n     * @param tokenB address of token in the pool\\n     * @param pool the address of the pool\\n     * @param liquidity the amount of lp token users want to burn\\n     * @param amountAMin the minimum token retuned after burning\\n     * @param amountBMin the minimum token retuned after burning\\n     * @param to Recipient of the returned tokens.\\n     * @param deadline Unix timestamp after which the transaction will revert.\\n     */\\n    function removeLiquidity(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    /**\\n     * @param tokenA address of token in the pool\\n     * @param tokenB address of token in the pool\\n     * @param pool the address of the pool\\n     * @param liquidity the amount of lp token users want to burn\\n     * @param amountAMin the minimum token retuned after burning\\n     * @param amountBMin the minimum token retuned after burning\\n     * @param to Recipient of the returned tokens.\\n     * @param deadline Unix timestamp after which the transaction will revert.\\n     * @param approveMax whether users permit the router spending max lp token or not.\\n     * @param r s v Signature of user to permit the router spending lp token\\n     */\\n    function removeLiquidityWithPermit(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    /**\\n     * @param token address of token in the pool\\n     * @param pool the address of the pool\\n     * @param liquidity the amount of lp token users want to burn\\n     * @param amountTokenMin the minimum token retuned after burning\\n     * @param amountETHMin the minimum eth in wei retuned after burning\\n     * @param to Recipient of the returned tokens.\\n     * @param deadline Unix timestamp after which the transaction will revert\\n     */\\n    function removeLiquidityETH(\\n        IERC20 token,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    /**\\n     * @param token address of token in the pool\\n     * @param pool the address of the pool\\n     * @param liquidity the amount of lp token users want to burn\\n     * @param amountTokenMin the minimum token retuned after burning\\n     * @param amountETHMin the minimum eth in wei retuned after burning\\n     * @param to Recipient of the returned tokens.\\n     * @param deadline Unix timestamp after which the transaction will revert\\n     * @param approveMax whether users permit the router spending max lp token\\n     * @param r s v signatures of user to permit the router spending lp token.\\n     */\\n    function removeLiquidityETHWithPermit(\\n        IERC20 token,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    /**\\n     * @param amountA amount of 1 side token added to the pool\\n     * @param reserveA current reserve of the pool\\n     * @param reserveB current reserve of the pool\\n     * @return amountB amount of the other token added to the pool\\n     */\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n}\"\n    },\n    \"src/interfaces/kyber/IDMMRouter01.sol\": {\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IDMMExchangeRouter.sol\\\";\\nimport \\\"./IDMMLiquidityRouter.sol\\\";\\n\\n/// @dev full interface for router\\ninterface IDMMRouter01 is IDMMExchangeRouter, IDMMLiquidityRouter {\\n    function factory() external pure returns (address);\\n\\n    function weth() external pure returns (IWETH);\\n}\"\n    },\n    \"src/interfaces/kyber/IDMMRouter02.sol\": {\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IDMMRouter01.sol\\\";\\n\\ninterface IDMMRouter02 is IDMMRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        IERC20 token,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        IERC20 token,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\"\n    },\n    \"src/interfaces/kyber/IWETH.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\"\n    },\n    \"src/multisig/MultiSigCloneFactory.sol\": {\n      \"content\": \"\\n/**\\n * SPDX-License-Identifier: MIT\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MultiSigWalletMaster.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\ncontract MultiSigCloneFactory {\\n\\n  address immutable public multiSigImplementation;\\n\\n  event ContractCreated(address indexed contractAddress, string indexed typeName);\\n\\n  constructor(address _multiSigImplementation) {\\n    multiSigImplementation = _multiSigImplementation;\\n  }\\n  \\n  function predict(bytes32 salt) external view returns (address) {\\n    return Clones.predictDeterministicAddress(multiSigImplementation, salt);\\n  }\\n\\n  function create(address owner, bytes32 salt) external returns (MultiSigWalletMaster) {\\n    address payable instance = payable(Clones.cloneDeterministic(multiSigImplementation, salt));\\n    MultiSigWalletMaster(instance).initialize(owner);\\n    emit ContractCreated(instance, \\\"MultiSigWallet\\\");\\n    return MultiSigWalletMaster(instance);\\n  }\\n}\"\n    },\n    \"src/multisig/MultiSigWalletMaster.sol\": {\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\nimport \\\"./RLPEncode.sol\\\";\\nimport \\\"./Nonce.sol\\\";\\n\\n/**\\n * Documented in ../../doc/multisig.md\\n * Version 4: include SentEth event\\n */\\ncontract MultiSigWalletMaster is Nonce, Initializable {\\n\\n  // Version history\\n  // Version 4: added event for send value\\n  // Version 5: added version field and changed chain id\\n  uint8 public constant VERSION = 0x5;\\n\\n  mapping (address => uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\\n\\n  uint16 public signerCount;\\n  bytes public contractId; // most likely unique id of this contract\\n\\n  event SignerChange(\\n    address indexed signer,\\n    uint8 signaturesNeeded\\n  );\\n\\n  event Transacted(\\n    address indexed toAddress,  // The address the transaction was sent to\\n    bytes4 selector, // selected operation\\n    address[] signers // Addresses of the signers used to initiate the transaction\\n  );\\n\\n  event Received(address indexed sender, uint amount);\\n  event SentEth(address indexed target, uint amount);\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n\\t//////////////////////////////////////////////////////////////*/\\n  /// Call needs to provide signature data. \\n  error Multisig_SignatureMissing();\\n  /// Sinature data isn't valid for the transaction or insufficient signer have signed the transaction. \\n  /// @param signer The ecrecover'd signer.\\n  error Multisig_InvalidSignDataOrInsufficientCosigner(address signer);\\n  /// Each signature data entry has to be from a unique address. \\n  /// @param from The address which has produced more than one signature. \\n  error Multisig_DuplicateSignature(address from);\\n  /// Signer is a contract or the 0x0 address. \\n  /// @param signer The address of the invalid signer. \\n  error Multisig_InvalidSigner(address signer);\\n  /// The multisig needs to have > 0 signers. \\n  error Multisig_InsufficientSigners();\\n  /// Sender has to be single signer or the multisig itself. \\n  /// @param sender The msg.sender of the transaction. \\n  error Multisig_UnauthorizedSender(address sender);\\n  /// Migration can't override current signer. \\n  /// param destination The address to which the signer rights should be migrated. \\n  error Multisig_InvalidDestination(address destination);\\n\\n  function initialize(address owner) external initializer {\\n    // We use the gas price field to get a unique id into our transactions.\\n    // Note that 32 bits do not guarantee that no one can generate a contract with the\\n    // same id, but it practically rules out that someone accidentally creates two\\n    // two multisig contracts with the same id, and that's all we need to prevent\\n    // replay-attacks.\\n    contractId = toBytes(uint32(uint160(address(this))));\\n    signerCount = 0;\\n    _setSigner(owner, 1); // set initial owner\\n  }\\n\\n  /**\\n   * It should be possible to store ether on this address.\\n   */\\n  receive() external payable {\\n    emit Received(msg.sender, msg.value);\\n  }\\n\\n  /**\\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\\n   */\\n  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,\\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external view returns (address[] memory) {\\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\\n    return verifySignatures(transactionHash, v, r, s);\\n  }\\n\\n  /**\\n   * Checks if the execution of a transaction would succeed if it was properly signed.\\n   */\\n  function checkExecution(address to, uint value, bytes calldata data) external {\\n    Address.functionCallWithValue(to, data, value);\\n    revert(\\\"Test passed. Reverting.\\\");\\n  }\\n\\n  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external returns (bytes memory) {\\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\\n    flagUsed(nonce);\\n    emit Transacted(to, extractSelector(data), found);\\n    if (value > 0) {emit SentEth(to, value);}\\n    return returndata;\\n  }\\n\\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\\n    if (data.length < 4){\\n      return bytes4(0);\\n    } else {\\n      return bytes4(data[0]) | (bytes4(data[1]) >> 8) | (bytes4(data[2]) >> 16) | (bytes4(data[3]) >> 24);\\n    }\\n  }\\n\\n  function toBytes (uint256 x) public pure returns (bytes memory result) {\\n    uint l = 0;\\n    uint xx = x;\\n    if (x >= 0x100000000000000000000000000000000) { x >>= 128; l += 16; }\\n    if (x >= 0x10000000000000000) { x >>= 64; l += 8; }\\n    if (x >= 0x100000000) { x >>= 32; l += 4; }\\n    if (x >= 0x10000) { x >>= 16; l += 2; }\\n    if (x >= 0x100) { x >>= 8; l += 1; }\\n    if (x > 0x0) { l += 1; }\\n    assembly {\\n      result := mload (0x40)\\n      mstore (0x40, add (result, add (l, 0x20)))\\n      mstore (add (result, l), xx)\\n      mstore (result, l)\\n    }\\n  }\\n\\n  // Note: does not work with contract creation\\n  function calculateTransactionHash(uint128 sequence, bytes memory id, address to, uint value, bytes calldata data)\\n    internal view returns (bytes32){\\n    bytes[] memory all = new bytes[](9);\\n    all[0] = toBytes(sequence); // sequence number instead of nonce\\n    all[1] = id; // contract id instead of gas price\\n    all[2] = bytes(\\\"\\\\x82\\\\x52\\\\x08\\\"); // 21000 gas limitation\\n    all[3] = abi.encodePacked (bytes1 (0x94), to);\\n    all[4] = toBytes(value);\\n    all[5] = data;\\n    all[6] = toBytes(block.chainid);\\n    all[7] = new bytes(0);\\n    for (uint i = 0; i<8; i++){\\n      if (i != 2 && i!= 3) {\\n        all[i] = RLPEncode.encodeBytes(all[i]);\\n      }\\n    }\\n    all[8] = all[7];\\n    return keccak256(RLPEncode.encodeList(all));\\n  }\\n\\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\\n    public view returns (address[] memory) {\\n    address[] memory found = new address[](r.length);\\n    if (r.length == 0 ) {\\n      revert Multisig_SignatureMissing();\\n    }\\n    for (uint i = 0; i < r.length; i++) {\\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\\n      uint8 signaturesNeeded = signers[signer];\\n      if (signaturesNeeded == 0 || signaturesNeeded > r.length) {\\n        revert Multisig_InvalidSignDataOrInsufficientCosigner(signer);\\n      }\\n      found[i] = signer;\\n    }\\n    requireNoDuplicates(found);\\n    return found;\\n  }\\n\\n  function requireNoDuplicates(address[] memory found) private pure {\\n    for (uint i = 0; i < found.length; i++) {\\n      for (uint j = i+1; j < found.length; j++) {\\n        if (found[i] == found[j]) {\\n          revert Multisig_DuplicateSignature(found[i]);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Call this method through execute\\n   */\\n  function setSigner(address signer, uint8 signaturesNeeded) external authorized {\\n    _setSigner(signer, signaturesNeeded);\\n    if (signerCount == 0) {\\n      revert Multisig_InsufficientSigners();\\n    }\\n  }\\n\\n  function migrate(address destination) external {\\n    _migrate(msg.sender, destination);\\n  }\\n\\n  function migrate(address source, address destination) external authorized {\\n    _migrate(source, destination);\\n  }\\n\\n  function _migrate(address source, address destination) private {\\n    // do not overwrite existing signer!\\n    if (signers[destination] > 0 ) {\\n      revert Multisig_InvalidDestination(destination);\\n    }\\n    _setSigner(destination, signers[source]);\\n    _setSigner(source, 0);\\n  }\\n\\n  function _setSigner(address signer, uint8 signaturesNeeded) private {\\n    if (Address.isContract(signer) || signer == address(0x0)) {\\n      revert Multisig_InvalidSigner(signer);\\n    }\\n    uint8 prevValue = signers[signer];\\n    signers[signer] = signaturesNeeded;\\n    if (prevValue > 0 && signaturesNeeded == 0){\\n      signerCount--;\\n    } else if (prevValue == 0 && signaturesNeeded > 0){\\n      signerCount++;\\n    }\\n    emit SignerChange(signer, signaturesNeeded);\\n  }\\n\\n  modifier authorized() {\\n    if (address(this) != msg.sender && signers[msg.sender] != 1) {\\n      revert Multisig_UnauthorizedSender(msg.sender);\\n    }\\n    _;\\n  }\\n\\n}\"\n    },\n    \"src/multisig/Nonce.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\ncontract Nonce {\\n\\n    uint256 public constant MAX_INCREASE = 100;\\n    \\n    uint256 private compound;\\n    \\n    constructor(){\\n        setBoth(128, 0);\\n    }\\n    \\n    /**\\n     * The next recommended nonce, which is the highest nonce ever used plus one.\\n     * The initial nonce is 129.\\n     */\\n    function nextNonce() external view returns (uint128){\\n        return getMax() + 1;\\n    }\\n\\n    /**\\n     * Returns whether the provided nonce can be used.\\n     * For the 100 nonces in the interval [nextNonce(), nextNonce + 99], this is always true.\\n     * For the nonces in the interval [nextNonce() - 129, nextNonce() - 1], this is true for the nonces that have not been used yet.\\n     */ \\n    function isFree(uint128 nonce) external view returns (bool){\\n        uint128 max = getMax();\\n        return isValidHighNonce(max, nonce) || isValidLowNonce(max, getRegister(), nonce);\\n    }\\n\\n    /**\\n     * Flags the given nonce as used.\\n     * Reverts if the provided nonce is not free.\\n     */\\n    function flagUsed(uint128 nonce) internal {\\n        uint256 comp = compound;\\n        uint128 max = uint128(comp);\\n        uint128 reg = uint128(comp >> 128);\\n        if (isValidHighNonce(max, nonce)){\\n            setBoth(nonce, ((reg << 1) | 0x1) << (nonce - max - 1));\\n        } else if (isValidLowNonce(max, reg, nonce)){\\n            setBoth(max, uint128(reg | 0x1 << (max - nonce - 1)));\\n        } else {\\n            revert(\\\"used\\\");\\n        }\\n    }\\n    \\n    function getMax() private view returns (uint128) {\\n        return uint128(compound);\\n    }\\n    \\n    function getRegister() private view returns (uint128) {\\n        return uint128(compound >> 128);\\n    }\\n    \\n    function setBoth(uint128 max, uint128 reg) private {\\n        compound = uint256(reg) << 128 | max;\\n    }\\n\\n    function isValidHighNonce(uint128 max, uint128 nonce) private pure returns (bool){\\n        return nonce > max && nonce <= max + MAX_INCREASE;\\n    }\\n\\n    function isValidLowNonce(uint128 max, uint128 reg, uint128 nonce) private pure returns (bool){\\n        uint256 diff = max - nonce;\\n        return diff > 0 && diff <= 128 && ((0x1 << (diff - 1)) & reg == 0);\\n    }\\n    \\n}\"\n    },\n    \"src/multisig/RLPEncode.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n/**\\n * @title RLPEncode\\n * @dev A simple RLP encoding library.\\n * @author Bakaoh\\n */\\nlibrary RLPEncode {\\n    /*\\n     * Internal functions\\n     */\\n\\n    /**\\n     * @dev RLP encodes a byte string.\\n     * @param self The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n        if (self.length == 1 && uint8(self[0]) < 128) {\\n            encoded = self;\\n        } else {\\n            encoded = abi.encodePacked(encodeLength(self.length, 128), self);\\n        }\\n        return encoded;\\n    }\\n\\n    /**\\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\\n     * @param self The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\\n        bytes memory list = flatten(self);\\n        return abi.encodePacked(encodeLength(list.length, 192), list);\\n    }\\n\\n    /*\\n     * Private functions\\n     */\\n\\n    /**\\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param len The length of the string or the payload.\\n     * @param offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function encodeLength(uint len, uint offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n        if (len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes32(len + offset)[31];\\n        } else {\\n            uint lenLen;\\n            uint i = 1;\\n            while (len >= i) {\\n                lenLen++;\\n                i <<= 8;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes32((len / (256**(lenLen-i))) % 256)[31];\\n            }\\n        }\\n        return encoded;\\n    }\\n\\n    /**\\n     * @dev Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function memcpy(uint _dest, uint _src, uint _len) private pure {\\n        uint dest = _dest;\\n        uint src = _src;\\n        uint len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint mask = type(uint).max >> (len << 3);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @dev Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint len;\\n        uint i;\\n        for (i = 0; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint flattenedPtr;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n            \\n            uint listPtr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += item.length;\\n        }\\n\\n        return flattened;\\n    }\\n\\n}\"\n    },\n    \"src/recovery/ERC20Recoverable.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/ERC20Flaggable.sol\\\";\\nimport \\\"./IRecoveryHub.sol\\\";\\nimport \\\"./IRecoverable.sol\\\";\\n\\n/**\\n * @title Recoverable\\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\\n * declareLost function on the recovery hub to post a deposit and claim that the shares assigned to a\\n * specific address are lost.\\n * If an attacker trying to claim shares belonging to someone else, they risk losing the deposit\\n * as it can be claimed at anytime by the rightful owner.\\n * Furthermore, if \\\"getClaimDeleter\\\" is defined in the subclass, the returned address is allowed to\\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\\n * function, e.g. cases of front-running.\\n * Most functionality is implemented in a shared RecoveryHub.\\n */\\nabstract contract ERC20Recoverable is ERC20Flaggable, IRecoverable {\\n\\n    uint8 private constant FLAG_CLAIM_PRESENT = 10;\\n\\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\\n    IERC20 public customCollateralAddress;\\n    // Rate the custom collateral currency is multiplied to be valued like one share.\\n    uint256 public customCollateralRate;\\n\\n    uint256 constant CLAIM_PERIOD = 180 days;\\n\\n    IRecoveryHub public override immutable recovery;\\n\\n    constructor(IRecoveryHub recoveryHub){\\n        recovery = recoveryHub;\\n    }\\n\\n    modifier onlyRecovery {\\n        _checkSender(address(recovery));\\n        _;\\n    }\\n\\n    /**\\n     * Returns the collateral rate for the given collateral type and 0 if that type\\n     * of collateral is not accepted. By default, only the token itself is accepted at\\n     * a rate of 1:1.\\n     *\\n     * Subclasses should override this method if they want to add additional types of\\n     * collateral.\\n     */\\n    function getCollateralRate(IERC20 collateralType) public override virtual view returns (uint256) {\\n        if (address(collateralType) == address(this)) {\\n            return 1;\\n        } else if (collateralType == customCollateralAddress) {\\n            return customCollateralRate;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function claimPeriod() external pure override returns (uint256){\\n        return CLAIM_PERIOD;\\n    }\\n\\n    /**\\n     * Allows subclasses to set a custom collateral besides the token itself.\\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\\n     * throws an exception or returns false on failure.\\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\\n     */\\n    function _setCustomClaimCollateral(IERC20 collateral, uint256 rate) internal {\\n        customCollateralAddress = collateral;\\n        if (address(customCollateralAddress) == address(0)) {\\n            customCollateralRate = 0; // disabled\\n        } else {\\n            if (rate == 0) {\\n                revert Recoverable_RateZero();\\n            }\\n            customCollateralRate = rate;\\n        }\\n    }\\n\\n    function getClaimDeleter() virtual public view returns (address);\\n\\n    function transfer(address recipient, uint256 amount) override(ERC20Flaggable, IERC20) virtual public returns (bool) {\\n        super.transfer(recipient, amount); // no need for safe transfer, as it's our own token\\n        if (hasFlagInternal(msg.sender, FLAG_CLAIM_PRESENT)){\\n            recovery.clearClaimFromToken(msg.sender);\\n        }\\n        return true;\\n    }\\n\\n    function notifyClaimMade(address target) external override onlyRecovery {\\n        setFlag(target, FLAG_CLAIM_PRESENT, true);\\n    }\\n\\n    function notifyClaimDeleted(address target) external override onlyRecovery {\\n        setFlag(target, FLAG_CLAIM_PRESENT, false);\\n    }\\n\\n    function deleteClaim(address lostAddress) external {\\n        _checkSender(getClaimDeleter());\\n        recovery.deleteClaim(lostAddress);\\n    }\\n\\n    function recover(address oldAddress, address newAddress) external override onlyRecovery {\\n        _transfer(oldAddress, newAddress, balanceOf(oldAddress));\\n    }\\n\\n}\"\n    },\n    \"src/recovery/IRecoverable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"./IRecoveryHub.sol\\\";\\n\\ninterface IRecoverable is IERC20{\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n    //////////////////////////////////////////////////////////////*/\\n    /// The new custom claim collateral rate has to be always > 0. \\n    error Recoverable_RateZero();\\n\\n    // returns the recovery hub\\n    function recovery() external view returns (IRecoveryHub);\\n\\n    function claimPeriod() external view returns (uint256);\\n    \\n    function notifyClaimMade(address target) external;\\n\\n    function notifyClaimDeleted(address target) external;\\n\\n    function getCollateralRate(IERC20 collateral) external view returns(uint256);\\n\\n    function recover(address oldAddress, address newAddress) external;\\n\\n}\"\n    },\n    \"src/recovery/IRecoveryHub.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRecoverable.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IRecoveryHub {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n    //////////////////////////////////////////////////////////////*/\\n    /// Recovery can be disabled per address.\\n    /// @param lostAddress The address for which the recovery is disabled.\\n    error RecoveryHub_RecoveryDisabled(address lostAddress);\\n    /// No valid collateral type\\n    /// @param collateralType The address of collateral type token\\n    error RecoveryHub_BadCollateral(IERC20 collateralType);\\n    /// No token to able to recover on the lost address\\n    /// @param token The token address which is checked for recovery.\\n    /// @param lostAddress The lost address.\\n    error RecoveryHub_NothingToRecover(IERC20 token, address lostAddress);\\n    /// The was already a claim for this token and address.\\n    /// @param token The token address.\\n    /// @param lostAddress The lost address.\\n    error RecoveryHub_AlreadyClaimed(IERC20 token, address lostAddress);\\n    /// Sender has to be claimant\\n    /// @param sender The msg.sender of the call\\n    error RecoveryHub_InvalidSender(address sender);\\n    /// No claim for this address exists\\n    /// @param lostAddress The checked address \\n    error RecoveryHub_ClaimNotFound(address lostAddress);\\n    /// Recover can only be called after the claim period\\n    /// @param claimPeriodEnd The timestamp when the period ends\\n    /// @param currentTimestamp The block timestamp of the call\\n    error RecoveryHub_InClaimPeriod(uint256 claimPeriodEnd, uint256 currentTimestamp);\\n\\n    function setRecoverable(bool flag) external;\\n    \\n    // deletes claim and transfers collateral back to claimer\\n    function deleteClaim(address target) external;\\n\\n    // clears claim and transfers collateral to holder\\n    function clearClaimFromToken(address holder) external;\\n\\n    function clearClaimFromUser(IRecoverable token) external;\\n\\n}\"\n    },\n    \"src/recovery/RecoveryHub.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRecoveryHub.sol\\\";\\nimport \\\"./IRecoverable.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract RecoveryHub is IRecoveryHub {\\n\\n    using SafeERC20 for IERC20;\\n\\n    // A struct that represents a claim made\\n    struct Claim {\\n        address claimant; // the person who created the claim\\n        uint256 collateral; // the amount of collateral deposited\\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\\n        IERC20 currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\\n    }\\n\\n    mapping(IRecoverable => mapping (address => Claim)) public claims; // there can be at most one claim per token and claimed address\\n    mapping(address => bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\\n\\n    event ClaimMade(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 balance);\\n    event ClaimCleared(IRecoverable indexed token, address indexed lostAddress, uint256 collateral);\\n    event ClaimDeleted(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\\n    event ClaimResolved(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\\n\\n    function setRecoverable(bool enabled) external override {\\n        recoveryDisabled[msg.sender] = !enabled;\\n    }\\n\\n    /**\\n     * Some users might want to disable claims for their address completely.\\n     * For example if they use a deep cold storage solution or paper wallet.\\n     */\\n    function isRecoverable(address target) public view returns (bool) {\\n        return !recoveryDisabled[target];\\n    }\\n\\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\\n    * 2) The \\\"lost\\\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\\n    *    whenever someone transfers funds to let claims be resolved automatically when the \\\"lost\\\" private key is\\n    *    used again.\\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\\n    *    rightful owner of the deposit.\\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\\n    * through a shareholder register).\\n    */\\n    function declareLost(IRecoverable token, IERC20 collateralType, address lostAddress) external {\\n        if(recoveryDisabled[lostAddress]) {\\n            revert RecoveryHub_RecoveryDisabled(lostAddress);\\n        }\\n        uint256 collateralRate = IRecoverable(token).getCollateralRate(collateralType);\\n        if (collateralRate == 0) {\\n            // if the there is no rate the collateral isn't accepted\\n            revert RecoveryHub_BadCollateral(collateralType);\\n        }\\n        uint256 balance = IERC20(token).balanceOf(lostAddress);\\n        if (balance == 0) {\\n            // if lost address has no balance, there also nothing to recover\\n            revert RecoveryHub_NothingToRecover(token, lostAddress);\\n        }\\n        uint256 collateral = balance * collateralRate;\\n        IERC20 currency = IERC20(collateralType);\\n        if (claims[token][lostAddress].collateral > 0) {\\n            revert RecoveryHub_AlreadyClaimed(token, lostAddress);\\n        }\\n\\n        claims[token][lostAddress] = Claim({\\n            claimant: msg.sender,\\n            collateral: collateral,\\n            // rely on time stamp is ok, no exact time stamp needed\\n            // solhint-disable-next-line not-rely-on-time\\n            timestamp: block.timestamp,\\n            currencyUsed: collateralType\\n        });\\n        emit ClaimMade(token, lostAddress, msg.sender, balance);\\n        // errors like no allowance/no balance revert generally in the transferFrom\\n        currency.safeTransferFrom(msg.sender, address(this), collateral);\\n        IRecoverable(token).notifyClaimMade(lostAddress);\\n    }\\n\\n    function getClaimant(IRecoverable token, address lostAddress) external view returns (address) {\\n        return claims[token][lostAddress].claimant;\\n    }\\n\\n    function getCollateral(IRecoverable token, address lostAddress) external view returns (uint256) {\\n        return claims[token][lostAddress].collateral;\\n    }\\n\\n    function getCollateralType(IRecoverable token, address lostAddress) external view returns (IERC20) {\\n        return claims[token][lostAddress].currencyUsed;\\n    }\\n\\n    function getTimeStamp(IRecoverable token, address lostAddress) external view returns (uint256) {\\n        return claims[token][lostAddress].timestamp;\\n    }\\n\\n    /**\\n     * Clears a claim after the key has been found again and assigns the collateral to the \\\"lost\\\" address.\\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\\n     */\\n    function clearClaimFromToken(address holder) external override {\\n        clearClaim(IRecoverable(msg.sender), holder);\\n    }\\n\\n    function clearClaimFromUser(IRecoverable token) external override {\\n        clearClaim(token, msg.sender);\\n    }\\n\\n    function clearClaim(IRecoverable token, address holder) private {\\n        Claim memory claim = claims[token][holder];\\n        if (claim.collateral > 0){\\n            IERC20 currency = IERC20(claim.currencyUsed);\\n            delete claims[token][holder];\\n            currency.safeTransfer(holder, claim.collateral);\\n            emit ClaimCleared(token, holder, claim.collateral);\\n        }\\n        IRecoverable(token).notifyClaimDeleted(holder);\\n    }\\n\\n   /**\\n    * After the claim period has passed, the claimant can call this function to send the\\n    * tokens on the lost address as well as the collateral to himself.\\n    */\\n    function recover(IRecoverable token, address lostAddress) external {\\n        Claim memory claim = claims[token][lostAddress];\\n        uint256 collateral = claim.collateral;\\n        if (collateral == 0) {\\n            revert RecoveryHub_ClaimNotFound(lostAddress);\\n        }\\n        address claimant = claim.claimant;\\n        if (claimant != msg.sender) {\\n            revert RecoveryHub_InvalidSender(msg.sender);\\n        }\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        uint256 claimPeriodEnd = claim.timestamp + IRecoverable(token).claimPeriod();\\n        if (claimPeriodEnd > block.timestamp) {\\n            revert RecoveryHub_InClaimPeriod(claimPeriodEnd, block.timestamp);\\n        }\\n        delete claims[token][lostAddress];\\n        emit ClaimResolved(token, lostAddress, claimant, collateral);\\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\\n        IERC20 currency = IERC20(claim.currencyUsed);\\n        currency.safeTransfer(claimant, collateral);\\n        IRecoverable(token).recover(lostAddress, claimant);\\n    }\\n\\n    /**\\n     * The token contract can delete claims. It is the responsibility of the token contract to make sure\\n     * only authorized parties can trigger such a call.\\n     */\\n    function deleteClaim(address lostAddress) external override {\\n        IRecoverable token = IRecoverable(msg.sender);\\n        Claim memory claim = claims[token][lostAddress];\\n        IERC20 currency = IERC20(claim.currencyUsed);\\n        if (claim.collateral == 0) {\\n            revert RecoveryHub_ClaimNotFound(lostAddress);\\n        }\\n        delete claims[token][lostAddress];\\n        emit ClaimDeleted(token, lostAddress, claim.claimant, claim.collateral);\\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\\n        currency.safeTransfer(claim.claimant, claim.collateral);\\n    }\\n\\n}\"\n    },\n    \"src/shares/AllowlistDraggableShares.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/ERC20Allowlistable.sol\\\";\\nimport \\\"./DraggableShares.sol\\\";\\n\\ncontract AllowlistDraggableShares is ERC20Allowlistable, DraggableShares {\\n\\n  constructor(\\n    string memory _terms,\\n    IERC20 _wrappedToken,\\n    uint256 _quorum,\\n    uint256 _quorumMigration,\\n    uint256 _votePeriod,\\n    IRecoveryHub _recoveryHub,\\n    IOfferFactory _offerFactory,\\n    address _oracle,\\n    address _owner\\n  )\\n    DraggableShares(_terms, _wrappedToken, _quorum, _quorumMigration, _votePeriod, _recoveryHub, _offerFactory, _oracle)\\n    Ownable(_owner)\\n  {\\n    // initialization is done in ERC20Allowlistbale and DraggableShares\\n  }\\n\\n  function transfer(address to, uint256 value) virtual override(ERC20Flaggable, DraggableShares) public returns (bool) {\\n      return super.transfer(to, value);\\n  }\\n  \\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Allowlistable, DraggableShares) internal {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n\\n}\"\n    },\n    \"src/shares/AllowlistShares.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../recovery/ERC20Recoverable.sol\\\";\\nimport \\\"../ERC20/ERC20Allowlistable.sol\\\";\\nimport \\\"./Shares.sol\\\";\\n\\ncontract AllowlistShares is Shares, ERC20Allowlistable {\\n\\n  constructor(\\n    string memory _symbol,\\n    string memory _name,\\n    string memory _terms,\\n    uint256 _totalShares,\\n    IRecoveryHub _recoveryHub,\\n    address _owner\\n  )\\n    Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub)\\n    ERC20Allowlistable()\\n  {\\n    // initialization in shares\\n  }\\n\\n  function transfer(address recipient, uint256 amount) override(ERC20Flaggable, Shares) virtual public returns (bool) {\\n    return super.transfer(recipient, amount); \\n  }\\n\\n  function _mint(address account, uint256 amount) internal override(ERC20Flaggable, Shares) {\\n      super._mint(account, amount);\\n  }\\n\\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Allowlistable) internal {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n\\n}\"\n    },\n    \"src/shares/DraggableShares.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../recovery/ERC20Recoverable.sol\\\";\\nimport \\\"../draggable/ERC20Draggable.sol\\\";\\nimport \\\"../ERC20/ERC20PermitLight.sol\\\";\\n\\n/**\\n * @title CompanyName AG Shares SHA\\n * @author Luzius Meisser, luzius@aktionariat.com\\n *\\n * This is an ERC-20 token representing share tokens of CompanyName AG that are bound to\\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\\n */\\ncontract DraggableShares is ERC20Draggable, ERC20Recoverable, ERC20PermitLight {\\n\\n    string public terms;\\n\\n    /// Event when the terms are changed with setTerms().\\n    event ChangeTerms(string terms); \\n\\n    constructor(\\n        string memory _terms,\\n        IERC20 _wrappedToken,\\n        uint256 _quorumBps,\\n        uint256 _quorumMigration,\\n        uint256 _votePeriodSeconds,\\n        IRecoveryHub _recoveryHub,\\n        IOfferFactory _offerFactory,\\n        address _oracle\\n    )\\n        ERC20Draggable(_wrappedToken, _quorumBps, _quorumMigration, _votePeriodSeconds, _offerFactory, _oracle)\\n        ERC20Recoverable(_recoveryHub)\\n        ERC20PermitLight() \\n    {\\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\\n        _recoveryHub.setRecoverable(false);\\n    }\\n\\n    function transfer(address to, uint256 value) virtual override(IERC20, ERC20Flaggable, ERC20Recoverable) public returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    /**\\n     * Let the oracle act as deleter of invalid claims. In earlier versions, this was referring to the claim deleter\\n     * of the wrapped token. But that stops working after a successful acquisition as the acquisition currency most\\n     * likely does not have a claim deleter.\\n     */\\n    function getClaimDeleter() public view override returns (address) {\\n        return oracle;\\n    }\\n\\n    function getCollateralRate(IERC20 collateralType) public view override returns (uint256) {\\n        uint256 rate = super.getCollateralRate(collateralType);\\n        if (rate > 0) {\\n            return rate;\\n        } else {\\n            // as long as it is binding, the conversion rate is 1:1\\n            uint256 factor = isBinding() ? 1 : unwrapConversionFactor;\\n            if (address(collateralType) == address(wrapped)) {\\n                // allow wrapped token as collateral\\n                return factor;\\n            } else {\\n                // If the wrapped contract allows for a specific collateral, we should too.\\n                // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\\n                return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * factor;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function allows the oracle to set the terms.\\n     * @param _terms The new terms.\\n     */\\n    function setTerms(string calldata _terms) external override onlyOracle {\\n        terms = _terms;\\n        emit ChangeTerms(terms);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Draggable) internal {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n}\"\n    },\n    \"src/shares/DraggableSharesWithPredecessor.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./DraggableShares.sol\\\";\\n/** \\n *  \\n * @dev Use this contract if you need to migrate the predecessor tokens with the majority of shares onchain.\\n */\\ncontract DraggableSharesWithPredecessor is DraggableShares {\\n  IDraggable immutable predecessor;\\n\\n\\n  constructor(\\n    IDraggable _predecessor,\\n    string memory _terms,\\n    IERC20 _wrappedToken,\\n    uint256 _quorumBps,\\n    uint256 _quorumMigration,\\n    uint256 _votePeriodSeconds,\\n    IRecoveryHub _recoveryHub,\\n    IOfferFactory _offerFactory,\\n    address _oracle\\n  )\\n    DraggableShares(_terms, _wrappedToken, _quorumBps, _quorumMigration, _votePeriodSeconds, _recoveryHub, _offerFactory, _oracle)\\n  {\\n    predecessor = _predecessor;\\n  }\\n  \\n  /**\\n   * @notice This contract needs to hold the majority of the predecessor tokens.\\n   */\\n  function initiateMigration() external {\\n    uint256 predecessorSupply = predecessor.totalSupply();\\n    _mint(address(predecessor), predecessorSupply);\\n    wrapped = predecessor.wrapped();\\n    predecessor.migrate();\\n    uint256 predecessorBalance = predecessor.balanceOf(address(this));\\n    predecessor.unwrap(predecessorBalance);\\n    _burn(address(this), predecessorBalance);\\n    assert(predecessorSupply == totalSupply());\\n  }\\n}\"\n    },\n    \"src/shares/DraggableSharesWithPredecessorExternal.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./DraggableShares.sol\\\";\\n/** \\n *  \\n * @dev Use this contract if you need to migrate the predecessor tokens with additional external votes.\\n */\\ncontract DraggableSharesWithPredecessorExternal is DraggableShares {\\n  IDraggable immutable predecessor;\\n\\n\\n  constructor(\\n    IDraggable _predecessor,\\n    string memory _terms,\\n    IERC20 _wrappedToken,\\n    uint256 _quorumBps,\\n    uint256 _quorumMigration,\\n    uint256 _votePeriodSeconds,\\n    IRecoveryHub _recoveryHub,\\n    IOfferFactory _offerFactory,\\n    address _oracle\\n  )\\n    DraggableShares(_terms, _wrappedToken, _quorumBps, _quorumMigration, _votePeriodSeconds, _recoveryHub, _offerFactory, _oracle)\\n  {\\n    predecessor = _predecessor;\\n  }\\n\\n  /**\\n   * @notice This contract needs to hold the majority of the predecessor tokens and the this contract needs to be the oracle of the predecessor.\\n   * \\n   */\\n  function initiateMigrationWithExternalApproval(uint256 additionalVotes) external onlyOracle {\\n    uint256 predecessorSupply = predecessor.totalSupply();\\n    _mint(address(predecessor), predecessorSupply);\\n    wrapped = predecessor.wrapped();\\n    predecessor.migrateWithExternalApproval(address(this), additionalVotes);\\n    uint256 predecessorBalance = predecessor.balanceOf(address(this));\\n    if (predecessorBalance > 0) {\\n      predecessor.unwrap(predecessorBalance);\\n      _burn(address(this), predecessorBalance);\\n    }\\n    assert(predecessorSupply == totalSupply());\\n  }\\n\\n  /**\\n   * @notice As the oracle on the predecessor has to be set to this contract for migration. This contract needs to be able to set the oracle on the predecessor.\\n   * @param oracle The new oracle on the predecessor.\\n   */\\n  function setPredecessorOracle(address oracle) external onlyOracle {\\n    predecessor.setOracle(oracle);\\n  }\\n}\"\n    },\n    \"src/shares/IShares.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IShares is IERC20 {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n\\t//////////////////////////////////////////////////////////////*/\\n\\t/// New total shares can't be below current valid supply\\n\\t/// @param totalSupply  The current valid supply. \\n\\t/// @param newTotalShares  The new max shares. \\n\\terror Shares_InvalidTotalShares(uint256 totalSupply, uint256 newTotalShares);\\n\\t/// Array lengths have to be equal. \\n\\t/// @param targets Array length of targets. \\n\\t/// @param amount Array length of amounts. \\n\\terror Shares_UnequalLength(uint256 targets, uint256 amount);\\n\\t/// It isn't possible to mint more share token than max shares in existens. \\n\\t/// @param totalShares The max amount of shares. \\n\\t/// @param needed The max amount of shares needed (current valid supply + new mint amount). \\n\\terror Shares_InsufficientTotalShares(uint256 totalShares, uint256 needed);\\n\\n\\tfunction burn(uint256) external;\\n\\n\\tfunction totalShares() external view returns (uint256);\\n}\"\n    },\n    \"src/shares/Shares.sol\": {\n      \"content\": \"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/ERC20Named.sol\\\";\\nimport \\\"../ERC20/ERC20PermitLight.sol\\\";\\nimport \\\"../ERC20/IERC677Receiver.sol\\\";\\nimport \\\"../recovery/ERC20Recoverable.sol\\\";\\nimport \\\"../shares/IShares.sol\\\";\\n\\n/**\\n * @title CompanyName AG Shares\\n * @author Luzius Meisser, luzius@aktionariat.com\\n *\\n * These tokens represent ledger-based securities according to article 973d of the Swiss Code of Obligations.\\n * This smart contract serves as an ownership registry, enabling the token holders to register them as\\n * shareholders in the issuer's shareholder registry. This is equivalent to the traditional system\\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\\n * themselves. For example, in case the company pays out a dividend to a previous shareholder because\\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\\n * the \\\"wrong\\\" shareholder. In relation to the company, only the registered shareholders count as such.\\n */\\ncontract Shares is ERC20Recoverable, ERC20Named, ERC20PermitLight, IShares{\\n\\n    // Version history:\\n    // 1: everything before 2022-07-19\\n    // 2: added mintMany and mintManyAndCall, added VERSION field\\n    // 3: added permit\\n    uint8 public constant VERSION = 3;\\n\\n    string public terms;\\n\\n    uint256 public override totalShares; // total number of shares, maybe not all tokenized\\n    uint256 public invalidTokens;\\n\\n    event Announcement(string message);\\n    event TokensDeclaredInvalid(address indexed holder, uint256 amount, string message);\\n    event ChangeTerms(string terms);\\n    event ChangeTotalShares(uint256 total);\\n\\n    constructor(\\n        string memory _symbol,\\n        string memory _name,\\n        string memory _terms,\\n        uint256 _totalShares,\\n        address _owner,\\n        IRecoveryHub _recoveryHub\\n    )\\n        ERC20Named(_symbol, _name, 0, _owner) \\n        ERC20Recoverable(_recoveryHub)\\n        ERC20PermitLight()\\n    {\\n        totalShares = _totalShares;\\n        terms = _terms;\\n        invalidTokens = 0;\\n        _recoveryHub.setRecoverable(false); \\n    }\\n\\n    function setTerms(string memory _terms) external onlyOwner {\\n        terms = _terms;\\n        emit ChangeTerms(_terms);\\n    }\\n\\n    /**\\n     * Declares the number of total shares, including those that have not been tokenized and those\\n     * that are held by the company itself. This number can be substiantially higher than totalSupply()\\n     * in case not all shares have been tokenized. Also, it can be lower than totalSupply() in case some\\n     * tokens have become invalid.\\n     */\\n    function setTotalShares(uint256 _newTotalShares) external onlyOwner() {\\n        uint256 _totalValidSupply = totalValidSupply();\\n        if (_newTotalShares < _totalValidSupply) {\\n            revert Shares_InvalidTotalShares(_totalValidSupply, _newTotalShares);\\n            \\n        }\\n        totalShares = _newTotalShares;\\n        emit ChangeTotalShares(_newTotalShares);\\n    }\\n\\n    /**\\n     * Allows the issuer to make public announcements that are visible on the blockchain.\\n     */\\n    function announcement(string calldata message) external onlyOwner() {\\n        emit Announcement(message);\\n    }\\n\\n    /**\\n     * See parent method for collateral requirements.\\n     */\\n    function setCustomClaimCollateral(IERC20 collateral, uint256 rate) external onlyOwner() {\\n        super._setCustomClaimCollateral(collateral, rate);\\n    }\\n\\n    function getClaimDeleter() public override view returns (address) {\\n        return owner;\\n    }\\n\\n    /**\\n     * Signals that the indicated tokens have been declared invalid (e.g. by a court ruling in accordance\\n     * with article 973g of the Swiss Code of Obligations) and got detached from\\n     * the underlying shares. Invalid tokens do not carry any shareholder rights any more.\\n     *\\n     * This function is purely declarative. It does not technically immobilize the affected tokens as\\n     * that would give the issuer too much power.\\n     */\\n    function declareInvalid(address holder, uint256 amount, string calldata message) external onlyOwner() {\\n        uint256 holderBalance = balanceOf(holder);\\n        if (amount > holderBalance) {\\n            revert ERC20InsufficientBalance(holder, holderBalance, amount);\\n        }\\n        invalidTokens += amount;\\n        emit TokensDeclaredInvalid(holder, amount, message);\\n    }\\n\\n    /**\\n     * The total number of valid tokens in circulation. In case some tokens have been declared invalid, this\\n     * number might be lower than totalSupply(). Also, it will always be lower than or equal to totalShares().\\n     */\\n    function totalValidSupply() public view returns (uint256) {\\n        return totalSupply() - invalidTokens;\\n    }\\n\\n    /**\\n     * Allows the company to tokenize shares and transfer them e.g to the draggable contract and wrap them.\\n     * If these shares are newly created, setTotalShares must be called first in order to adjust the total number of shares.\\n     */\\n    function mintAndCall(address shareholder, address callee, uint256 amount, bytes calldata data) external {\\n        mint(callee, amount);\\n        if (!IERC677Receiver(callee).onTokenTransfer(shareholder, amount, data)) {\\n            revert IERC677Receiver.IERC677_OnTokenTransferFailed();\\n        }\\n    }\\n\\n    function mintManyAndCall(address[] calldata target, address callee, uint256[] calldata amount, bytes calldata data) external {\\n        uint256 len = target.length;\\n        if (len != amount.length) {\\n            revert Shares_UnequalLength(len, amount.length);\\n        }\\n        uint256 total = 0;\\n        for (uint256 i = 0; i<len; i++){\\n            total += amount[i];\\n        }\\n        mint(callee, total);\\n        for (uint256 i = 0; i<len; i++){\\n            if(!IERC677Receiver(callee).onTokenTransfer(target[i], amount[i], data)){\\n                revert IERC677Receiver.IERC677_OnTokenTransferFailed();\\n            }\\n        }\\n    }\\n\\n    function mint(address target, uint256 amount) public onlyOwner {\\n        _mint(target, amount);\\n    }\\n\\n    function mintMany(address[] calldata target, uint256[] calldata amount) public onlyOwner {\\n        uint256 len = target.length;\\n        if (len != amount.length) {\\n            revert Shares_UnequalLength(len, amount.length);\\n        }\\n        for (uint256 i = 0; i<len; i++){\\n            _mint(target[i], amount[i]);\\n        }\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual override {\\n        uint256 newValidSupply = totalValidSupply() + amount;\\n        if (newValidSupply > totalShares) {\\n            revert Shares_InsufficientTotalShares(totalShares, newValidSupply);\\n        }\\n        super._mint(account, amount);\\n    }\\n\\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20Flaggable, IERC20) public returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    /**\\n     * Transfers _amount tokens to the company and burns them.\\n     * The meaning of this operation depends on the circumstances and the fate of the shares does\\n     * not necessarily follow the fate of the tokens. For example, the company itself might call\\n     * this function to implement a formal decision to destroy some of the outstanding shares.\\n     * Also, this function might be called by an owner to return the shares to the company and\\n     * get them back in another form under an according agreement (e.g. printed certificates or\\n     * tokens on a different blockchain). It is not recommended to call this function without\\n     * having agreed with the company on the further fate of the shares in question.\\n     */\\n    function burn(uint256 _amount) override external {\\n        _transfer(msg.sender, address(this), _amount);\\n        _burn(address(this), _amount);\\n    }\\n\\n}\"\n    },\n    \"src/utils/Address.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n// and modified it.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Address {\\n\\n    /// @param target Target address to call the function on.\\n    error Address_NotTransferNorContract(address target);\\n\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n        return account.code.length > 0;\\n    }\\n    \\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\\n        if (data.length != 0 && !isContract(target)) {\\n            revert Address_NotTransferNorContract(target);\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else if (returndata.length > 0) {\\n            assembly{\\n                revert (add (returndata, 0x20), mload (returndata))\\n            }\\n        } else {\\n           revert(\\\"failed\\\");\\n        }\\n    }\\n}\"\n    },\n    \"src/utils/BrokerbotLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../brokerbot/IBrokerbot.sol\\\";\\nimport \\\"../brokerbot/PaymentHub.sol\\\";\\nimport \\\"../brokerbot/BrokerbotRegistry.sol\\\";\\n\\nlibrary BrokerbotLib {\\n\\n\\terror Brokerbot_Not_Found();  \\n\\tfunction getBrokerbotAndPaymentHub(BrokerbotRegistry brokerbotRegistry, IERC20 base, IERC20 token) internal view returns (IBrokerbot brokerbot, PaymentHub paymentHub) {\\n\\t\\tbrokerbot = brokerbotRegistry.getBrokerbot(base, token);\\n\\t\\tif (address(brokerbot) == address(0)) revert Brokerbot_Not_Found();\\n\\t\\tpaymentHub = PaymentHub(payable(brokerbot.paymenthub()));\\n\\t}\\n}\"\n    },\n    \"src/utils/BytesLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonalo S <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n  function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, 'toUint24_overflow');\\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\"\n    },\n    \"src/utils/Initializable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    error Initializable_AlreadyInitalized();\\n\\n    /**\\n     * @dev Modifier to protect the initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        if (_initialized) {\\n            revert Initializable_AlreadyInitalized();\\n        }\\n        _;\\n        _initialized = true;\\n    }\\n\\n}\"\n    },\n    \"src/utils/Ownable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n//\\n// Modifications:\\n// - Replaced Context._msgSender() with msg.sender\\n// - Made leaner\\n// - Extracted interface\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    error Ownable_NotOwner(address sender);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor (address initialOwner) {\\n        owner = initialOwner;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function _checkOwner() internal view {\\n        if (msg.sender != owner) {\\n            revert Ownable_NotOwner(msg.sender);\\n        }\\n    }\\n}\"\n    },\n    \"src/utils/Path.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// copied and modified from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/Path.sol\\npragma solidity >=0.6.0;\\n\\nimport './BytesLib.sol';\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary Path {\\n    using BytesLib for bytes;\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The length of the bytes encoded fee\\n    uint256 private constant FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address and pool fee\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n    /// @notice Returns true iff the path contains two or more pools\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more pools, otherwise false\\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n    }\\n\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return fee The fee level of the pool\\n    function decodeFirstPool(bytes memory path)\\n        internal\\n        pure\\n        returns (\\n            address tokenA,\\n            address tokenB,\\n            uint24 fee\\n        )\\n    {\\n        tokenA = path.toAddress(0);\\n        fee = path.toUint24(ADDR_SIZE);\\n        tokenB = path.toAddress(NEXT_OFFSET);\\n    }\\n\\n    /// @notice Gets the segment corresponding to the last pool in the path\\n    /// @param path The bytes encoded swap path\\n    /// @return The segment containing all data necessary to target the last pool in the path\\n    function getLastPool(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(path.length - POP_OFFSET, POP_OFFSET);\\n    }\\n\\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + fee elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\\n    }\\n}\"\n    },\n    \"src/utils/SafeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../ERC20/IERC20Permit.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        if (nonceAfter != nonceBefore + 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 200\n    },\n    \"evmVersion\": \"paris\",\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
      "solcInputHash": "52da0c8ebd6b37bb8f91e29cfaaf8064",
      "transactionHash": "0x2dd2430d93e7969bde35244484d7d7695b6157690c9a10c112b733417e11dac1",
      "args": [
        "0x447ffD9a116efb3D77f47802cc4869C3730f723C"
      ]
    },
    "decoded": {
      "from": "0x447ffD9a116efb3D77f47802cc4869C3730f723C",
      "gasPrice": "87424800208",
      "maxFeePerGas": "87424800208",
      "maxPriorityFeePerGas": "1500000000",
      "gasLimit": "257831",
      "to": null,
      "value": "0",
      "nonce": 10,
      "data": "0x608060405234801561001057600080fd5b506040516103f53803806103f583398101604081905261002f9161007e565b600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350506100ae565b60006020828403121561009057600080fd5b81516001600160a01b03811681146100a757600080fd5b9392505050565b610338806100bd6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806309f793711461005c57806376abbf0a146100715780638da5cb5b146100c15780639abad75e146100d4578063f2fde38b146100e7575b600080fd5b61006f61006a36600461025a565b6100fa565b005b6100a561007f3660046102a5565b60016020908152600092835260408084209091529082529020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6000546100a5906001600160a01b031681565b61006f6100e23660046102de565b610175565b61006f6100f53660046102de565b6101ac565b61010261020f565b6001600160a01b0382811660008181526001602090815260408083208686168085529083529281902080546001600160a01b03191695891695861790555193845290927f3cc22fa2b08c920913fb7245fcc72114373ad796b1be5d44ee1ff6ad60b3a65a910160405180910390a3505050565b6040516001600160a01b038216907f8709efa7ee1ccd26c55d0d4770969d05389572dec0bc4e3b34acfdf89f1b64f990600090a250565b6101b461020f565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b03163314610240576040516396a19be960e01b815233600482015260240160405180910390fd5b565b6001600160a01b038116811461025757600080fd5b50565b60008060006060848603121561026f57600080fd5b833561027a81610242565b9250602084013561028a81610242565b9150604084013561029a81610242565b809150509250925092565b600080604083850312156102b857600080fd5b82356102c381610242565b915060208301356102d381610242565b809150509250929050565b6000602082840312156102f057600080fd5b81356102fb81610242565b939250505056fea26469706673582212205b7e29f3d56ce9e9696aa8901cae24cdf99842d4135753964ace66f4ebdbdef564736f6c63430008150033000000000000000000000000447ffd9a116efb3d77f47802cc4869c3730f723c",
      "r": "0x68de07be0d9a5799da2b4b05a6f0a403abddb06f1f714ef8b302ed223cc3fc9d",
      "s": "0x20a06295000dbebd08c97aa94461c67b8bb8df427fa7f7a87aaaa4d98a1d1a65",
      "v": 0,
      "chainId": 137
    }
  }
}