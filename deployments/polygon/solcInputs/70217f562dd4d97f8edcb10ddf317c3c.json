{
  "language": "Solidity",
  "sources": {
    "src/draggable/ERC20Draggable.sol": {
      "content": "/**\n * SPDX-License-Identifier: LicenseRef-Aktionariat\n *\n * MIT License with Automated License Fee Payments\n *\n * Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n *\n * Permission is hereby granted to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - All automated license fee payments integrated into this and related Software\n *   are preserved.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-20 tokens subject to a drag-along agreement\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * This is an ERC-20 token that is bound to a shareholder or other agreement that contains\n * a drag-along clause. The smart contract can help enforce this drag-along clause in case\n * an acquirer makes an offer using the provided functionality. If a large enough quorum of\n * token holders agree, the remaining token holders can be automatically \"dragged along\" or\n * squeezed out. For shares non-tokenized shares, the contract relies on an external Oracle\n * to provide the votes of those.\n *\n * Subclasses should provide a link to a human-readable form of the agreement.\n */\n\nimport \"./IDraggable.sol\";\nimport \"../ERC20/ERC20Flaggable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\nimport \"./IOffer.sol\";\nimport \"./IOfferFactory.sol\";\nimport \"../shares/IShares.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Draggable is IERC677Receiver, IDraggable, ERC20Flaggable {\n\n\tusing SafeERC20 for IERC20;\n    \n\t// If flag is not present, one can be sure that the address did not vote. If the \n\t// flag is present, the address might have voted and one needs to check with the\n\t// current offer (if any) when transferring tokens.\n\tuint8 private constant FLAG_VOTE_HINT = 1;\n\n\tIERC20 public override wrapped; // The wrapped contract\n\tIOfferFactory public immutable factory;\n\n\t// If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\n\tuint256 public unwrapConversionFactor = 0;\n\n\t// The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\n\tIOffer public override offer;\n\n\tuint256 private constant QUORUM_MULTIPLIER = 10000;\n\n\tuint256 public immutable quorumMigration; // used for contract migartion, in BPS (out of 10'000)\n\tuint256 public immutable quorum; // used for drag-along at acquisition offers, in BPS (out of 10'000)\n\tuint256 public immutable votePeriod; // In seconds\n\n\taddress public override oracle;\n\n\tstruct DraggableParams {\n\t\tIERC20 wrappedToken;\n\t\tuint256 quorumDrag;\n\t\tuint256 quorumMigration;\n\t\tuint256 votePeriod;\n\t}\n\n\tevent MigrationSucceeded(address newContractAddress, uint256 yesVotes, uint256 oracleVotes, uint256 totalVotingPower);\n\tevent ChangeOracle(address oracle);\n\n    /**\n\t * Note that the Brokerbot only supports tokens that revert on failure and where transfer never returns false.\n     */\n\tconstructor(\n\t\tDraggableParams memory _params,\n\t\tIOfferFactory _offerFactory,\n\t\taddress _oracle\n\t) \n\t\tERC20Flaggable(0)\n\t{\n\t\twrapped = _params.wrappedToken;\n\t\tquorum = _params.quorumDrag;\n\t\tquorumMigration = _params.quorumMigration;\n\t\tvotePeriod = _params.votePeriod;\n\t\tfactory = _offerFactory;\n\t\toracle = _oracle;\n\t}\n\n\tmodifier onlyOracle {\n\t\t_checkSender(oracle);\n\t\t_;\n\t}\n\n\tmodifier onlyWrappedToken {\n\t\t_checkSender(address(wrapped));\n\t\t_;\n\t}\n\n\tmodifier onlyOffer(){\n\t\t_checkSender(address(offer));\n\t\t_;\n\t}\n\n\tmodifier checkBinding(bool expected) {\n\t\tif (expected != isBinding()) {\n\t\t\tif(expected) {\n\t\t\t\trevert Draggable_NotBinding();\n\t\t\t}\n\t\t\tif(!expected) {\n\t\t\t\trevert Draggable_IsBinding();\n\t\t\t}\n\t\t} \n\t\t_;\n\t}\n\n\tfunction onTokenTransfer(\n\t\taddress from, \n\t\tuint256 amount, \n\t\tbytes calldata\n\t) external override onlyWrappedToken returns (bool) {\n\t\t_mint(from, amount);\n\t\treturn true;\n\t}\n\n\t/** Wraps additional tokens, thereby creating more ERC20Draggable tokens. */\n\tfunction wrap(address shareholder, uint256 amount) external {\n\t\twrapped.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_mint(shareholder, amount);\n\t}\n\n\t/**\n\t * Indicates that the token holders are bound to the token terms and that:\n\t * - Conversion back to the wrapped token (unwrap) is not allowed\n\t * - A drag-along can be performed by making an according offer\n\t * - They can be migrated to a new version of this contract in accordance with the terms\n\t */\n\tfunction isBinding() public view returns (bool) {\n\t\treturn unwrapConversionFactor == 0;\n\t}\n\n    /**\n\t * Current recommended naming convention is to add the postfix \"SHA\" to the plain shares\n\t * in order to indicate that this token represents shares bound to a shareholder agreement.\n\t */\n\tfunction name() public view override returns (string memory) {\n\t\tstring memory wrappedName = wrapped.name();\n\t\tif (isBinding()) {\n\t\t\treturn string(abi.encodePacked(wrappedName, \" SHA\"));\n\t\t} else {\n\t\t\treturn string(abi.encodePacked(wrappedName, \" (Wrapped)\"));\n\t\t}\n\t}\n\n\tfunction symbol() public view override returns (string memory) {\n\t\t// ticker should be less dynamic than name\n\t\treturn string(abi.encodePacked(wrapped.symbol(), \"S\"));\n\t}\n\n\t/**\n\t * Deactivates the drag-along mechanism and enables the unwrap function.\n\t */\n\tfunction _deactivate(uint256 factor) internal {\n\t\tif (factor == 0) {\n\t\t\trevert Draggable_FactorZero();\n\t\t}\n\t\tunwrapConversionFactor = factor;\n\t}\n\n\t/** Decrease the number of drag-along tokens. The user gets back their shares in return */\n\tfunction unwrap(uint256 amount) external override checkBinding(false) {\n\t\t_unwrap(msg.sender, amount, unwrapConversionFactor);\n\t}\n\n\tfunction _unwrap(address owner, uint256 amount, uint256 factor) internal {\n\t\t_burn(owner, amount);\n\t\twrapped.safeTransfer(owner, amount * factor);\n\t}\n\n\t/**\n\t * Burns both the token itself as well as the wrapped token!\n\t * If you want to get out of the shareholder agreement, use unwrap after it has been\n\t * deactivated by a majority vote or acquisition.\n\t *\n\t * Burning only works if wrapped token supports burning. Also, the exact meaning of this\n\t * operation might depend on the circumstances. Burning and reussing the wrapped token\n\t * does not free the sender from the legal obligations of the shareholder agreement.\n\t */\n\tfunction burn(uint256 amount) external {\n\t\t_burn(msg.sender, amount);\n\t\tIShares(address(wrapped)).burn(isBinding() ? amount : amount * unwrapConversionFactor);\n\t}\n\n\tfunction makeAcquisitionOffer(\n\t\tbytes32 salt, \n\t\tuint256 pricePerShare, \n\t\tIERC20 currency\n\t) external payable checkBinding(true) {\n\t\tIOffer newOffer = factory.create{value: msg.value}(\n\t\t\tsalt, msg.sender, pricePerShare, currency, quorum, votePeriod);\n\n\t\tif (_offerExists()) {\n\t\t\toffer.makeCompetingOffer(newOffer);\n\t\t}\n\t\toffer = newOffer;\n\t}\n\n\tfunction drag(address buyer, IERC20 currency) external override onlyOffer {\n\t\t_unwrap(buyer, balanceOf(buyer), 1);\n\t\t_replaceWrapped(currency, buyer);\n\t}\n\n\tfunction notifyOfferEnded() external override onlyOffer {\n\t\toffer = IOffer(address(0));\n\t}\n\n\tfunction _replaceWrapped(IERC20 newWrapped, address oldWrappedDestination) internal checkBinding(true) {\n\t\t// Free all old wrapped tokens we have\n\t\twrapped.safeTransfer(oldWrappedDestination, wrapped.balanceOf(address(this)));\n\t\t// Count the new wrapped tokens\n\t\twrapped = newWrapped;\n\t\tif (totalSupply() > 0) // if there are no tokens, no need to deactivate\n\t\t\t_deactivate(newWrapped.balanceOf(address(this)) / totalSupply());\n\t\temit NameChanged(name(), symbol());\n\t}\n\n\tfunction setOracle(address newOracle) external override onlyOracle {\n\t\toracle = newOracle;\n\t\temit ChangeOracle(oracle);\n\t}\n\n\tfunction migrateWithExternalApproval(address successor, uint256 additionalVotes) external override onlyOracle {\n\t\t// Additional votes cannot be higher than the votes not represented by these tokens.\n\t\t// The assumption here is that more shareholders are bound to the shareholder agreement\n\t\t// that this contract helps enforce and a vote among all parties is necessary to change\n\t\t// it, with an oracle counting and reporting the votes of the others.\n\t\tif (totalSupply() + additionalVotes > totalVotingTokens()) {\n\t\t\trevert Draggable_TooManyVotes(totalVotingTokens(), totalSupply() + additionalVotes);\n\t\t}\n\t\t_migrate(successor, additionalVotes);\n\t}\n\n\tfunction migrate() external override {\n\t\t_migrate(msg.sender, 0);\n\t}\n\n\tfunction _migrate(address successor, uint256 additionalVotes) internal {\n\t\tuint256 yesVotes = additionalVotes + balanceOf(successor);\n\t\tuint256 totalVotes = totalVotingTokens();\n\t\tif (yesVotes > totalVotes) {\n\t\t\trevert Draggable_TooManyVotes(totalVotes, yesVotes);\n\t\t}\n\t\tif (_offerExists()) {\n\t\t\t// if you have the quorum, you can cancel the offer first if necessary\n\t\t\trevert Draggable_OpenOffer();\n\t\t}\n\t\tif (yesVotes * QUORUM_MULTIPLIER < totalVotes * quorumMigration) {\n\t\t\trevert Draggable_QuorumNotReached(totalVotes * quorumMigration, yesVotes * QUORUM_MULTIPLIER);\n\t\t}\n\t\t_replaceWrapped(IERC20(successor), successor);\n\t\temit MigrationSucceeded(successor, yesVotes, additionalVotes, totalVotes);\n\t}\n\n\tfunction votingPower(address voter) external view override returns (uint256) {\n\t\treturn balanceOf(voter);\n\t}\n\n\tfunction totalVotingTokens() public view override returns (uint256) {\n\t\treturn IShares(address(wrapped)).totalShares();\n\t}\n\n\tfunction _hasVoted(address voter) internal view returns (bool) {\n\t\treturn hasFlagInternal(voter, FLAG_VOTE_HINT);\n\t}\n\n\tfunction notifyVoted(address voter) external override onlyOffer {\n\t\tsetFlag(voter, FLAG_VOTE_HINT, true);\n\t}\n\n\tfunction _beforeTokenTransfer(address from, address to,\tuint256 amount) internal virtual override {\n\t\tif (_hasVoted(from) || _hasVoted(to)) {\n\t\t\tif (_offerExists()) {\n\t\t\t\toffer.notifyMoved(from, to, amount);\n\t\t\t} else {\n\t\t\t\tsetFlag(from, FLAG_VOTE_HINT, false);\n\t\t\t\tsetFlag(to, FLAG_VOTE_HINT, false);\n\t\t\t}\n\t\t}\n\t\tsuper._beforeTokenTransfer(from, to, amount);\n\t}\n\n\tfunction _offerExists() internal view returns (bool) {\n\t\treturn address(offer) != address(0) && ! offer.isKilled();\t\t// needs to have contract deployed AND offer needs to be not in deleted state\n\t}\n}\n"
    },
    "src/draggable/IDraggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IOffer.sol\";\ninterface IDraggable is IERC20 {\n\n    /*//////////////////////////////////////////////////////////////\n                            Custom errors\n    //////////////////////////////////////////////////////////////*/\n    /// conversion factor has to be > 0 for this transaction.\n    error Draggable_NotBinding();\n    /// conversion factor has to be = 0 for this transaction.\n    error Draggable_IsBinding();\n    /// conversion factor can't be 0 if binding gets deactivated.\n    error Draggable_FactorZero();\n    /// the reported votes can't be > max voting tokens.\n    /// @param maxVotes The max voting tokens.\n    /// @param reportedVotes The actual reported votes.\n    error Draggable_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\n    /// there is still an open offer that has to be canceled first\n    error Draggable_OpenOffer();\n    /// For migration the quorum needs to be reached.\n    /// @param needed The needed quorum.\n    /// @param actual The current yes votes.\n    error Draggable_QuorumNotReached(uint256 needed, uint256 actual);\n    \n    function wrapped() external view returns (IERC20);\n    function unwrap(uint256 amount) external;\n    function offer() external view returns (IOffer);\n    function oracle() external view returns (address);\n    function drag(address buyer, IERC20 currency) external;\n    function notifyOfferEnded() external;\n    function votingPower(address voter) external returns (uint256);\n    function totalVotingTokens() external view returns (uint256);\n    function notifyVoted(address voter) external;\n    function migrate() external;\n    function setOracle(address newOracle) external;\n    function migrateWithExternalApproval(address successor, uint256 additionalVotes) external;\n    function setTerms(string calldata _terms) external;\n\n\n}\n"
    },
    "src/draggable/IOffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IOffer {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n  //////////////////////////////////////////////////////////////*/\n\t/// Invalid msg.sender.\n\t/// @param sender The msg.sender of the transaction.\n\terror Offer_InvalidSender(address sender);\n\t/// Offer needs to be still open.\n\terror Offer_AlreadyAccepted();\n\t/// Offer needs to be not accepted yet.\n\terror Offer_NotAccepted();\n\t/// Sender of the offer needs to have needed funds in his account.\n\terror Offer_NotWellFunded();\n\t/// New offer not valid. `newPrice` needs to be higher than `oldPrice`.\n\t/// @param oldPrice Price of the old offer.\n\t/// @param newPrice Price of the new offer.\n\terror Offer_OldOfferBetter(uint256 oldPrice, uint256 newPrice);\n\t/// Voting needs to be still open.\n\terror Offer_VotingEnded();\n\t/// Too many (External) reported votes. `reportedVotes` needs to be less or equal to `maxVotes`.\n\t/// @param maxVotes The max possible votes for the token.\n\t/// @param reportedVotes The external reported votes + circulating supply of the token.\n\terror Offer_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\n\t/// Competing offer needs to be in the same currency.\n\terror Offer_OfferInWrongCurrency();\n\t/// Offer got already killed.\n\terror Offer_IsKilled();\n\n\t/*//////////////////////////////////////////////////////////////\n                            Function Interfaces\n\t//////////////////////////////////////////////////////////////*/\n\n\tfunction makeCompetingOffer(IOffer newOffer) external;\n\n\t// if there is a token transfer while an offer is open, the votes get transfered too\n\tfunction notifyMoved(address from, address to, uint256 value) external;\n\n\tfunction currency() external view returns (IERC20);\n\n\tfunction price() external view returns (uint256);\n\n\tfunction isWellFunded() external view returns (bool);\n\n\tfunction voteYes() external;\n\n\tfunction voteNo() external;\n\n\tfunction isKilled() external view returns (bool);\n}"
    },
    "src/draggable/IOfferFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IOffer.sol\";\n\ninterface IOfferFactory {\n\n\tfunction create(\n\t\tbytes32 salt, address buyer, uint256 pricePerShare,\tIERC20 currency,\tuint256 quorum,\tuint256 votePeriod\n\t) external payable returns (IOffer);\n}"
    },
    "src/ERC20/ERC20Allowlistable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\n\nimport \"./ERC20Flaggable.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * A very flexible and efficient form to subject ERC-20 tokens to an allowlisting.\n * See ../../doc/allowlist.md for more information.\n */\nabstract contract ERC20Allowlistable is ERC20Flaggable, Ownable {\n\n  uint8 private constant TYPE_DEFAULT = 0x0;\n  uint8 private constant TYPE_ALLOWLISTED = 0x1;\n  uint8 private constant TYPE_FORBIDDEN = 0x2;\n  uint8 private constant TYPE_POWERLISTED = 0x4;\n  // I think TYPE_POWERLISTED should have been 0x3. :) But MOP was deployed like this so we keep it. Does not hurt.\n\n  uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\n  uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\n  uint8 private constant FLAG_INDEX_POWERLIST = 22;\n\n  event AddressTypeUpdate(address indexed account, uint8 addressType);\n\n  /// Receiver has flag forbidden.\n  /// @param receiver the address of the forbidden receiver.\n  error Allowlist_ReceiverIsForbidden(address receiver);\n  /// Sender has flag forbidden.\n  /// @param sender the address of the forbidden sender.\n  error Allowlist_SenderIsForbidden(address sender);\n  /// Receiver has no allowlist flag.\n  /// @param receiver the address which isn't allowlisted.\n  error Allowlist_ReceiverNotAllowlisted(address receiver);\n\n  bool public restrictTransfers;\n\n  constructor(){\n    setApplicableInternal(true);\n  }\n\n  /**\n   * Configures whether the allowlisting is applied.\n   * Also sets the powerlist and allowlist flags on the null address accordingly.\n   * It is recommended to also deactivate the powerlist flag on other addresses.\n   */\n  function setApplicable(bool transferRestrictionsApplicable) external onlyOwner {\n    setApplicableInternal(transferRestrictionsApplicable);\n  }\n\n  function setApplicableInternal(bool transferRestrictionsApplicable) internal {\n    restrictTransfers = transferRestrictionsApplicable;\n    // if transfer restrictions are applied, we guess that should also be the case for newly minted tokens\n    // if the admin disagrees, it is still possible to change the type of the null address\n    if (transferRestrictionsApplicable){\n      setTypeInternal(address(0x0), TYPE_POWERLISTED);\n    } else {\n      setTypeInternal(address(0x0), TYPE_DEFAULT);\n    }\n  }\n\n  function setType(address account, uint8 typeNumber) public onlyOwner {\n    setTypeInternal(account, typeNumber);\n  }\n\n  /**\n   * If TYPE_DEFAULT all flags are set to 0\n   */\n  function setTypeInternal(address account, uint8 typeNumber) internal {\n    setFlag(account, FLAG_INDEX_ALLOWLIST, typeNumber == TYPE_ALLOWLISTED);\n    setFlag(account, FLAG_INDEX_FORBIDDEN, typeNumber == TYPE_FORBIDDEN);\n    setFlag(account, FLAG_INDEX_POWERLIST, typeNumber == TYPE_POWERLISTED);\n    emit AddressTypeUpdate(account, typeNumber);\n  }\n\n  function setType(address[] calldata addressesToAdd, uint8 value) public onlyOwner {\n    for (uint i=0; i<addressesToAdd.length; i++){\n      setType(addressesToAdd[i], value);\n    }\n  }\n\n  /**\n   * If true, this address is allowlisted and can only transfer tokens to other allowlisted addresses.\n   */\n  function canReceiveFromAnyone(address account) public view returns (bool) {\n    return hasFlagInternal(account, FLAG_INDEX_ALLOWLIST) || hasFlagInternal(account, FLAG_INDEX_POWERLIST);\n  }\n\n  /**\n   * If true, this address can only transfer tokens to allowlisted addresses and not receive from anyone.\n   */\n  function isForbidden(address account) public view returns (bool){\n    return hasFlagInternal(account, FLAG_INDEX_FORBIDDEN);\n  }\n\n  /**\n   * If true, this address can automatically allowlist target addresses if necessary.\n   */\n  function isPowerlisted(address account) public view returns (bool) {\n    return hasFlagInternal(account, FLAG_INDEX_POWERLIST);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) override virtual internal {\n    super._beforeTokenTransfer(from, to, amount);\n    // empty block for gas saving fall through\n    // solhint-disable-next-line no-empty-blocks\n    if (canReceiveFromAnyone(to)){\n      // ok, transfers to allowlisted addresses are always allowed\n    } else if (isForbidden(to)){\n      // Target is forbidden, but maybe restrictions have been removed and we can clean the flag\n      if (restrictTransfers) {\n        revert Allowlist_ReceiverIsForbidden(to);\n      }\n      setFlag(to, FLAG_INDEX_FORBIDDEN, false);\n    } else {\n      if (isPowerlisted(from)){\n        // it is not allowlisted, but we can make it so\n        // we know the recipient is neither forbidden, allowlisted or powerlisted, so we can set flag directly\n        setFlag(to, FLAG_INDEX_ALLOWLIST, true);\n        emit AddressTypeUpdate(to, TYPE_ALLOWLISTED);\n      }\n      // if we made it to here, the target must be a free address and we are not powerlisted\n      else if (hasFlagInternal(from, FLAG_INDEX_ALLOWLIST)){\n        // We cannot send to free addresses, but maybe the restrictions have been removed and we can clean the flag?\n        if (restrictTransfers) {\n          revert Allowlist_ReceiverNotAllowlisted(to);\n        }\n        setFlag(from, FLAG_INDEX_ALLOWLIST, false);\n      } else if (isForbidden(from)){\n        if (restrictTransfers) {\n          revert Allowlist_SenderIsForbidden(from);\n        }\n        setFlag(from, FLAG_INDEX_FORBIDDEN, false);\n      }\n    }\n  }\n\n}\n"
    },
    "src/ERC20/ERC20Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/// @title Standard ERC20 Errors\n/// @dev See https://eips.ethereum.org/EIPS/eip-20\n///  https://eips.ethereum.org/EIPS/eip-6093\ninterface ERC20Errors {\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n    error ERC20InvalidSender(address sender);\n    error ERC20InvalidReceiver(address receiver);\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n    error ERC20InvalidApprover(address approver);\n    error ERC20InvalidSpender(address spender);\n}"
    },
    "src/ERC20/ERC20Flaggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n// - use upper 32 bits of balance for flags\n// - add a global settings variable\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./ERC20Errors.sol\";\nimport \"./IERC677Receiver.sol\";\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\n\nabstract contract ERC20Flaggable is IERC20, ERC20Errors {\n\n    // as Documented in /doc/infiniteallowance.md\n    // 0x8000000000000000000000000000000000000000000000000000000000000000\n    uint256 constant private INFINITE_ALLOWANCE = 2**255;\n\n    uint256 private constant FLAGGING_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\n\n    // Documentation of flags used by subclasses:\n    // NOTE: flags denote the bit number that is being used and must be smaller than 32\n    // ERC20Draggable: uint8 private constant FLAG_INDEX_VOTED = 1;\n    // ERC20Recoverable: uint8 private constant FLAG_INDEX_CLAIM_PRESENT = 10;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_POWERLIST = 22;\n\n    mapping (address => uint256) private _balances; // upper 32 bits reserved for flags\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    uint8 public override decimals;\n\n    event NameChanged(string name, string symbol);\n\n    /// Overflow on minting, transfer. \n    /// @param receiver The address were the balance overflows. \n    /// @param balance The current balance of the receiver. \n    /// @param amount The amount added, which result in the overflow. \n    error ERC20BalanceOverflow(address receiver, uint256 balance, uint256 amount);\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return uint224 (_balances [account]);\n    }\n\n    function hasFlag(address account, uint8 number) external view returns (bool) {\n        return hasFlagInternal(account, number);\n    }\n\n    function setFlag(address account, uint8 index, bool value) internal {\n        uint256 flagMask = 1 << (index + 224);\n        uint256 balance = _balances [account];\n        if ((balance & flagMask == flagMask) != value) {\n            _balances [account] = balance ^ flagMask;\n        }\n    }\n\n    function hasFlagInternal(address account, uint8 number) internal view returns (bool) {\n        uint256 flag = 0x1 << (number + 224);\n        return _balances[account] & flag == flag;\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = allowance(sender, msg.sender);\n        if (currentAllowance < INFINITE_ALLOWANCE){\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in /doc/infiniteallowance.md\n            _allowances[sender][msg.sender] = currentAllowance - amount;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        _beforeTokenTransfer(sender, recipient, amount);\n        decreaseBalance(sender, amount);\n        increaseBalance(recipient, amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external virtual returns (bool) {\n        return transfer (recipient, amount) \n            && IERC677Receiver (recipient).onTokenTransfer (msg.sender, amount, data);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), recipient, amount);\n        _totalSupply += amount;\n        increaseBalance(recipient, amount);\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    function increaseBalance(address recipient, uint256 amount) private {\n        if (recipient == address(0x0)) {\n            revert ERC20InvalidReceiver(recipient); //use burn instead\n        }\n        uint256 oldBalance = _balances[recipient];\n        uint256 newBalance = oldBalance + amount;\n        if (oldBalance & FLAGGING_MASK != newBalance & FLAGGING_MASK) {\n            revert ERC20BalanceOverflow(recipient, oldBalance, amount);\n        }\n        _balances[recipient] = newBalance;\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        decreaseBalance(account, amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function decreaseBalance(address sender, uint256 amount) private {\n        uint256 oldBalance = _balances[sender];\n        uint256 newBalance = oldBalance - amount;\n        if (oldBalance & FLAGGING_MASK != newBalance & FLAGGING_MASK) {\n            revert ERC20InsufficientBalance(sender, balanceOf(sender), amount);\n        }\n        _balances[sender] = newBalance;\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n     // solhint-disable-next-line no-empty-blocks\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\n        // intentionally left blank\n    }\n\n    /**\n     * Checks if msg.sender is an authorized address.\n     * @param validSender The authorized address.\n     */\n    function _checkSender(address validSender) internal view {\n        if (msg.sender != validSender) {\n            revert ERC20InvalidSender(msg.sender);\n        }\n    }\n\n}"
    },
    "src/ERC20/ERC20Named.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Flaggable.sol\";\nimport \"../utils/Ownable.sol\";\n\ncontract ERC20Named is ERC20Flaggable, Ownable {\n\n    string public override name;\n    string public override symbol;\n\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, address _admin) ERC20Flaggable(_decimals) Ownable(_admin) {\n        setNameInternal(_symbol, _name);\n    }\n\n    function setName(string memory _symbol, string memory _name) external onlyOwner {\n        setNameInternal(_symbol, _name);\n    }\n\n    function setNameInternal(string memory _symbol, string memory _name) internal {\n        symbol = _symbol;\n        name = _name;\n        emit NameChanged(_name, _symbol);\n    }\n\n}"
    },
    "src/ERC20/ERC20Permit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"./ERC20Flaggable.sol\";\nimport \"../utils/Permit2Hub.sol\";\n\n/// @title ERC20Permit2\n/// @dev This abstract contract extends the ERC20Flaggable contract and introduces the Permit2Hub.\nabstract contract ERC20Permit2 is ERC20Flaggable {\n    \n    /// @dev The Permit2Hub contract instance.\n    Permit2Hub public immutable permit2Hub;\n\n    /// @dev Initializes the ERC20Permit2 contract.\n    /// @param _permit2Hub The address of the Permit2Hub contract.\n    constructor(Permit2Hub _permit2Hub) {\n        permit2Hub = _permit2Hub;\n    }\n\n    /// @inheritdoc ERC20Flaggable\n    function allowance(address owner, address spender) public view virtual override(ERC20Flaggable) returns (uint256) {\n        if (permit2Hub.isPermit2Enabled(owner, spender)) \n            return type(uint256).max;  // If permit is enabled, return the maximum value of uint256\n        else \n            return super.allowance(owner, spender);  // Otherwise, call the parent(ERC20Flaggable) allowance function\n    }\n}\n"
    },
    "src/ERC20/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Flaggable.sol\";\nimport \"./IERC20Permit.sol\";\nabstract contract ERC20PermitLight is ERC20Flaggable, IERC20Permit {\n\n   /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public override nonces;\n\n  /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override {\n        if (deadline < block.timestamp) {\n            revert Permit_DeadlineExpired(deadline, block.timestamp);\n        }\n\n        unchecked { // unchecked to save a little gas with the nonce increment...\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0) || recoveredAddress != owner) {\n                revert Permit_InvalidSigner(recoveredAddress);\n            }\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n}"
    },
    "src/ERC20/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "src/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit is IERC20 {\n\n    /*//////////////////////////////////////////////////////////////\n                            Custom errors\n\t//////////////////////////////////////////////////////////////*/\n    /// Block timestamp must to be before deadline.\n    /// @param deadline The deadline of the permit.\n    /// @param blockTimestamp The timestamp of the execution block.\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\n    /// Recovered address must be owner and not zero address.\n    /// @param signerAddress The recovered signer address.\n    error Permit_InvalidSigner(address signerAddress);\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    "src/ERC20/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\ninterface IERC677Receiver {\n\n    error IERC677_OnTokenTransferFailed();\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "src/recovery/ERC20Recoverable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Flaggable.sol\";\nimport \"./IRecoveryHub.sol\";\nimport \"./IRecoverable.sol\";\n\n/**\n * @title Recoverable\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\n * declareLost function on the recovery hub to post a deposit and claim that the shares assigned to a\n * specific address are lost.\n * If an attacker trying to claim shares belonging to someone else, they risk losing the deposit\n * as it can be claimed at anytime by the rightful owner.\n * Furthermore, if \"getClaimDeleter\" is defined in the subclass, the returned address is allowed to\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\n * function, e.g. cases of front-running.\n * Most functionality is implemented in a shared RecoveryHub.\n */\nabstract contract ERC20Recoverable is ERC20Flaggable, IRecoverable {\n\n    uint8 private constant FLAG_CLAIM_PRESENT = 10;\n\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\n    IERC20 public customCollateralAddress;\n    // Rate the custom collateral currency is multiplied to be valued like one share.\n    uint256 public customCollateralRate;\n\n    uint256 constant CLAIM_PERIOD = 180 days;\n\n    IRecoveryHub public override immutable recovery;\n\n    constructor(IRecoveryHub recoveryHub){\n        recovery = recoveryHub;\n    }\n\n    modifier onlyRecovery {\n        _checkSender(address(recovery));\n        _;\n    }\n\n    /**\n     * Returns the collateral rate for the given collateral type and 0 if that type\n     * of collateral is not accepted. By default, only the token itself is accepted at\n     * a rate of 1:1.\n     *\n     * Subclasses should override this method if they want to add additional types of\n     * collateral.\n     */\n    function getCollateralRate(IERC20 collateralType) public override virtual view returns (uint256) {\n        if (address(collateralType) == address(this)) {\n            return 1;\n        } else if (collateralType == customCollateralAddress) {\n            return customCollateralRate;\n        } else {\n            return 0;\n        }\n    }\n\n    function claimPeriod() external pure override returns (uint256){\n        return CLAIM_PERIOD;\n    }\n\n    /**\n     * Allows subclasses to set a custom collateral besides the token itself.\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\n     * throws an exception or returns false on failure.\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\n     */\n    function _setCustomClaimCollateral(IERC20 collateral, uint256 rate) internal {\n        customCollateralAddress = collateral;\n        if (address(customCollateralAddress) == address(0)) {\n            customCollateralRate = 0; // disabled\n        } else {\n            if (rate == 0) {\n                revert Recoverable_RateZero();\n            }\n            customCollateralRate = rate;\n        }\n    }\n\n    function getClaimDeleter() virtual public view returns (address);\n\n    function transfer(address recipient, uint256 amount) override(ERC20Flaggable, IERC20) virtual public returns (bool) {\n        super.transfer(recipient, amount); // no need for safe transfer, as it's our own token\n        if (hasFlagInternal(msg.sender, FLAG_CLAIM_PRESENT)){\n            recovery.clearClaimFromToken(msg.sender);\n        }\n        return true;\n    }\n\n    function notifyClaimMade(address target) external override onlyRecovery {\n        setFlag(target, FLAG_CLAIM_PRESENT, true);\n    }\n\n    function notifyClaimDeleted(address target) external override onlyRecovery {\n        setFlag(target, FLAG_CLAIM_PRESENT, false);\n    }\n\n    function deleteClaim(address lostAddress) external {\n        _checkSender(getClaimDeleter());\n        recovery.deleteClaim(lostAddress);\n    }\n\n    function recover(address oldAddress, address newAddress) external override onlyRecovery {\n        _transfer(oldAddress, newAddress, balanceOf(oldAddress));\n    }\n\n}"
    },
    "src/recovery/IRecoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IRecoveryHub.sol\";\n\ninterface IRecoverable is IERC20{\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n    //////////////////////////////////////////////////////////////*/\n    /// The new custom claim collateral rate has to be always > 0. \n    error Recoverable_RateZero();\n\n    // returns the recovery hub\n    function recovery() external view returns (IRecoveryHub);\n\n    function claimPeriod() external view returns (uint256);\n    \n    function notifyClaimMade(address target) external;\n\n    function notifyClaimDeleted(address target) external;\n\n    function getCollateralRate(IERC20 collateral) external view returns(uint256);\n\n    function recover(address oldAddress, address newAddress) external;\n\n}"
    },
    "src/recovery/IRecoveryHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRecoverable.sol\";\nimport \"../ERC20/IERC20.sol\";\n\ninterface IRecoveryHub {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n    //////////////////////////////////////////////////////////////*/\n    /// Recovery can be disabled per address.\n    /// @param lostAddress The address for which the recovery is disabled.\n    error RecoveryHub_RecoveryDisabled(address lostAddress);\n    /// No valid collateral type\n    /// @param collateralType The address of collateral type token\n    error RecoveryHub_BadCollateral(IERC20 collateralType);\n    /// No token to able to recover on the lost address\n    /// @param token The token address which is checked for recovery.\n    /// @param lostAddress The lost address.\n    error RecoveryHub_NothingToRecover(IERC20 token, address lostAddress);\n    /// The was already a claim for this token and address.\n    /// @param token The token address.\n    /// @param lostAddress The lost address.\n    error RecoveryHub_AlreadyClaimed(IERC20 token, address lostAddress);\n    /// Sender has to be claimant\n    /// @param sender The msg.sender of the call\n    error RecoveryHub_InvalidSender(address sender);\n    /// No claim for this address exists\n    /// @param lostAddress The checked address \n    error RecoveryHub_ClaimNotFound(address lostAddress);\n    /// Recover can only be called after the claim period\n    /// @param claimPeriodEnd The timestamp when the period ends\n    /// @param currentTimestamp The block timestamp of the call\n    error RecoveryHub_InClaimPeriod(uint256 claimPeriodEnd, uint256 currentTimestamp);\n\n    function setRecoverable(bool flag) external;\n    \n    // deletes claim and transfers collateral back to claimer\n    function deleteClaim(address target) external;\n\n    // clears claim and transfers collateral to holder\n    function clearClaimFromToken(address holder) external;\n\n    function clearClaimFromUser(IRecoverable token) external;\n\n}"
    },
    "src/shares/AllowlistDraggableShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Allowlistable.sol\";\nimport \"./DraggableShares.sol\";\n\ncontract AllowlistDraggableShares is DraggableShares, ERC20Allowlistable {\n\n  constructor(\n    string memory _terms,\n    DraggableParams memory _params,\n    IRecoveryHub _recoveryHub,\n    IOfferFactory _offerFactory,\n    address _oracle,\n    Permit2Hub _permit2Hub\n  )\n    DraggableShares(_terms, _params, _recoveryHub, _offerFactory, _oracle, _permit2Hub)\n    Ownable(_oracle)\n  {\n    // initialization is done in ERC20Allowlistbale and DraggableShares\n  }\n\n  function transfer(address to, uint256 value) virtual override(ERC20Flaggable, DraggableShares) public returns (bool) {\n      return super.transfer(to, value);\n  }\n  \n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Allowlistable, DraggableShares) internal {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n    function allowance(address owner, address spender) public view override(DraggableShares, ERC20Flaggable) returns (uint256) {\n        return super.allowance(owner,spender);\n  }\n\n}"
    },
    "src/shares/AllowlistShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../ERC20/ERC20Allowlistable.sol\";\nimport \"./Shares.sol\";\n\ncontract AllowlistShares is Shares, ERC20Allowlistable {\n\n  constructor(\n    string memory _symbol,\n    string memory _name,\n    string memory _terms,\n    uint256 _totalShares,\n    IRecoveryHub _recoveryHub,\n    address _owner,\n    Permit2Hub _permit2Hub\n  )\n    Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub, _permit2Hub)\n    ERC20Allowlistable()\n  {\n    // initialization in shares\n  }\n\n  function transfer(address recipient, uint256 amount) override(ERC20Flaggable, Shares) virtual public returns (bool) {\n    return super.transfer(recipient, amount); \n  }\n\n  function _mint(address account, uint256 amount) internal override(ERC20Flaggable, Shares) {\n      super._mint(account, amount);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Allowlistable) internal {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n  function allowance(address owner, address spender) public view override(Shares, ERC20Flaggable) returns (uint256) {\n        return super.allowance(owner,spender);\n  }\n\n}"
    },
    "src/shares/DraggableShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../draggable/ERC20Draggable.sol\";\nimport \"../ERC20/ERC20PermitLight.sol\";\nimport \"../ERC20/ERC20Permit2.sol\";\n\n/**\n * @title CompanyName AG Shares SHA\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * This is an ERC-20 token representing share tokens of CompanyName AG that are bound to\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\n */\ncontract DraggableShares is ERC20Draggable, ERC20Recoverable, ERC20PermitLight, ERC20Permit2 {\n\n    // Version history:\n    // 4: permit2\n    uint8 public constant VERSION = 4;\n\n    string public terms;\n\n    /// Event when the terms are changed with setTerms().\n    event ChangeTerms(string terms); \n\n    constructor(\n        string memory _terms,\n        DraggableParams memory _params,\n        IRecoveryHub _recoveryHub,\n        IOfferFactory _offerFactory,\n        address _oracle,\n        Permit2Hub _permit2Hub\n    )\n        ERC20Draggable(_params, _offerFactory, _oracle)\n        ERC20Recoverable(_recoveryHub)\n        ERC20PermitLight() \n        ERC20Permit2(_permit2Hub)\n\n    {\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\n        _recoveryHub.setRecoverable(false);\n    }\n\n    function transfer(address to, uint256 value) virtual override(IERC20, ERC20Flaggable, ERC20Recoverable) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Let the oracle act as deleter of invalid claims. In earlier versions, this was referring to the claim deleter\n     * of the wrapped token. But that stops working after a successful acquisition as the acquisition currency most\n     * likely does not have a claim deleter.\n     */\n    function getClaimDeleter() public view override returns (address) {\n        return oracle;\n    }\n\n    function getCollateralRate(IERC20 collateralType) public view override returns (uint256) {\n        uint256 rate = super.getCollateralRate(collateralType);\n        if (rate > 0) {\n            return rate;\n        } else {\n            // as long as it is binding, the conversion rate is 1:1\n            uint256 factor = isBinding() ? 1 : unwrapConversionFactor;\n            if (address(collateralType) == address(wrapped)) {\n                // allow wrapped token as collateral\n                return factor;\n            } else {\n                // If the wrapped contract allows for a specific collateral, we should too.\n                // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\n                return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * factor;\n            }\n        }\n    }\n\n    /**\n     * @notice This function allows the oracle to set the terms.\n     * @param _terms The new terms.\n     */\n    function setTerms(string calldata _terms) external override onlyOracle {\n        terms = _terms;\n        emit ChangeTerms(terms);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Draggable) internal {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function allowance(address owner, address spender) public view virtual override(ERC20Permit2, ERC20Flaggable, IERC20) returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n\n}"
    },
    "src/shares/DraggableSharesWithPredecessor.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./DraggableShares.sol\";\n/** \n *  \n * @dev Use this contract if you need to migrate the predecessor tokens with the majority of shares onchain.\n */\ncontract DraggableSharesWithPredecessor is DraggableShares {\n  IDraggable immutable predecessor;\n\n\n  constructor(\n    IDraggable _predecessor,\n    string memory _terms,\n    DraggableParams memory _params,\n    IRecoveryHub _recoveryHub,\n    IOfferFactory _offerFactory,\n    address _oracle,\n    Permit2Hub _permit2Hub\n  )\n    DraggableShares(_terms, _params, _recoveryHub, _offerFactory, _oracle, _permit2Hub)\n  {\n    predecessor = _predecessor;\n  }\n  \n  /**\n   * @notice This contract needs to hold the majority of the predecessor tokens.\n   */\n  function initiateMigration() external {\n    uint256 predecessorSupply = predecessor.totalSupply();\n    _mint(address(predecessor), predecessorSupply);\n    wrapped = predecessor.wrapped();\n    predecessor.migrate();\n    uint256 predecessorBalance = predecessor.balanceOf(address(this));\n    predecessor.unwrap(predecessorBalance);\n    _burn(address(this), predecessorBalance);\n    assert(predecessorSupply == totalSupply());\n  }\n}"
    },
    "src/shares/DraggableSharesWithPredecessorExternal.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./DraggableShares.sol\";\n/** \n *  \n * @dev Use this contract if you need to migrate the predecessor tokens with additional external votes.\n */\ncontract DraggableSharesWithPredecessorExternal is DraggableShares {\n  IDraggable immutable predecessor;\n\n\n  constructor(\n    IDraggable _predecessor,\n    string memory _terms,\n    DraggableParams memory _params,\n    IRecoveryHub _recoveryHub,\n    IOfferFactory _offerFactory,\n    address _oracle,\n    Permit2Hub _permit2Hub\n  )\n    DraggableShares(_terms, _params, _recoveryHub, _offerFactory, _oracle, _permit2Hub)\n  {\n    predecessor = _predecessor;\n  }\n\n  /**\n   * @notice This contract needs to hold the majority of the predecessor tokens and the this contract needs to be the oracle of the predecessor.\n   * \n   */\n  function initiateMigrationWithExternalApproval(uint256 additionalVotes) external onlyOracle {\n    uint256 predecessorSupply = predecessor.totalSupply();\n    _mint(address(predecessor), predecessorSupply);\n    wrapped = predecessor.wrapped();\n    predecessor.migrateWithExternalApproval(address(this), additionalVotes);\n    uint256 predecessorBalance = predecessor.balanceOf(address(this));\n    if (predecessorBalance > 0) {\n      predecessor.unwrap(predecessorBalance);\n      _burn(address(this), predecessorBalance);\n    }\n    assert(predecessorSupply == totalSupply());\n  }\n\n  /**\n   * @notice As the oracle on the predecessor has to be set to this contract for migration. This contract needs to be able to set the oracle on the predecessor.\n   * @param oracle The new oracle on the predecessor.\n   */\n  function setPredecessorOracle(address oracle) external onlyOracle {\n    predecessor.setOracle(oracle);\n  }\n}"
    },
    "src/shares/IShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IShares is IERC20 {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n\t//////////////////////////////////////////////////////////////*/\n\t/// New total shares can't be below current valid supply\n\t/// @param totalSupply  The current valid supply. \n\t/// @param newTotalShares  The new max shares. \n\terror Shares_InvalidTotalShares(uint256 totalSupply, uint256 newTotalShares);\n\t/// Array lengths have to be equal. \n\t/// @param targets Array length of targets. \n\t/// @param amount Array length of amounts. \n\terror Shares_UnequalLength(uint256 targets, uint256 amount);\n\t/// It isn't possible to mint more share token than max shares in existens. \n\t/// @param totalShares The max amount of shares. \n\t/// @param needed The max amount of shares needed (current valid supply + new mint amount). \n\terror Shares_InsufficientTotalShares(uint256 totalShares, uint256 needed);\n\n\tfunction burn(uint256) external;\n\n\tfunction totalShares() external view returns (uint256);\n}"
    },
    "src/shares/Shares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Named.sol\";\nimport \"../ERC20/ERC20PermitLight.sol\";\nimport \"../ERC20/ERC20Permit2.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../shares/IShares.sol\";\n\n/**\n * @title CompanyName AG Shares\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * These tokens represent ledger-based securities according to article 973d of the Swiss Code of Obligations.\n * This smart contract serves as an ownership registry, enabling the token holders to register them as\n * shareholders in the issuer's shareholder registry. This is equivalent to the traditional system\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\n * themselves. For example, in case the company pays out a dividend to a previous shareholder because\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\n * the \"wrong\" shareholder. In relation to the company, only the registered shareholders count as such.\n */\ncontract Shares is ERC20Recoverable, ERC20Named, ERC20PermitLight, ERC20Permit2, IShares{\n\n    // Version history:\n    // 1: everything before 2022-07-19\n    // 2: added mintMany and mintManyAndCall, added VERSION field\n    // 3: added permit\n    // 4: permit2\n    uint8 public constant VERSION = 4;\n\n    string public terms;\n\n    uint256 public override totalShares; // total number of shares, maybe not all tokenized\n    uint256 public invalidTokens;\n\n    event Announcement(string message);\n    event TokensDeclaredInvalid(address indexed holder, uint256 amount, string message);\n    event ChangeTerms(string terms);\n    event ChangeTotalShares(uint256 total);\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n        string memory _terms,\n        uint256 _totalShares,\n        address _owner,\n        IRecoveryHub _recoveryHub,\n        Permit2Hub _permit2Hub\n    )\n        ERC20Named(_symbol, _name, 0, _owner) \n        ERC20Recoverable(_recoveryHub)\n        ERC20PermitLight()\n        ERC20Permit2(_permit2Hub)\n    {\n        totalShares = _totalShares;\n        terms = _terms;\n        invalidTokens = 0;\n        _recoveryHub.setRecoverable(false); \n    }\n\n    function setTerms(string memory _terms) external onlyOwner {\n        terms = _terms;\n        emit ChangeTerms(_terms);\n    }\n\n    /**\n     * Declares the number of total shares, including those that have not been tokenized and those\n     * that are held by the company itself. This number can be substiantially higher than totalSupply()\n     * in case not all shares have been tokenized. Also, it can be lower than totalSupply() in case some\n     * tokens have become invalid.\n     */\n    function setTotalShares(uint256 _newTotalShares) external onlyOwner() {\n        uint256 _totalValidSupply = totalValidSupply();\n        if (_newTotalShares < _totalValidSupply) {\n            revert Shares_InvalidTotalShares(_totalValidSupply, _newTotalShares);\n            \n        }\n        totalShares = _newTotalShares;\n        emit ChangeTotalShares(_newTotalShares);\n    }\n\n    /**\n     * Allows the issuer to make public announcements that are visible on the blockchain.\n     */\n    function announcement(string calldata message) external onlyOwner() {\n        emit Announcement(message);\n    }\n\n    /**\n     * See parent method for collateral requirements.\n     */\n    function setCustomClaimCollateral(IERC20 collateral, uint256 rate) external onlyOwner() {\n        super._setCustomClaimCollateral(collateral, rate);\n    }\n\n    function getClaimDeleter() public override view returns (address) {\n        return owner;\n    }\n\n    /**\n     * Signals that the indicated tokens have been declared invalid (e.g. by a court ruling in accordance\n     * with article 973g of the Swiss Code of Obligations) and got detached from\n     * the underlying shares. Invalid tokens do not carry any shareholder rights any more.\n     *\n     * This function is purely declarative. It does not technically immobilize the affected tokens as\n     * that would give the issuer too much power.\n     */\n    function declareInvalid(address holder, uint256 amount, string calldata message) external onlyOwner() {\n        uint256 holderBalance = balanceOf(holder);\n        if (amount > holderBalance) {\n            revert ERC20InsufficientBalance(holder, holderBalance, amount);\n        }\n        invalidTokens += amount;\n        emit TokensDeclaredInvalid(holder, amount, message);\n    }\n\n    /**\n     * The total number of valid tokens in circulation. In case some tokens have been declared invalid, this\n     * number might be lower than totalSupply(). Also, it will always be lower than or equal to totalShares().\n     */\n    function totalValidSupply() public view returns (uint256) {\n        return totalSupply() - invalidTokens;\n    }\n\n    /**\n     * Allows the company to tokenize shares and transfer them e.g to the draggable contract and wrap them.\n     * If these shares are newly created, setTotalShares must be called first in order to adjust the total number of shares.\n     */\n    function mintAndCall(address shareholder, address callee, uint256 amount, bytes calldata data) external {\n        mint(callee, amount);\n        if (!IERC677Receiver(callee).onTokenTransfer(shareholder, amount, data)) {\n            revert IERC677Receiver.IERC677_OnTokenTransferFailed();\n        }\n    }\n\n    function mintManyAndCall(address[] calldata target, address callee, uint256[] calldata amount, bytes calldata data) external {\n        uint256 len = target.length;\n        if (len != amount.length) {\n            revert Shares_UnequalLength(len, amount.length);\n        }\n        uint256 total = 0;\n        for (uint256 i = 0; i<len; i++){\n            total += amount[i];\n        }\n        mint(callee, total);\n        for (uint256 i = 0; i<len; i++){\n            if(!IERC677Receiver(callee).onTokenTransfer(target[i], amount[i], data)){\n                revert IERC677Receiver.IERC677_OnTokenTransferFailed();\n            }\n        }\n    }\n\n    function mint(address target, uint256 amount) public onlyOwner {\n        _mint(target, amount);\n    }\n\n    function mintMany(address[] calldata target, uint256[] calldata amount) public onlyOwner {\n        uint256 len = target.length;\n        if (len != amount.length) {\n            revert Shares_UnequalLength(len, amount.length);\n        }\n        for (uint256 i = 0; i<len; i++){\n            _mint(target[i], amount[i]);\n        }\n    }\n\n    function _mint(address account, uint256 amount) internal virtual override {\n        uint256 newValidSupply = totalValidSupply() + amount;\n        if (newValidSupply > totalShares) {\n            revert Shares_InsufficientTotalShares(totalShares, newValidSupply);\n        }\n        super._mint(account, amount);\n    }\n\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20Flaggable, IERC20) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Transfers _amount tokens to the company and burns them.\n     * The meaning of this operation depends on the circumstances and the fate of the shares does\n     * not necessarily follow the fate of the tokens. For example, the company itself might call\n     * this function to implement a formal decision to destroy some of the outstanding shares.\n     * Also, this function might be called by an owner to return the shares to the company and\n     * get them back in another form under an according agreement (e.g. printed certificates or\n     * tokens on a different blockchain). It is not recommended to call this function without\n     * having agreed with the company on the further fate of the shares in question.\n     */\n    function burn(uint256 _amount) override external {\n        _transfer(msg.sender, address(this), _amount);\n        _burn(address(this), _amount);\n    }\n\n    function allowance(address owner, address spender) public view virtual override(ERC20Permit2, ERC20Flaggable, IERC20) returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n\n}"
    },
    "src/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n\n    /// @param target Target address to call the function on.\n    error Address_NotTransferNorContract(address target);\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n        return account.code.length > 0;\n    }\n    \n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\n        if (data.length != 0 && !isContract(target)) {\n            revert Address_NotTransferNorContract(target);\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            assembly{\n                revert (add (returndata, 0x20), mload (returndata))\n            }\n        } else {\n           revert(\"failed\");\n        }\n    }\n}"
    },
    "src/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error Ownable_NotOwner(address sender);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function _checkOwner() internal view {\n        if (msg.sender != owner) {\n            revert Ownable_NotOwner(msg.sender);\n        }\n    }\n}"
    },
    "src/utils/Permit2Hub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"../utils/Ownable.sol\";\n\n/// @title Permit2Hub\n/// @dev This contract manages the Permit2 functionality and access control.\ncontract Permit2Hub is Ownable {\n  \n  /// @dev The address of the Permit2 contract.\n  address public immutable permit2;\n  /// @dev Flag to indicate whether Permit2 is disabled.\n  bool public permit2Disabled = false;\n\n  /// @dev Mapping to track addresses for which Permit2 is disabled.\n  mapping(address => bool) public permit2DisabledForAddress;\n\n  /// @dev Emitted when the Permit2 setting is changed.\n  event ChangedPermit2(bool newSetting);\n\n  /// @dev Initializes the Permit2Hub contract with the provided Permit2 address and owner address.\n  /// @param _permit2 The address of the Permit2 contract.\n  /// @param _owner The address of the owner.\n  constructor(address _permit2, address _owner) Ownable(_owner) {\n    permit2 = _permit2;\n  }\n\n  /// @dev Checks if Permit2 is enabled for the given owner and spender addresses.\n  /// @param owner The owner address.\n  /// @param spender The spender address, needs to be the permit2 contract.\n  /// @return A boolean indicating whether Permit2 is enabled.\n  function isPermit2Enabled(address owner, address spender) public view returns (bool){\n    return spender == permit2 && !permit2Disabled && !permit2DisabledForAddress[owner];\n  }\n\n  /// @dev Toggles the global Permit2 setting. Can only be called by the owner.\n  function togglePermit2() external onlyOwner {\n    permit2Disabled = !permit2Disabled;\n    emit ChangedPermit2(permit2Disabled);\n  }\n\n  /// @dev Sets the Permit2 status for a specific address.\n  /// @param enabled The status to set for the address.\n  function setPermit2(bool enabled) external {\n    permit2DisabledForAddress[msg.sender] = !enabled;\n  }\n}\n"
    },
    "src/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"../ERC20/IERC20Permit.sol\";\nimport {Address} from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}