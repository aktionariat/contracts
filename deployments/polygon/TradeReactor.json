{
  "address": "0xd6e98a2bde37b7bca4d265429d91af5c3ca3e74a",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract SignatureTransfer",
          "name": "_transfer",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "Address_NotTransferNorContract",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TradeReactor_InvalidFiller",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TradeReactor_OfferTooLow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TradeReactor_TokenMismatch",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "filler",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint160",
          "name": "amountOut",
          "type": "uint160"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint160",
          "name": "amountIn",
          "type": "uint160"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "exp",
          "type": "uint48"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "nonce",
          "type": "uint48"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "IntentSignal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "currency",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        }
      ],
      "name": "Trade",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBrokerbot",
          "name": "bot",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "intent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "buyFromBrokerbot",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "intent",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getAsk",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "intent",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getBid",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "sellerIntent",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "buyerIntent",
          "type": "tuple"
        }
      ],
      "name": "getMaxValidAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "feeRecipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "sellerIntent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "sellerSig",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "buyerIntent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "buyerSig",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "process",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "feeRecipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "sellerIntent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "sellerSig",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "buyerIntent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "buyerSig",
          "type": "bytes"
        }
      ],
      "name": "process",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBrokerbot",
          "name": "bot",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "intent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "soldShares",
          "type": "uint256"
        }
      ],
      "name": "sellToBrokerbot",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "filler",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountOut",
              "type": "uint160"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "uint160",
              "name": "amountIn",
              "type": "uint160"
            },
            {
              "internalType": "uint48",
              "name": "expiration",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "nonce",
              "type": "uint48"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Intent",
          "name": "intent",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "signalIntent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "contract SignatureTransfer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x06bbf06d4df61b9750eb86eff370b8600627f925af47c8bf926c006d5e385f49",
  "receipt": {
    "to": null,
    "from": "0x447ffd9a116efb3d77f47802cc4869c3730f723c",
    "contractAddress": "0xd6e98a2bde37b7bca4d265429d91af5c3ca3e74a",
    "transactionIndex": "0x4f",
    "gasUsed": "0x1aa5c6",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000800000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000100000000000000000000000004000800000000000000001000000008000000000000000000000100000000000000000020000000000000000000000000000040000000000000000000000100000",
    "blockHash": "0xbc1050ac5e36ca85d444d603b2025d266329dbdad6c924d120aa14a27fc14a7b",
    "transactionHash": "0x88fc8c929e0301470c086c22b3c97fde04969a03a3b1dc613a3d98027e13ee8b",
    "logs": [
      {
        "address": "0x0000000000000000000000000000000000001010",
        "blockHash": "0xbc1050ac5e36ca85d444d603b2025d266329dbdad6c924d120aa14a27fc14a7b",
        "blockNumber": "0x3556578",
        "data": "0x000000000000000000000000000000000000000000000000016beb0496610df600000000000000000000000000000000000000000000000086d972e0d8c891a4000000000000000000000000000000000000000000001f92912d47446c86f375000000000000000000000000000000000000000000000000856d87dc426783ae000000000000000000000000000000000000000000001f929299324902e8016b",
        "logIndex": "0xe5",
        "removed": false,
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000447ffd9a116efb3d77f47802cc4869c3730f723c",
          "0x00000000000000000000000067b94473d81d0cd00849d563c94d0432ac988b49"
        ],
        "transactionHash": "0x88fc8c929e0301470c086c22b3c97fde04969a03a3b1dc613a3d98027e13ee8b",
        "transactionIndex": "0x4f"
      }
    ],
    "blockNumber": "0x3556578",
    "cumulativeGasUsed": "0x801c71",
    "status": "0x1"
  },
  "args": [
    "0x666a22cca1d155032ed2f6ae7797616ede16f21c"
  ],
  "numDeployments": 2,
  "solcInputHash": "83214f1fbffc5658be3cb2753dec8430",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract SignatureTransfer\",\"name\":\"_transfer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Address_NotTransferNorContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradeReactor_InvalidFiller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradeReactor_OfferTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradeReactor_TokenMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"exp\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"IntentSignal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IBrokerbot\",\"name\":\"bot\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyFromBrokerbot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAsk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"sellerIntent\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"buyerIntent\",\"type\":\"tuple\"}],\"name\":\"getMaxValidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"sellerIntent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"sellerSig\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"buyerIntent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"buyerSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"sellerIntent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"sellerSig\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"buyerIntent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"buyerSig\",\"type\":\"bytes\"}],\"name\":\"process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBrokerbot\",\"name\":\"bot\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"soldShares\",\"type\":\"uint256\"}],\"name\":\"sellToBrokerbot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountOut\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amountIn\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Intent\",\"name\":\"intent\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"signalIntent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"contract SignatureTransfer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract uses the SignatureTransfer contract for secure transfers with signatures.\",\"errors\":{\"Address_NotTransferNorContract(address)\":[{\"params\":{\"target\":\"Target address to call the function on.\"}}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC20 token failed.\"}]},\"events\":{\"IntentSignal(address,address,address,uint160,address,uint160,uint48,uint48,bytes,bytes)\":{\"details\":\"Emitted when an intent to trade is signaled.\",\"params\":{\"amountIn\":\"The amount of the tokenIn the owner wants to receive.\",\"amountOut\":\"The amount of the tokenOut the owner wants to sell or exchange.\",\"data\":\"Additional data that may be used in the trade execution.\",\"exp\":\"The expiration time of the intent.\",\"filler\":\"The address of the filler, if any, that the intent is specifically directed to.\",\"nonce\":\"A nonce to ensure the uniqueness of the intent.\",\"owner\":\"The address of the intent owner.\",\"signature\":\"The signature of the owner authorizing the intent.\",\"tokenIn\":\"The address of the token the owner wants to receive in exchange.\",\"tokenOut\":\"The address of the token the owner wants to sell or exchange.\"}}},\"kind\":\"dev\",\"methods\":{\"buyFromBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)\":{\"details\":\"This function allows a user to buy tokens from a Brokerbot by transferring the specified amount of investment token to the Brokerbot and receiving the purchased tokens in return. The function ensures that the offer is not too low by comparing the invested amount to the bid price.\",\"params\":{\"amount\":\"The amount of tokens to invest in the purchase.\",\"bot\":\"The Brokerbot from which tokens are being bought.\",\"intent\":\"The trade intent data structure.\",\"signature\":\"The signature of the intent owner.\"},\"returns\":{\"_0\":\"The amount of tokens received from the Brokerbot.\"}},\"getAsk((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)\":{\"details\":\"Ideally called with an intent where tokenIn is a currency with many (e.g. 18) decimals.TokenOut can have very few decimals.\",\"params\":{\"amount\":\"The amount of tokenOut.\",\"intent\":\"The trade intent data structure.\"},\"returns\":{\"_0\":\"The calculated asking price.\"}},\"getBid((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)\":{\"details\":\"Ideally called with an intent where tokenOut is a currency with many (e.g. 18) decimals.TokenIn can have very few decimals.\",\"params\":{\"amount\":\"The amount of tokenIn.\",\"intent\":\"The trade intent data structure.\"},\"returns\":{\"_0\":\"The calculated bidding price.\"}},\"getMaxValidAmount((address,address,address,uint160,address,uint160,uint48,uint48,bytes),(address,address,address,uint160,address,uint160,uint48,uint48,bytes))\":{\"params\":{\"buyerIntent\":\"The buyer's trade intent.\",\"sellerIntent\":\"The seller's trade intent.\"},\"returns\":{\"_0\":\"The maximum valid trade amount.\"}},\"process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)\":{\"params\":{\"buyerIntent\":\"The buyer's trade intent.\",\"buyerSig\":\"The buyer's signature.\",\"feeRecipient\":\"The address that will receive the fee.\",\"sellerIntent\":\"The seller's trade intent.\",\"sellerSig\":\"The seller's signature.\"}},\"process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)\":{\"params\":{\"amount\":\"The amount of the token to trade.\",\"buyerIntent\":\"The buyer's trade intent.\",\"buyerSig\":\"The buyer's signature.\",\"feeRecipient\":\"The address that will receive the fee.\",\"sellerIntent\":\"The seller's trade intent.\",\"sellerSig\":\"The seller's signature.\"}},\"sellToBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)\":{\"details\":\"This function allows a user to sell tokens to a Brokerbot by transferring the specified amount of tokens to the Brokerbot and receiving the payment in return. The function ensures that the received amount is not lower than the ask price.\",\"params\":{\"bot\":\"The Brokerbot to which tokens are being sold.\",\"intent\":\"The trade intent data structure.\",\"signature\":\"The signature of the intent owner.\",\"soldShares\":\"The amount of tokens being sold.\"},\"returns\":{\"_0\":\"The amount of payment received from the Brokerbot.\"}},\"signalIntent((address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)\":{\"params\":{\"intent\":\"The trade intent data structure. \",\"signature\":\"The signature of the intent owner.\"}}},\"title\":\"TradeReactor Contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"buyFromBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)\":{\"notice\":\"Buys tokens from a Brokerbot.\"},\"getAsk((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)\":{\"notice\":\"Calculates the asking price for a given amount of tokenOut.\"},\"getBid((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)\":{\"notice\":\"Calculates the bidding price for a given amount of tokenIn.\"},\"getMaxValidAmount((address,address,address,uint160,address,uint160,uint48,uint48,bytes),(address,address,address,uint160,address,uint160,uint48,uint48,bytes))\":{\"notice\":\"Determines the maximum valid amount that can be traded based on seller and buyer intents.\"},\"process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)\":{\"notice\":\"Processes a trade between a seller and a buyer with the maximum valid amount.\"},\"process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)\":{\"notice\":\"Processes a trade between a seller and a buyer for a specified amount.\"},\"sellToBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)\":{\"notice\":\"Sells tokens to a Brokerbot.\"},\"signalIntent((address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)\":{\"notice\":\"A function to publicly signal an intent to buy or sell a token so it can be picked up by the filler for processing. Alternaticely, the owner can directly communicate with the filler, without recording the intent on chain.\"}},\"notice\":\"This contract handles the signaling and processing of trade intents between buyers and sellers.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/brokerbot/TradeReactor.sol\":\"TradeReactor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/ERC20/IERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\",\"keccak256\":\"0x2224189bcdeb28cbadfdb8d126c278df60ec39875c7929e7ffa9e2055cded960\",\"license\":\"MIT\"},\"src/ERC20/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n\\t//////////////////////////////////////////////////////////////*/\\n    /// Block timestamp must to be before deadline.\\n    /// @param deadline The deadline of the permit.\\n    /// @param blockTimestamp The timestamp of the execution block.\\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\\n    /// Recovered address must be owner and not zero address.\\n    /// @param signerAddress The recovered signer address.\\n    error Permit_InvalidSigner(address signerAddress);\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\",\"keccak256\":\"0x9c6c4c49deffc8176f13b34150dd580526b45dd85ce1b71fe2ed340ff0489ebd\",\"license\":\"MIT\"},\"src/brokerbot/IBrokerbot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\n\\ninterface IBrokerbot {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n  //////////////////////////////////////////////////////////////*/\\n  error Brokerbot_BuyingDisabled();\\n  error Brokerbot_SellingDisabled();\\n  /// Sender(msg.sender) has to be incoming token or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_InvalidSender(address sender);\\n  /// target.call() wasn't successful.\\n  /// @param target The receiver of the Eth.\\n  /// @param amount The withdraw amount.\\n  error Brokerbot_WithdrawFailed(address target, uint256 amount);\\n  /// Sender(msg.sender) needs to be owner or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_NotAuthorized(address sender);\\n\\n  function paymenthub() external view returns (address);\\n\\n  function base() external view returns (IERC20);\\n\\n  function token() external view returns (IERC20Permit);\\n  \\n  function settings() external view returns (uint256);\\n\\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\\n\\n  function getBuyPrice(uint256 shares) external view returns (uint256);\\n\\n  function getSellPrice(uint256 shares) external view returns (uint256);\\n\\n}\",\"keccak256\":\"0xb41ad02c5b587309ecd6c84d4677d457e4cdb9f993447e97a605b10ec24de7b5\",\"license\":\"MIT\"},\"src/brokerbot/IUniswapV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied from \\n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\\n// https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IQuoter {\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n    \\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH9() external view returns (address);\\n}\\n\\ninterface ISwapRouter {\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n    \\n    function refundETH() external payable;\\n}\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\",\"keccak256\":\"0xd1fe06efa70710c24624abbfe0ed5ab69a47e9d3ec70734ea6e813711ff69784\",\"license\":\"MIT\"},\"src/brokerbot/PaymentHub.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\nimport \\\"./IUniswapV3.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\n/**\\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\\n * Instead, an allowance needs to be set only once, namely for this contract.\\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap or the reception of Ether\\n * using the current exchange rate as found in the chainlink oracle.\\n */\\ncontract PaymentHub {\\n\\n    using SafeERC20 for IERC20;\\n\\n    // Version history\\n    // Version 4: added path to pay with any ecr20 via uniswap\\n    // Version 5: added sell via permit\\n    // Version 6: added transferEther function\\n    // Version 7: added sell against eth and erc20, version, add permitinfo/swapinfo struct\\n    // Version 8: use SafeERC20 for transfers\\n    // Version 8a: remove unused vars, function for keep eth\\n    // Version 9: change payFromEther to include a swap path\\n    uint256 public constant VERSION = 9;\\n\\n    address public trustedForwarder;\\n\\n    uint24 private constant DEFAULT_FEE = 3000;\\n    IQuoter private immutable uniswapQuoter;\\n    ISwapRouter private immutable uniswapRouter;\\n\\n    struct PermitInfo {\\n        uint256 exFee;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    // event to when new forwarder is set\\n    event ForwarderChanged(address indexed _oldForwarder, address indexed _newForwarder);\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n    //////////////////////////////////////////////////////////////*/\\n    /// Failguard when an erc20 transfer returns false. \\n    error PaymentHub_TransferFailed();\\n    /// Sender not trusted.\\n    /// @param sender The msg.sender of this transaction.\\n    error PaymentHub_InvalidSender(address sender);\\n    /// swap with less base token as required.\\n    /// @param amountBase Required amount.\\n    /// @param swappedAmount Swapped amount.\\n    error PaymentHub_SwapError(uint256 amountBase, uint256 swappedAmount);\\n\\n    constructor(address _trustedForwarder, IQuoter _quoter, ISwapRouter swapRouter) {\\n        trustedForwarder = _trustedForwarder;\\n        uniswapQuoter = _quoter;\\n        uniswapRouter = swapRouter;\\n    }\\n\\n    modifier onlySellerAndForwarder(address seller) {\\n        if (msg.sender != trustedForwarder && msg.sender != seller) {\\n            revert PaymentHub_InvalidSender(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyForwarder() {\\n        if (msg.sender != trustedForwarder) {\\n            revert PaymentHub_InvalidSender(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Change the trusted forwarder.\\n     * @param newForwarder The new trusted forwarder.\\n     */\\n     function changeForwarder(address newForwarder) external onlyForwarder {\\n        trustedForwarder = newForwarder;\\n        emit ForwarderChanged(msg.sender, newForwarder);\\n    }\\n\\n    /**  \\n     * Get price in ERC20\\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\\n     * @param amountInBase The amount of the base currency for the exact output.\\n     * @param path The encoded path of the swap from erc20 to base.\\n     * @return amount quoted to pay\\n     */\\n    function getPriceInERC20(uint256 amountInBase, bytes memory path) public returns (uint256) {\\n        return getPriceERC20(amountInBase, path, true);\\n    }\\n    \\n    /**\\n     * @notice Get price for given amount and path swapped via uniswap. \\n     * @param amount The exact amount which you want get out (exactOutput) or you put in (exactInput).\\n     * @param path The path of the swap (inreverse order for exactOutput).\\n     * @param exactOutput True if exactOutput should be used or false if exactInput should be used.\\n     */\\n    function getPriceERC20(uint256 amount, bytes memory path, bool exactOutput) public returns (uint256) {\\n        if (exactOutput) {\\n            return uniswapQuoter.quoteExactOutput(\\n                path,\\n                amount\\n            );\\n        } else {\\n            return uniswapQuoter.quoteExactInput(\\n                path,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Get price in Ether via swap path (no oracle on polygon)\\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\\n     * @return The price in wei.\\n     */\\n    function getPriceInEther(uint256 amountInBase, IBrokerbot brokerBot, bytes calldata path) public returns (uint256) {\\n        return getPriceERC20(amountInBase, path, true);\\n    }\\n\\n    /**\\n     * Convenience method to swap ether into base and pay a target address\\n     */\\n    function payFromEther(address recipient, uint256 amountInBase, bytes memory path) public payable returns (uint256 amountIn) {\\n        ISwapRouter swapRouter = uniswapRouter;\\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\\n        ISwapRouter.ExactOutputParams memory params =\\n            ISwapRouter.ExactOutputParams({\\n                path: path,\\n                recipient: recipient,\\n                // solhint-disable-next-line not-rely-on-time\\n                deadline: block.timestamp,\\n                amountOut: amountInBase,\\n                amountInMaximum: msg.value\\n            });\\n\\n        // Executes the swap, returning the amountIn actually spent.\\n        amountIn = swapRouter.exactOutput{value: msg.value}(params);\\n\\n        // For exact output swaps, the amountInMaximum may not have all been spent.\\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\\n        if (amountIn < msg.value) {\\n            swapRouter.refundETH();\\n            (bool success, ) = msg.sender.call{value:msg.value - amountIn}(\\\"\\\"); // return change\\n            if (!success) {\\n                revert PaymentHub_TransferFailed();\\n            }\\n        }\\n    }\\n\\n    /// @dev The calling address must approve this contract to spend its ERC20 for this function to succeed. As the amount of input ERC20 is variable,\\n    /// the calling address will need to approve for a slightly higher or infinit amount, anticipating some variance.\\n    /// @param amountOut The desired amount of baseCurrency.\\n    /// @param amountInMaximum The maximum amount of ERC20 willing to be swapped for the specified amountOut of baseCurrency.\\n    /// @param erc20In The address of the erc20 token to pay with.\\n    /// @param path The encoded path of the swap from erc20 to base.\\n    /// @param recipient The reciving address - brokerbot.\\n    /// @return amountIn The amountIn of ERC20 actually spent to receive the desired amountOut.\\n    function payFromERC20(uint256 amountOut, uint256 amountInMaximum, address erc20In, bytes memory path, address recipient) public returns (uint256 amountIn) {\\n        ISwapRouter swapRouter = uniswapRouter;\\n        // Transfer the specified `amountInMaximum` to this contract.\\n        IERC20(erc20In).safeTransferFrom(msg.sender, address(this), amountInMaximum);\\n\\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\\n        ISwapRouter.ExactOutputParams memory params =\\n            ISwapRouter.ExactOutputParams({\\n                path: path,\\n                recipient: recipient,\\n                // solhint-disable-next-line not-rely-on-time\\n                deadline: block.timestamp,\\n                amountOut: amountOut,\\n                amountInMaximum: amountInMaximum\\n            });\\n\\n        // Executes the swap, returning the amountIn actually spent.\\n        amountIn = swapRouter.exactOutput(params);\\n\\n        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.\\n        if (amountIn < amountInMaximum) {\\n            IERC20(erc20In).safeTransfer(msg.sender, amountInMaximum - amountIn);\\n        }\\n    }\\n\\n    ///This function appoves infinite allowance for Uniswap, this is safe as the paymenthub should never hold any token (see also recover() ).\\n    ///@dev This function needs to be called before using the PaymentHub the first time with a new ERC20 token.\\n    ///@param erc20In The erc20 addresse to approve.\\n    function approveERC20(address erc20In) external {\\n        IERC20(erc20In).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    function multiPay(IERC20 token, address[] calldata recipients, uint256[] calldata amounts) public {\\n        for (uint i=0; i<recipients.length; i++) {\\n            IERC20(token).safeTransferFrom(msg.sender, recipients[i], amounts[i]);\\n        }\\n    }\\n\\n    /**\\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\\n     */\\n    function multiPayAndNotify(IERC20 token, IBrokerbot[] calldata brokerbots, uint256[] calldata amounts, bytes calldata ref) external {\\n        for (uint i=0; i<brokerbots.length; i++) {\\n            payAndNotify(token, brokerbots[i], amounts[i], ref);\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows to make a base currency payment from the sender to the brokerbot, given an allowance to this contract.\\n     * @dev Equivalent to xchf.transferAndCall(brokerbot, amountInBase)\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountInBase The amount of base currency used to buy shares.\\n     * @param ref The reference data blob.\\n     * @return The amount of shares bought\\n     */\\n    function payAndNotify(IBrokerbot brokerbot, uint256 amountInBase, bytes calldata ref) external returns (uint256) {\\n        return payAndNotify(brokerbot.base(), brokerbot, amountInBase, ref);\\n    }\\n\\n    function payAndNotify(IERC20 token, IBrokerbot brokerbot, uint256 amount, bytes calldata ref) public returns (uint256) {\\n        token.safeTransferFrom(msg.sender, address(brokerbot), amount);\\n        return brokerbot.processIncoming(token, msg.sender, amount, ref);\\n    }\\n\\n    /**\\n     * @notice Pay with Ether to buy shares.\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountBase The amount of base currency used to buy shares.\\n     * @param ref The reference data blob.\\n     * @param path The Uniswap path from ETH to base currency (uses exactOuput => reverse order)\\n     * @return priceInEther The amount of Ether spent.\\n     * @return sharesOut The amount of shares bought.\\n     */\\n    function payFromEtherAndNotify(IBrokerbot brokerbot, uint256 amountBase, bytes calldata ref, bytes memory path) external payable returns (uint256 priceInEther, uint256 sharesOut) {\\n        IERC20 base = brokerbot.base();\\n        uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\\n        priceInEther = payFromEther(address(brokerbot), amountBase, path);\\n        uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\\n        if (amountBase != (balanceAfter - balanceBefore)) { // check that the swap was successful with correct currency\\n            revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\\n        }    \\n        sharesOut = brokerbot.processIncoming(base, msg.sender, amountBase, ref); // not sending msg.value as this is already done in payFromEther function\\n    }\\n\\n    /***\\n     * @notice Pay from any ERC20 token (which has Uniswapv3 ERC20-ETH pool) and send swapped base currency to brokerbot.\\n     * @notice The needed amount needs to be approved at the ERC20 contract beforehand\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountBase The amount of base currency used to buy shares.\\n     * @param erc20 The address of the ERC20 token to pay.\\n     * @param amountInMaximum The maximum amount of the ERC20 to pay (should include some slippage).\\n     * @param path The encoded path of the swap from erc20 to base currency.\\n     * @param ref Reference data blob.\\n     * @return amountIn The amount erc20 spent to buy shares.\\n     * @return amountOut The amount of shares received by the brokerbot.\\n     */\\n    function payFromERC20AndNotify(IBrokerbot brokerbot, uint256 amountBase, address erc20, uint256 amountInMaximum, bytes memory path, bytes calldata ref) external returns (uint256 amountIn, uint256 amountOut) {\\n        IERC20 base = brokerbot.base();\\n        uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\\n        amountIn = payFromERC20(amountBase, amountInMaximum, erc20, path, address(brokerbot));\\n        uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\\n        if (amountBase != (balanceAfter - balanceBefore)) {\\n            revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\\n        }        \\n        amountOut = brokerbot.processIncoming(base, msg.sender, balanceAfter - balanceBefore, ref);\\n    }\\n\\n    /**\\n     * @notice Sell shares with permit\\n     * @param brokerbot The brokerbot to recive the shares.\\n     * @param seller The address of the seller.\\n     * @param recipient The address of the recipient of the sell preceeds.\\n     * @param amountToSell The amount the seller wants to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param permitInfo Information about the permit.\\n     * @return The base currency amount for the selling of the shares.\\n     */\\n    function sellSharesWithPermit(IBrokerbot brokerbot, IERC20Permit shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo) public onlySellerAndForwarder(seller) returns (uint256) {\\n        // Call permit to set allowance\\n        shares.permit(seller, address(this), amountToSell, permitInfo.deadline, permitInfo.v, permitInfo.r,permitInfo.s);\\n        // process sell\\n        if (permitInfo.exFee > 0){\\n            uint256 proceeds = _sellShares(brokerbot, shares, seller, address(this), amountToSell, ref);\\n            IERC20 currency = brokerbot.base();\\n            currency.safeTransfer(msg.sender, permitInfo.exFee);\\n            currency.safeTransfer(recipient, proceeds - permitInfo.exFee);\\n            return proceeds - permitInfo.exFee;\\n        } else {\\n            return _sellShares(brokerbot, shares, seller, recipient, amountToSell, ref);\\n        }\\n    }\\n\\n    /**\\n     * @notice With this function a user can sell shares with permit and swap them to a desired token.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param seller The seller address.\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param permitInfo Information about the permit.\\n     * @param params Information about the swap.\\n     * @return The output amount of the swap to the desired token.\\n     */\\n    function sellSharesWithPermitAndSwap(IBrokerbot brokerbot, IERC20Permit shares, address seller,  uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external onlySellerAndForwarder(seller) returns (uint256) {\\n        params.amountIn = sellSharesWithPermit(brokerbot, shares, seller, address(this), amountToSell, ref, permitInfo);\\n        return _swap(params, unwrapWeth);\\n    }\\n\\n    /**\\n     * @notice With this function a user can sell shares and swap them to a desired token. The user has to approve the paymenthub before on the shares contract.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param params Information about the swap.\\n     * @return The output amount of the swap to the desired token.\\n     */\\n    function sellSharesAndSwap(IBrokerbot brokerbot, IERC20 shares, uint256 amountToSell,  bytes calldata ref, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external returns (uint256) {\\n        params.amountIn = _sellShares(brokerbot, shares, msg.sender, address(this), amountToSell, ref);\\n        return _swap(params, unwrapWeth);\\n    }\\n\\n    /**\\n     * @notice Transfers shares to brokerbot and executes the selling.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param seller The seller address.\\n     * @param recipient The recipient of the base currency tokens. (this can be a 3rd party to off-ramp or the paymenthub itself if a swap will be done direct after)\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @return The base currency amount for the selling of the shares.\\n     */ \\n    function _sellShares(IBrokerbot brokerbot, IERC20 shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref ) internal returns (uint256) {\\n        // send shares token to brokerbot\\n        shares.safeTransferFrom(seller, address(brokerbot), amountToSell);\\n        // process sell on brokerbot\\n        return brokerbot.processIncoming(shares, recipient, amountToSell, ref);\\n    }\\n\\n    /**\\n     * @notice Swap (base currency) token according to given path and unwrap weth if needed.\\n     * @param params Information about the swap (includes path).\\n     * @return amountOut The output amount of the swap to the desired token.\\n     */\\n    function _swap(ISwapRouter.ExactInputParams memory params, bool unwrapWeth) internal returns(uint256 amountOut) {\\n        // if weth should be unwrapped, swap recipient is this contract and eth is send to seller\\n        if (unwrapWeth){\\n            address seller = params.recipient;\\n            params.recipient = address(this);\\n            amountOut = _swapToERC20(params);\\n            IWETH9(uniswapQuoter.WETH9()).withdraw(amountOut);\\n            (bool success, ) = payable(seller).call{value:amountOut}(\\\"\\\");\\n            if (!success) revert PaymentHub_TransferFailed();\\n        } else {\\n            amountOut = _swapToERC20(params);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calls the Uniswap router to swap tokens according to given path.\\n     * @param params Information about the swap (includes path).\\n     * @return amountOut The output amount of the swap to the desired token.\\n     */\\n    function _swapToERC20(ISwapRouter.ExactInputParams memory params) internal returns(uint256 amountOut) {\\n        amountOut = uniswapRouter.exactInput(params);\\n        if (amountOut < params.amountOutMinimum){\\n            revert PaymentHub_SwapError(params.amountOutMinimum, amountOut);\\n        }\\n    }\\n\\n    /**\\n     * @notice In case tokens have been accidentally sent directly to this contract. Only Forwarder can withdraw, else a MEV bot will intercept it.\\n     * @param ercAddress The erc20 address.\\n     * @param to The address to transfer tokens to.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function recover(IERC20 ercAddress, address to, uint256 amount) external onlyForwarder {\\n        ercAddress.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer ether to a given address. Only Forwarder can withdraw, else a MEV bot will intercept it.\\n     * @param to The address to transfer ether to.\\n     */\\n    function withdrawEther(address to, uint256 amount) external onlyForwarder {\\n        (bool success, ) = payable(to).call{value:amount}(\\\"\\\");\\n        if (!success) {\\n            revert PaymentHub_TransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer ether to a given address.\\n     * @dev Used with the mutlisigwallet.\\n     * @param to The address to transfer ether to.\\n     */\\n    function transferEther(address to) external payable {\\n        (bool success, ) = payable(to).call{value:msg.value}(\\\"\\\");\\n        if (!success) {\\n            revert PaymentHub_TransferFailed();\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {\\n        // Important to receive ETH refund from Uniswap\\n    }\\n}\\n\",\"keccak256\":\"0xeec6c626113c05a8184399686ee6ca86b7a42fa09038fb40283c6647cfe1c619\",\"license\":\"LicenseRef-Aktionariat\"},\"src/brokerbot/TradeReactor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {SignatureTransfer} from \\\"../lib/SignatureTransfer.sol\\\";\\nimport {ISignatureTransfer} from \\\"../lib/ISignatureTransfer.sol\\\";\\nimport {IERC20Permit} from \\\"../ERC20/IERC20Permit.sol\\\";\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {Intent, IntentHash} from \\\"../lib/IntentHash.sol\\\";\\nimport {PaymentHub} from \\\"./PaymentHub.sol\\\";\\nimport {IBrokerbot} from \\\"./IBrokerbot.sol\\\";\\nimport {SafeERC20} from \\\"../utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title TradeReactor Contract\\n * @notice This contract handles the signaling and processing of trade intents between buyers and sellers.\\n * @dev This contract uses the SignatureTransfer contract for secure transfers with signatures.\\n*/\\ncontract TradeReactor {\\n\\n    using IntentHash for Intent;\\n    using SafeERC20 for IERC20;\\n\\n    error TradeReactor_OfferTooLow();\\n    error TradeReactor_InvalidFiller();\\n    error TradeReactor_TokenMismatch();\\n\\n    // copied from brokerbot for compatibility\\n    event Trade(address seller, address buyer, address indexed token, uint amount, address currency, uint price, uint fee);\\n\\n    /// @dev Emitted when an intent to trade is signaled.\\n    /// @param owner The address of the intent owner.\\n    /// @param filler The address of the filler, if any, that the intent is specifically directed to.\\n    /// @param tokenOut The address of the token the owner wants to sell or exchange.\\n    /// @param amountOut The amount of the tokenOut the owner wants to sell or exchange.\\n    /// @param tokenIn The address of the token the owner wants to receive in exchange.\\n    /// @param amountIn The amount of the tokenIn the owner wants to receive.\\n    /// @param exp The expiration time of the intent.\\n    /// @param nonce A nonce to ensure the uniqueness of the intent.\\n    /// @param data Additional data that may be used in the trade execution.\\n    /// @param signature The signature of the owner authorizing the intent.\\n    event IntentSignal(address owner, address filler, address tokenOut, uint160 amountOut, address tokenIn, uint160 amountIn, uint48 exp, uint48 nonce, bytes data, bytes signature);\\n\\n    SignatureTransfer immutable public transfer;\\n\\n    constructor(SignatureTransfer _transfer){\\n        transfer = _transfer;\\n    }\\n\\n    /**\\n     * @notice A function to publicly signal an intent to buy or sell a token so it can be picked up by the filler for processing.\\n     * Alternaticely, the owner can directly communicate with the filler, without recording the intent on chain.\\n     * @param intent The trade intent data structure. \\n     * @param signature The signature of the intent owner.\\n    */\\n    function signalIntent(Intent calldata intent, bytes calldata signature) external {\\n        emit IntentSignal(intent.owner, intent.filler, intent.tokenOut, intent.amountOut, intent.tokenIn, intent.amountIn, intent.expiration, intent.nonce, intent.data, signature);\\n    }\\n\\n    /**\\n     * @notice Calculates the asking price for a given amount of tokenOut.\\n     * @dev Ideally called with an intent where tokenIn is a currency with many (e.g. 18) decimals.\\n     * @dev TokenOut can have very few decimals.\\n     * @param intent The trade intent data structure.\\n     * @param amount The amount of tokenOut.\\n     * @return The calculated asking price.\\n     */\\n    function getAsk(Intent calldata intent, uint256 amount) public pure returns (uint256) {\\n        // We should make sure that the rounding is always for the benefit of the intent owner to prevent exploits\\n        // Example: when the seller offers to sell 7 ABC for 10 CHF, the accurate price would be 4.2857....\\n        // The naive approach to calculate the same price using integers would be 3 * 10 / 7 = 3\\n        // But with the given approach, we get 10 - (7 - 3) * 10 / 7 = 5, which is higher than tha accurate price.\\n        return intent.amountIn - intent.amountIn * (intent.amountOut - amount) / intent.amountOut;\\n    }\\n\\n    /**\\n     * @notice Calculates the bidding price for a given amount of tokenIn.\\n     * @dev Ideally called with an intent where tokenOut is a currency with many (e.g. 18) decimals.\\n     * @dev TokenIn can have very few decimals.\\n     * @param intent The trade intent data structure.\\n     * @param amount The amount of tokenIn.\\n     * @return The calculated bidding price.\\n     */\\n    function getBid(Intent calldata intent, uint256 amount) public pure returns (uint256) {\\n        // We should make sure that the rounding is always for the benefit of the intent owner to prevent exploits\\n        // Example: when the buyer offers to buy 7 ABC for 10 CHF, but only 3 can be filled, the accurate price would be 4.2857....\\n        // With this calculation, we get a rounded down bid of 10 * 3 / 7 = 4\\n        return intent.amountOut * amount / intent.amountIn;\\n    }\\n\\n    /**\\n     * @notice Determines the maximum valid amount that can be traded based on seller and buyer intents.\\n     * @param sellerIntent The seller's trade intent.\\n     * @param buyerIntent The buyer's trade intent.\\n     * @return The maximum valid trade amount.\\n     */\\n    function getMaxValidAmount(Intent calldata sellerIntent, Intent calldata buyerIntent) public view returns (uint256) {\\n        uint256 sellerAvailable = transfer.getPermittedAmount(sellerIntent.owner, toPermit(sellerIntent));\\n        uint256 buyerAvailable = transfer.getPermittedAmount(buyerIntent.owner, toPermit(buyerIntent));\\n        uint256 biddingFor = buyerIntent.amountIn * buyerAvailable / buyerIntent.amountOut;\\n        uint256 maxAmount = biddingFor > sellerAvailable ? sellerAvailable : biddingFor;\\n        uint256 ask = getAsk(sellerIntent, maxAmount);\\n        uint256 bid = getBid(buyerIntent, maxAmount);\\n        if (bid < ask) revert TradeReactor_OfferTooLow();\\n        return maxAmount;\\n    }\\n\\n    /**\\n     * @notice Processes a trade between a seller and a buyer with the maximum valid amount.\\n     * @param feeRecipient The address that will receive the fee.\\n     * @param sellerIntent The seller's trade intent.\\n     * @param sellerSig The seller's signature.\\n     * @param buyerIntent The buyer's trade intent.\\n     * @param buyerSig The buyer's signature.\\n     */    \\n    function process(address feeRecipient, Intent calldata sellerIntent, bytes calldata sellerSig, Intent calldata buyerIntent, bytes calldata buyerSig) external {\\n        process(feeRecipient, sellerIntent, sellerSig, buyerIntent, buyerSig, getMaxValidAmount(sellerIntent, buyerIntent));\\n    }\\n\\n    /**\\n     * @notice Processes a trade between a seller and a buyer for a specified amount.\\n     * @param feeRecipient The address that will receive the fee.\\n     * @param sellerIntent The seller's trade intent.\\n     * @param sellerSig The seller's signature.\\n     * @param buyerIntent The buyer's trade intent.\\n     * @param buyerSig The buyer's signature.\\n     * @param amount The amount of the token to trade.\\n     */\\n    function process(address feeRecipient, Intent calldata sellerIntent, bytes calldata sellerSig, Intent calldata buyerIntent, bytes calldata buyerSig, uint256 amount) public {\\n        // signatures will be verified in SignatureTransfer\\n        if (sellerIntent.tokenOut != buyerIntent.tokenIn || sellerIntent.tokenIn != buyerIntent.tokenOut) revert TradeReactor_TokenMismatch();\\n        if (sellerIntent.filler != address(0x0) && sellerIntent.filler != msg.sender) revert TradeReactor_InvalidFiller();\\n        if (buyerIntent.filler != address(0x0) && buyerIntent.filler != msg.sender) revert TradeReactor_InvalidFiller();\\n        uint256 ask = getAsk(sellerIntent, amount);\\n        uint256 bid = getBid(buyerIntent, amount);\\n        if (bid < ask) revert TradeReactor_OfferTooLow();\\n        // move tokens to reactor in order to implicitly allowlist target address in case reactor is powerlisted\\n        transfer.permitWitnessTransferFrom(toPermit(sellerIntent), toDetails(address(this), amount), sellerIntent.owner, sellerIntent.hash(), IntentHash.PERMIT2_INTENT_TYPE, sellerSig);\\n        transfer.permitWitnessTransferFrom(toPermit(buyerIntent), toDetails(address(this), bid), buyerIntent.owner, buyerIntent.hash(), IntentHash.PERMIT2_INTENT_TYPE, buyerSig);\\n        // move tokens to target addresses\\n        IERC20(sellerIntent.tokenOut).safeTransfer(buyerIntent.owner, amount);\\n        IERC20(sellerIntent.tokenIn).safeTransfer(sellerIntent.owner, ask);\\n        IERC20(sellerIntent.tokenIn).safeTransfer(feeRecipient, bid - ask); // collect spread as fee\\n        emit Trade(sellerIntent.owner, buyerIntent.owner, sellerIntent.tokenOut, amount, sellerIntent.tokenIn, ask, bid - ask);\\n    }\\n\\n    /**\\n     * @notice Buys tokens from a Brokerbot.\\n     * @dev This function allows a user to buy tokens from a Brokerbot by transferring the specified amount of investment token to the Brokerbot and receiving the purchased tokens in return. The function ensures that the offer is not too low by comparing the invested amount to the bid price.\\n     * @param bot The Brokerbot from which tokens are being bought.\\n     * @param intent The trade intent data structure.\\n     * @param signature The signature of the intent owner.\\n     * @param amount The amount of tokens to invest in the purchase.\\n     * @return The amount of tokens received from the Brokerbot.\\n     */\\n    function buyFromBrokerbot(IBrokerbot bot, Intent calldata intent, bytes calldata signature, uint256 amount) external returns (uint256) {\\n        PaymentHub hub = PaymentHub(payable(bot.paymenthub()));\\n        transfer.permitWitnessTransferFrom(toPermit(intent), toDetails(address(this), amount), intent.owner, intent.hash(), IntentHash.PERMIT2_INTENT_TYPE, signature);\\n        IERC20(intent.tokenOut).approve(address(hub), amount);\\n        uint256 received = hub.payAndNotify(bot, amount, intent.data);\\n        if (amount > getBid(intent, received)) revert TradeReactor_OfferTooLow();\\n        IERC20(intent.tokenIn).safeTransfer(intent.owner, received);\\n        IERC20(intent.tokenOut).safeTransfer(intent.owner, IERC20(intent.tokenOut).balanceOf(address(this))); // refund over paid amount\\n        return received;\\n    }\\n\\n    /**\\n     * @notice Sells tokens to a Brokerbot.\\n     * @dev This function allows a user to sell tokens to a Brokerbot by transferring the specified amount of tokens to the Brokerbot and receiving the payment in return. The function ensures that the received amount is not lower than the ask price.\\n     * @param bot The Brokerbot to which tokens are being sold.\\n     * @param intent The trade intent data structure.\\n     * @param signature The signature of the intent owner.\\n     * @param soldShares The amount of tokens being sold.\\n     * @return The amount of payment received from the Brokerbot.\\n     */\\n    function sellToBrokerbot(IBrokerbot bot, Intent calldata intent, bytes calldata signature, uint256 soldShares)public returns (uint256) {\\n        PaymentHub hub = PaymentHub(payable(bot.paymenthub()));\\n        transfer.permitWitnessTransferFrom(toPermit(intent), toDetails(address(this), soldShares), intent.owner, intent.hash(), IntentHash.PERMIT2_INTENT_TYPE, signature);\\n        IERC20(intent.tokenOut).approve(address(hub), soldShares);\\n        uint256 received = hub.payAndNotify(IERC20(intent.tokenOut), bot, soldShares, intent.data);\\n        if (received < getAsk(intent, soldShares)) revert TradeReactor_OfferTooLow();\\n        IERC20(intent.tokenIn).safeTransfer(intent.owner, received);\\n        return received;\\n    }\\n\\n    function toDetails(address recipient, uint256 amount) internal pure returns (ISignatureTransfer.SignatureTransferDetails memory){\\n        return ISignatureTransfer.SignatureTransferDetails({to: recipient, requestedAmount: amount});\\n    }\\n \\n    function toPermit(Intent memory intent) internal pure returns (ISignatureTransfer.PermitTransferFrom memory) {\\n        return ISignatureTransfer.PermitTransferFrom({\\n            permitted: ISignatureTransfer.TokenPermissions({\\n                token: address(intent.tokenOut),\\n                amount: intent.amountOut\\n            }),\\n            nonce: intent.nonce,\\n            deadline: intent.expiration\\n        });\\n    }\\n\\n}\",\"keccak256\":\"0x5f3d9d8eaffc9b0a4a8cbf7b734966929b417cf7a9b813f10499c5bb504b530f\",\"license\":\"MIT\"},\"src/lib/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\n\\n/// @notice EIP712 helpers for permit2\\n/// @dev Maintains cross-chain replay protection in the event of a fork\\n/// @dev Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol\\ncontract EIP712 {\\n    // Cache the domain separator as an immutable value, but also store the chain id that it\\n    // corresponds to, in order to invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private constant _HASHED_NAME = keccak256(\\\"Permit2\\\"); // TODO: what name should we use here?\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    constructor() {\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME);\\n    }\\n\\n    /// @notice Returns the domain separator for the current chain.\\n    /// @dev Uses cached version if chainid and address are unchanged from construction.\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        return block.chainid == _CACHED_CHAIN_ID\\n            ? _CACHED_DOMAIN_SEPARATOR\\n            : _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME);\\n    }\\n\\n    /// @notice Builds a domain separator using the current chainId and contract address.\\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 nameHash) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, block.chainid, address(this)));\\n    }\\n\\n    /// @notice Creates an EIP-712 typed data hash\\n    function _hashTypedData(bytes32 dataHash) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), dataHash));\\n    }\\n}\",\"keccak256\":\"0x462809d614ef3ff0f66b648b6f42a1fdeaddfd9d67a8ebb31892b841d55035e7\",\"license\":\"MIT\"},\"src/lib/ISignatureTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SignatureTransfer\\n/// @notice Handles ERC20 token transfers through signature based actions\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface ISignatureTransfer {\\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\\n    /// @param maxAmount The maximum amount a spender can request to transfer\\n    error InvalidAmount(uint256 maxAmount);\\n\\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\\n    error LengthMismatch();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\\n\\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\\n    struct TokenPermissions {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount that can be spent\\n        uint256 amount;\\n    }\\n\\n    /// @notice The signed permit message for a single token transfer\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Specifies the recipient address and amount for batched transfers.\\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\\n    struct SignatureTransferDetails {\\n        // recipient address\\n        address to;\\n        // spender requested amount\\n        uint256 requestedAmount;\\n    }\\n\\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\\n    /// @dev It returns a uint256 bitmap\\n    /// @dev The index, or wordPosition is capped at type(uint248).max\\n    function nonceBitmap(address, uint256) external view returns (uint256);\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n\\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\\n    /// @dev The wordPos is maxed at type(uint248).max\\n    /// @param wordPos A number to index the nonceBitmap at\\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\\n}\",\"keccak256\":\"0x86104c66cc0214eb509507b3c4f8d01867a4c6ccf438ed2ec8290894b97d90a9\",\"license\":\"MIT\"},\"src/lib/IntentHash.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {PermitHash} from \\\"./PermitHash.sol\\\";\\n\\nstruct Intent {\\n\\taddress owner;\\n\\taddress filler;\\n\\taddress tokenOut; // The ERC20 token sent out\\n\\tuint160 amountOut; // The maximum amount\\n\\taddress tokenIn; // The ERC20 token received\\n\\tuint160 amountIn; // The amount received in exchange for the maximum of the sent token\\n\\tuint48 expiration; // timestamp at which the intent expires\\n\\tuint48 nonce; // a unique value indexed per owner,token,and spender for each signature\\n\\tbytes data;\\n}\\n\\n/// @notice helpers for handling dutch order objects\\nlibrary IntentHash {\\n\\n\\tbytes internal constant INTENT_TYPE =\\n\\t\\tabi.encodePacked(\\n\\t\\t\\t\\\"Intent(\\\",\\n\\t\\t\\t\\\"address owner,\\\",\\n\\t\\t\\t\\\"address filler,\\\",\\n\\t\\t\\t\\\"address tokenOut,\\\",\\n\\t\\t\\t\\\"uint160 amountOut,\\\",\\n\\t\\t\\t\\\"address tokenIn,\\\",\\n\\t\\t\\t\\\"uint160 amountIn,\\\",\\n\\t\\t\\t\\\"uint48 expiration,\\\",\\n\\t\\t\\t\\\"uint48 nonce,\\\",\\n\\t\\t\\t\\\"bytes data)\\\"\\n\\t\\t);\\n\\n\\tbytes32 internal constant INTENT_TYPE_HASH = keccak256(INTENT_TYPE);\\n\\n\\tstring internal constant PERMIT2_INTENT_TYPE =\\n        string(abi.encodePacked(\\\"Intent witness)\\\", INTENT_TYPE, PermitHash._TOKEN_PERMISSIONS_TYPESTRING));\\n\\n\\t/// @notice hash the given intent\\n\\t/// @param intent the intent to hash\\n\\t/// @return the eip-712 intent hash\\n\\tfunction hash(Intent calldata intent) internal pure returns (bytes32) {\\n\\t\\treturn\\n\\t\\t\\tkeccak256(\\n\\t\\t\\t\\tabi.encode(\\n\\t\\t\\t\\t\\tINTENT_TYPE_HASH,\\n\\t\\t\\t\\t\\tintent.owner,\\n\\t\\t\\t\\t\\tintent.filler,\\n\\t\\t\\t\\t\\tintent.tokenOut,\\n\\t\\t\\t\\t\\tintent.amountOut,\\n\\t\\t\\t\\t\\tintent.tokenIn,\\n\\t\\t\\t\\t\\tintent.amountIn,\\n\\t\\t\\t\\t\\tintent.expiration,\\n\\t\\t\\t\\t\\tintent.nonce,\\n\\t\\t\\t\\t\\tkeccak256(intent.data)\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t}\\n}\\n\",\"keccak256\":\"0xd04db21a5713fd2ab5e5d33fe19088a7f90b4bac1bc93f67fd6484fbbb155c1f\",\"license\":\"GPL-2.0-or-later\"},\"src/lib/PermitHash.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\nimport {ISignatureTransfer} from \\\"./ISignatureTransfer.sol\\\";\\n\\nlibrary PermitHash {\\n    bytes32 public constant _TOKEN_PERMISSIONS_TYPEHASH = keccak256(\\\"TokenPermissions(address token,uint256 amount)\\\");\\n\\n    bytes32 public constant _PERMIT_TRANSFER_FROM_TYPEHASH = keccak256(\\n        \\\"PermitTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline)TokenPermissions(address token,uint256 amount)\\\"\\n    );\\n\\n    string public constant _TOKEN_PERMISSIONS_TYPESTRING = \\\"TokenPermissions(address token,uint256 amount)\\\";\\n\\n    string public constant _PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB =\\n        \\\"PermitWitnessTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline,\\\";\\n\\n    function hash(ISignatureTransfer.PermitTransferFrom memory permit) internal view returns (bytes32) {\\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(permit.permitted);\\n        return keccak256(\\n            abi.encode(_PERMIT_TRANSFER_FROM_TYPEHASH, tokenPermissionsHash, msg.sender, permit.nonce, permit.deadline)\\n        );\\n    }\\n\\n    function hashWithWitness(\\n        ISignatureTransfer.PermitTransferFrom memory permit,\\n        bytes32 witness,\\n        string calldata witnessTypeString\\n    ) internal view returns (bytes32) {\\n        bytes32 typeHash = keccak256(abi.encodePacked(_PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB, witnessTypeString));\\n\\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(permit.permitted);\\n        return keccak256(abi.encode(typeHash, tokenPermissionsHash, msg.sender, permit.nonce, permit.deadline, witness));\\n    }\\n\\n    function _hashTokenPermissions(ISignatureTransfer.TokenPermissions memory permitted)\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_TOKEN_PERMISSIONS_TYPEHASH, permitted));\\n    }\\n}\",\"keccak256\":\"0xfd0a203be91915f92f91cc911b8d2d193becc75879506a80cef03c5545d5555c\",\"license\":\"MIT\"},\"src/lib/SignatureTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\nimport {ISignatureTransfer} from \\\"./ISignatureTransfer.sol\\\";\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {SignatureVerification} from \\\"./SignatureVerification.sol\\\";\\nimport {PermitHash} from \\\"./PermitHash.sol\\\";\\nimport {EIP712} from \\\"./EIP712.sol\\\";\\n\\ncontract SignatureTransfer is ISignatureTransfer, EIP712 {\\n\\n    using SignatureVerification for bytes;\\n    using PermitHash for PermitTransferFrom;\\n\\n    /// @inheritdoc ISignatureTransfer\\n    mapping(address => mapping(uint256 => uint256)) public nonceBitmap;\\n    mapping(address => mapping(uint256 => uint256)) public partialFills;\\n\\n    /// @notice Thrown when validating an inputted signature that is stale\\n    /// @param signatureDeadline The timestamp at which a signature is no longer valid\\n    error SignatureExpired(uint256 signatureDeadline);\\n\\n    /// @notice Thrown when validating that the inputted nonce has not been used\\n    error InvalidNonce();\\n\\n    error OverFilled();\\n\\n    function permitTransferFrom(PermitTransferFrom memory permit, SignatureTransferDetails calldata transferDetails, address owner, bytes calldata signature) external {\\n        _permitTransferFrom(permit, transferDetails, owner, permit.hash(), signature);\\n    }\\n\\n    /// @inheritdoc ISignatureTransfer\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external {\\n        _permitTransferFrom(permit, transferDetails, owner, permit.hashWithWitness(witness, witnessTypeString), signature);\\n    }\\n\\n    /**\\n     * Find a nonce that looks free given the data on the blockchain.\\n     * Of course, this method cannot take into account nonces of valid but unused permits.\\n     */\\n    function findFreeNonce(address owner, uint256 start) public view returns (uint256){\\n        while (!isFreeNonce(owner, start)){\\n            start++;\\n        }\\n        return start;\\n    }\\n\\n    function isFreeNonce(address owner, uint256 nonce) public view returns (bool){\\n        return !isUsedNonce(owner, nonce) && partialFills[owner][nonce] == 0;\\n    }\\n\\n    function isUsedNonce(address owner, uint256 nonce) public view returns (bool) {\\n        (uint256 wordPos, uint256 bitPos) = bitmapPositions(nonce);\\n        uint256 bit = 1 << bitPos;\\n        return nonceBitmap[owner][wordPos] & bit != 0;\\n    }\\n\\n    function getPermittedAmount(address owner, PermitTransferFrom calldata permit) public view returns (uint256) {\\n        if (isUsedNonce(owner, permit.nonce)) {\\n            return 0;\\n        } else {\\n            return permit.permitted.amount - partialFills[owner][permit.nonce];\\n        }\\n    }\\n\\n    /// @notice Transfers a token using a signed permit message.\\n    /// @param permit The permit data signed over by the owner\\n    /// @param dataHash The EIP-712 hash of permit data to include when checking signature\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function _permitTransferFrom(PermitTransferFrom memory permit, SignatureTransferDetails calldata transferDetails, address owner, bytes32 dataHash, bytes calldata signature) private {\\n        uint256 requestedAmount = transferDetails.requestedAmount;\\n\\n        if (block.timestamp > permit.deadline) revert SignatureExpired(permit.deadline);\\n\\n        _useUnorderedNonce(owner, permit.nonce, requestedAmount, permit.permitted.amount);\\n\\n        signature.verify(_hashTypedData(dataHash), owner);\\n\\n        IERC20(permit.permitted.token).transferFrom(owner, transferDetails.to, requestedAmount);\\n    }\\n\\n    /// @inheritdoc ISignatureTransfer\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external {\\n        nonceBitmap[msg.sender][wordPos] |= mask;\\n\\n        emit UnorderedNonceInvalidation(msg.sender, wordPos, mask);\\n    }\\n\\n    /// @notice Returns the index of the bitmap and the bit position within the bitmap. Used for unordered nonces\\n    /// @param nonce The nonce to get the associated word and bit positions\\n    /// @return wordPos The word position or index into the nonceBitmap\\n    /// @return bitPos The bit position\\n    /// @dev The first 248 bits of the nonce value is the index of the desired bitmap\\n    /// @dev The last 8 bits of the nonce value is the position of the bit in the bitmap\\n    function bitmapPositions(uint256 nonce) private pure returns (uint256 wordPos, uint256 bitPos) {\\n        wordPos = uint248(nonce >> 8);\\n        bitPos = uint8(nonce);\\n    }\\n\\n    /// @notice Checks whether a nonce is taken and sets the bit at the bit position in the bitmap at the word position\\n    /// @dev This function is used to manage nonces for transactions, ensuring that each nonce is used only once and tracking partial fills of orders.\\n    /// @param from The address to use the nonce at\\n    /// @param nonce The nonce to spend\\n    /// @param amount The amount being filled in the current transaction.\\n    /// @param max The maximum allowable fill amount for the nonce.\\n    function _useUnorderedNonce(address from, uint256 nonce, uint256 amount, uint256 max) internal {\\n        (uint256 wordPos, uint256 bitPos) = bitmapPositions(nonce);\\n        uint256 bit = 1 << bitPos;\\n        uint256 state = nonceBitmap[from][wordPos];\\n        if (state & bit != 0) revert InvalidNonce();\\n\\n        uint256 alreadyFilled = partialFills[from][nonce];\\n        if (alreadyFilled + amount > max) revert OverFilled();\\n        if (alreadyFilled + amount < max){\\n            partialFills[from][nonce] = alreadyFilled + amount;\\n        } else {\\n            if (alreadyFilled > 0) delete partialFills[from][nonce]; // get some gas back \\n            nonceBitmap[from][wordPos] |= bit; // flag done\\n        }\\n    }\\n}\",\"keccak256\":\"0xb2d92592e17b5dafbfdccacdab01f40a8dfbf23f5e8b358bb8063626e696bfe7\",\"license\":\"MIT\"},\"src/lib/SignatureVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Copied from github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol and modified.\\n */\\nlibrary SignatureVerification {\\n    /// @notice Thrown when the passed in signature is not a valid length\\n    error InvalidSignatureLength();\\n\\n    /// @notice Thrown when the recovered signer is equal to the zero address\\n    error InvalidSignature();\\n\\n    /// @notice Thrown when the recovered signer does not equal the claimedSigner\\n    error InvalidSigner();\\n\\n    /// @notice Thrown when the recovered contract signature is incorrect\\n    error InvalidContractSignature();\\n\\n    bytes32 constant UPPER_BIT_MASK = (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n\\n    function verify(bytes calldata signature, bytes32 hash, address claimedSigner) internal view {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (claimedSigner.code.length == 0) {\\n            if (signature.length == 65) {\\n                (r, s) = abi.decode(signature, (bytes32, bytes32));\\n                v = uint8(signature[64]);\\n            } else if (signature.length == 64) {\\n                // EIP-2098\\n                bytes32 vs;\\n                (r, vs) = abi.decode(signature, (bytes32, bytes32));\\n                s = vs & UPPER_BIT_MASK;\\n                v = uint8(uint256(vs >> 255)) + 27;\\n            } else {\\n                revert InvalidSignatureLength();\\n            }\\n            address signer = ecrecover(hash, v, r, s);\\n            if (signer == address(0)) revert InvalidSignature();\\n            if (signer != claimedSigner) revert InvalidSigner();\\n        } else {\\n            bytes4 magicValue = IERC1271(claimedSigner).isValidSignature(hash, signature);\\n            if (magicValue != IERC1271.isValidSignature.selector) revert InvalidContractSignature();\\n        }\\n    }\\n}\\n\\ninterface IERC1271 {\\n    /// @dev Should return whether the signature provided is valid for the provided data\\n    /// @param hash      Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\",\"keccak256\":\"0x0a7e2a987eff6d4e75094eb0cd01c4db7c7ad287fb848d6ee802cdd6299345d9\",\"license\":\"MIT\"},\"src/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n// and modified it.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Address {\\n\\n    /// @param target Target address to call the function on.\\n    error Address_NotTransferNorContract(address target);\\n\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n        return account.code.length > 0;\\n    }\\n    \\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\\n        if (data.length != 0 && !isContract(target)) {\\n            revert Address_NotTransferNorContract(target);\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else if (returndata.length > 0) {\\n            assembly{\\n                revert (add (returndata, 0x20), mload (returndata))\\n            }\\n        } else {\\n           revert(\\\"failed\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0xb95d45875550203c1afb7dfc9c99ce62c77496c36e96f3adfaad2d42cb3380a2\",\"license\":\"MIT\"},\"src/utils/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n//\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n//\\n// Modifications:\\n// - Replaced Context._msgSender() with msg.sender\\n// - Made leaner\\n// - Extracted interface\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    error Ownable_NotOwner(address sender);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor (address initialOwner) {\\n        owner = initialOwner;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function _checkOwner() internal view {\\n        if (msg.sender != owner) {\\n            revert Ownable_NotOwner(msg.sender);\\n        }\\n    }\\n}\",\"keccak256\":\"0x9057578671d192c7891a59854cf8bab2698450c5b271f21e0696036fb65cae3b\",\"license\":\"MIT\"},\"src/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../ERC20/IERC20Permit.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        if (nonceAfter != nonceBefore + 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\",\"keccak256\":\"0xa162e550fe203915126fddc231c55d28dd3f16d39be22dd48c5fc7f5ccd6fd93\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a0604052348015600f57600080fd5b50604051611f4c380380611f4c833981016040819052602c91603c565b6001600160a01b0316608052606a565b600060208284031215604d57600080fd5b81516001600160a01b0381168114606357600080fd5b9392505050565b608051611e9d6100af60003960008181610137015281816102720152818161039901528181610550015281816109e801528181610ae40152610d970152611e9d6000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c80633eae8237116100665780633eae8237146100f75780634e03ba4b1461010c578063548d40511461011f5780638a4068dd14610132578063befbde5d1461017157600080fd5b806305cc7606146100985780631424404e146100be578063214fe96c146100d1578063294623ce146100e4575b600080fd5b6100ab6100a636600461141c565b610184565b6040519081526020015b60405180910390f35b6100ab6100cc36600461141c565b6101d6565b6100ab6100df366004611461565b610265565b6100ab6100f2366004611526565b6104df565b61010a6101053660046115b7565b610856565b005b61010a61011a366004611688565b610d09565b6100ab61012d366004611526565b610d26565b6101597f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100b5565b61010a61017f366004611754565b610fe8565b600061019660c0840160a085016117bd565b6001600160a01b0316826101b060808601606087016117bd565b6001600160a01b03166101c391906117f0565b6101cd9190611807565b90505b92915050565b60006101e860808401606085016117bd565b6001600160a01b03168261020260808601606087016117bd565b6001600160a01b03166102159190611829565b61022560c0860160a087016117bd565b6001600160a01b031661023891906117f0565b6102429190611807565b61025260c0850160a086016117bd565b6001600160a01b03166101cd9190611829565b6000806001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016639f0982936102a460208701876117bd565b61032d6102b08861191f565b6040805160a0810182526000606082018181526080830182905282526020820181905291810191909152506040805160a081018252828201516001600160a01b0390811660608084019182528501519091166080830152815260e083015165ffffffffffff908116602083015260c0909301519092169082015290565b6040518363ffffffff1660e01b815260040161034a929190611a28565b602060405180830381865afa158015610367573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038b9190611a45565b905060006001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016639f0982936103cb60208701876117bd565b6103d76102b08861191f565b6040518363ffffffff1660e01b81526004016103f4929190611a28565b602060405180830381865afa158015610411573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104359190611a45565b9050600061044960808601606087016117bd565b6001600160a01b03168261046360c0880160a089016117bd565b6001600160a01b031661047691906117f0565b6104809190611807565b905060008382116104915781610493565b835b905060006104a188836101d6565b905060006104af8884610184565b9050818110156104d257604051633c4d934560e21b815260040160405180910390fd5b5090979650505050505050565b600080866001600160a01b031663777adcf06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610520573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105449190611a5e565b90506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663137c29fe6105816102b08961191f565b61058b30876110bc565b61059860208b018b6117bd565b6105a18b6110ed565b6040516020016105b090611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a60208301396040516020016105e5929190611b8e565b6040516020818303038152906040528b8b6040518863ffffffff1660e01b81526004016106189796959493929190611c04565b600060405180830381600087803b15801561063257600080fd5b505af1158015610646573d6000803e3d6000fd5b5061065b9250505060608701604088016117bd565b60405163095ea7b360e01b81526001600160a01b03838116600483015260248201869052919091169063095ea7b3906044016020604051808303816000875af11580156106ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d09190611c97565b5060006001600160a01b0382166317f565d289866106f26101008c018c611cb9565b6040518563ffffffff1660e01b81526004016107119493929190611d00565b6020604051808303816000875af1158015610730573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107549190611a45565b90506107608782610184565b84111561078057604051633c4d934560e21b815260040160405180910390fd5b6107b161079060208901896117bd565b826107a160a08b0160808c016117bd565b6001600160a01b0316919061123d565b61084b6107c160208901896117bd565b6107d160608a0160408b016117bd565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa158015610817573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083b9190611a45565b6107a160608b0160408c016117bd565b979650505050505050565b61086660a08501608086016117bd565b6001600160a01b031661087f6060890160408a016117bd565b6001600160a01b03161415806108c557506108a060608501604086016117bd565b6001600160a01b03166108b960a0890160808a016117bd565b6001600160a01b031614155b156108e357604051634e0820f160e11b815260040160405180910390fd5b60006108f56040890160208a016117bd565b6001600160a01b0316141580156109245750336109186040890160208a016117bd565b6001600160a01b031614155b15610942576040516303db19b360e31b815260040160405180910390fd5b600061095460408601602087016117bd565b6001600160a01b03161415801561098357503361097760408601602087016117bd565b6001600160a01b031614155b156109a1576040516303db19b360e31b815260040160405180910390fd5b60006109ad88836101d6565b905060006109bb8684610184565b9050818110156109de57604051633c4d934560e21b815260040160405180910390fd5b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663137c29fe610a196102b08c61191f565b610a2330876110bc565b610a3060208e018e6117bd565b610a398e6110ed565b604051602001610a4890611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a6020830139604051602001610a7d929190611b8e565b6040516020818303038152906040528e8e6040518863ffffffff1660e01b8152600401610ab09796959493929190611c04565b600060405180830381600087803b158015610aca57600080fd5b505af1158015610ade573d6000803e3d6000fd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663137c29fe610b1e886102b09061191f565b610b2830856110bc565b610b3560208b018b6117bd565b610b3e8b6110ed565b604051602001610b4d90611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a6020830139604051602001610b82929190611b8e565b6040516020818303038152906040528b8b6040518863ffffffff1660e01b8152600401610bb59796959493929190611c04565b600060405180830381600087803b158015610bcf57600080fd5b505af1158015610be3573d6000803e3d6000fd5b50610c0a9250610bf991505060208801886117bd565b846107a160608d0160408e016117bd565b610c2b610c1a60208b018b6117bd565b836107a160a08d0160808e016117bd565b610c498a610c398484611829565b6107a160a08d0160808e016117bd565b610c5960608a0160408b016117bd565b6001600160a01b03167f8a181b821b6fbc45fb158a5ade70964c9d58849c1ac3cd4078aa9cff7f5d2049610c9060208c018c6117bd565b610c9d60208a018a6117bd565b868d6080016020810190610cb191906117bd565b87610cbc8189611829565b604080516001600160a01b039788168152958716602087015285019390935293166060830152608082019290925260a081019190915260c00160405180910390a250505050505050505050565b610d1d878787878787876101058e8c610265565b50505050505050565b600080866001600160a01b031663777adcf06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d8b9190611a5e565b90506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663137c29fe610dc86102b08961191f565b610dd230876110bc565b610ddf60208b018b6117bd565b610de88b6110ed565b604051602001610df790611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a6020830139604051602001610e2c929190611b8e565b6040516020818303038152906040528b8b6040518863ffffffff1660e01b8152600401610e5f9796959493929190611c04565b600060405180830381600087803b158015610e7957600080fd5b505af1158015610e8d573d6000803e3d6000fd5b50610ea29250505060608701604088016117bd565b60405163095ea7b360e01b81526001600160a01b03838116600483015260248201869052919091169063095ea7b3906044016020604051808303816000875af1158015610ef3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f179190611c97565b5060006001600160a01b03821663d3b3ca77610f3960608a0160408b016117bd565b8a87610f496101008d018d611cb9565b6040518663ffffffff1660e01b8152600401610f69959493929190611d32565b6020604051808303816000875af1158015610f88573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fac9190611a45565b9050610fb887856101d6565b811015610fd857604051633c4d934560e21b815260040160405180910390fd5b61084b61079060208901896117bd565b7f64d58e5a032b3dff51a1bebcb1818be4d39cf1e8a658e3ca52bba8542b63822461101660208501856117bd565b61102660408601602087016117bd565b61103660608701604088016117bd565b61104660808801606089016117bd565b61105660a0890160808a016117bd565b61106660c08a0160a08b016117bd565b61107660e08b0160c08c01611d66565b6110876101008c0160e08d01611d66565b6110956101008d018d611cb9565b8c8c6040516110af9c9b9a99989796959493929190611d81565b60405180910390a1505050565b604080518082018252600080825260209182015281518083019092526001600160a01b039390931681529182015290565b60006040516020016110fe90611a7b565b60408051601f19818403018152919052805160209182012090611123908401846117bd565b61113360408501602086016117bd565b61114360608601604087016117bd565b61115360808701606088016117bd565b61116360a08801608089016117bd565b61117360c0890160a08a016117bd565b61118360e08a0160c08b01611d66565b6111946101008b0160e08c01611d66565b6111a26101008c018c611cb9565b6040516111b0929190611e0d565b60408051918290038220602083019b909b526001600160a01b03998a16908201529688166060880152948716608087015292861660a086015290851660c085015290931660e083015265ffffffffffff9283166101008301529190911661012082015261014081019190915261016001604051602081830303815290604052805190602001209050919050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b17905261128f908490611294565b505050565b60006112a96001600160a01b038416836112fc565b905080516000141580156112ce5750808060200190518101906112cc9190611c97565b155b1561128f57604051635274afe760e01b81526001600160a01b03841660048201526024015b60405180910390fd5b60606101cd838360006060825160001415801561132157506001600160a01b0384163b155b1561134a57604051639eb1341360e01b81526001600160a01b03851660048201526024016112f3565b600080856001600160a01b031684866040516113669190611e1d565b60006040518083038185875af1925050503d80600081146113a3576040519150601f19603f3d011682016040523d82523d6000602084013e6113a8565b606091505b509150915081156113bc5791506113fc9050565b8051156113cb57805160208201fd5b60405162461bcd60e51b815260206004820152600660248201526519985a5b195960d21b60448201526064016112f3565b9392505050565b6000610120828403121561141657600080fd5b50919050565b6000806040838503121561142f57600080fd5b823567ffffffffffffffff81111561144657600080fd5b61145285828601611403565b95602094909401359450505050565b6000806040838503121561147457600080fd5b823567ffffffffffffffff8082111561148c57600080fd5b61149886838701611403565b935060208501359150808211156114ae57600080fd5b506114bb85828601611403565b9150509250929050565b6001600160a01b03811681146114da57600080fd5b50565b60008083601f8401126114ef57600080fd5b50813567ffffffffffffffff81111561150757600080fd5b60208301915083602082850101111561151f57600080fd5b9250929050565b60008060008060006080868803121561153e57600080fd5b8535611549816114c5565b9450602086013567ffffffffffffffff8082111561156657600080fd5b61157289838a01611403565b9550604088013591508082111561158857600080fd5b50611595888289016114dd565b96999598509660600135949350505050565b80356115b2816114c5565b919050565b60008060008060008060008060c0898b0312156115d357600080fd5b6115dc896115a7565b9750602089013567ffffffffffffffff808211156115f957600080fd5b6116058c838d01611403565b985060408b013591508082111561161b57600080fd5b6116278c838d016114dd565b909850965060608b013591508082111561164057600080fd5b61164c8c838d01611403565b955060808b013591508082111561166257600080fd5b5061166f8b828c016114dd565b999c989b50969995989497949560a00135949350505050565b600080600080600080600060a0888a0312156116a357600080fd5b87356116ae816114c5565b9650602088013567ffffffffffffffff808211156116cb57600080fd5b6116d78b838c01611403565b975060408a01359150808211156116ed57600080fd5b6116f98b838c016114dd565b909750955060608a013591508082111561171257600080fd5b61171e8b838c01611403565b945060808a013591508082111561173457600080fd5b506117418a828b016114dd565b989b979a50959850939692959293505050565b60008060006040848603121561176957600080fd5b833567ffffffffffffffff8082111561178157600080fd5b61178d87838801611403565b945060208601359150808211156117a357600080fd5b506117b0868287016114dd565b9497909650939450505050565b6000602082840312156117cf57600080fd5b81356113fc816114c5565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176101d0576101d06117da565b60008261182457634e487b7160e01b600052601260045260246000fd5b500490565b818103818111156101d0576101d06117da565b634e487b7160e01b600052604160045260246000fd5b604051610120810167ffffffffffffffff811182821017156118765761187661183c565b60405290565b803565ffffffffffff811681146115b257600080fd5b600082601f8301126118a357600080fd5b813567ffffffffffffffff808211156118be576118be61183c565b604051601f8301601f19908116603f011681019082821181831017156118e6576118e661183c565b816040528381528660208588010111156118ff57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000610120823603121561193257600080fd5b61193a611852565b611943836115a7565b8152611951602084016115a7565b6020820152611962604084016115a7565b6040820152611973606084016115a7565b6060820152611984608084016115a7565b608082015261199560a084016115a7565b60a08201526119a660c0840161187c565b60c08201526119b760e0840161187c565b60e08201526101008084013567ffffffffffffffff8111156119d857600080fd5b6119e436828701611892565b918301919091525092915050565b611a1082825180516001600160a01b03168252602090810151910152565b60208101516040830152604081015160608301525050565b6001600160a01b038316815260a081016113fc60208301846119f2565b600060208284031215611a5757600080fd5b5051919050565b600060208284031215611a7057600080fd5b81516113fc816114c5565b66092dce8cadce8560cb1b81526d1859191c995cdcc81bdddb995c8b60921b60078201526e1859191c995cdcc8199a5b1b195c8b608a1b6015820152701859191c995cdcc81d1bdad95b93dd5d0b607a1b6024820152711d5a5b9d0c4d8c08185b5bdd5b9d13dd5d0b60721b60358201526f1859191c995cdcc81d1bdad95b925b8b60821b6047820152701d5a5b9d0c4d8c08185b5bdd5b9d125b8b607a1b6057820152711d5a5b9d0d0e08195e1c1a5c985d1a5bdb8b60721b60688201526c1d5a5b9d0d0e081b9bdb98d94b609a1b607a8201526a627974657320646174612960a81b608782015260920190565b60005b83811015611b85578181015183820152602001611b6d565b50506000910152565b6e496e74656e74207769746e6573732960881b815260008351611bb881600f850160208801611b6a565b835190830190611bcf81600f840160208801611b6a565b01600f01949350505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000610140611c13838b6119f2565b88516001600160a01b03166080840152602089015160a08401526001600160a01b03881660c084015260e083018790526101008301819052855190830181905261016090611c678183860160208a01611b6a565b601f01601f191683018381038201610120850152611c888282018688611bdb565b9b9a5050505050505050505050565b600060208284031215611ca957600080fd5b815180151581146113fc57600080fd5b6000808335601e19843603018112611cd057600080fd5b83018035915067ffffffffffffffff821115611ceb57600080fd5b60200191503681900382131561151f57600080fd5b60018060a01b0385168152836020820152606060408201526000611d28606083018486611bdb565b9695505050505050565b6001600160a01b038681168252851660208201526040810184905260806060820181905260009061084b9083018486611bdb565b600060208284031215611d7857600080fd5b6101cd8261187c565b6001600160a01b038d811682528c811660208301528b811660408301528a811660608301528981166080830152881660a082015265ffffffffffff87811660c0830152861660e08201526101406101008201819052600090611de69083018688611bdb565b828103610120840152611dfa818587611bdb565b9f9e505050505050505050505050505050565b8183823760009101908152919050565b60008251611e2f818460208701611b6a565b919091019291505056fe546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c75696e7432353620616d6f756e7429a2646970667358221220aa3271870e0be5025cbd3fda9a35e253b423bbabbb10e4bee00a2b759175edf464736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c80633eae8237116100665780633eae8237146100f75780634e03ba4b1461010c578063548d40511461011f5780638a4068dd14610132578063befbde5d1461017157600080fd5b806305cc7606146100985780631424404e146100be578063214fe96c146100d1578063294623ce146100e4575b600080fd5b6100ab6100a636600461141c565b610184565b6040519081526020015b60405180910390f35b6100ab6100cc36600461141c565b6101d6565b6100ab6100df366004611461565b610265565b6100ab6100f2366004611526565b6104df565b61010a6101053660046115b7565b610856565b005b61010a61011a366004611688565b610d09565b6100ab61012d366004611526565b610d26565b6101597f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100b5565b61010a61017f366004611754565b610fe8565b600061019660c0840160a085016117bd565b6001600160a01b0316826101b060808601606087016117bd565b6001600160a01b03166101c391906117f0565b6101cd9190611807565b90505b92915050565b60006101e860808401606085016117bd565b6001600160a01b03168261020260808601606087016117bd565b6001600160a01b03166102159190611829565b61022560c0860160a087016117bd565b6001600160a01b031661023891906117f0565b6102429190611807565b61025260c0850160a086016117bd565b6001600160a01b03166101cd9190611829565b6000806001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016639f0982936102a460208701876117bd565b61032d6102b08861191f565b6040805160a0810182526000606082018181526080830182905282526020820181905291810191909152506040805160a081018252828201516001600160a01b0390811660608084019182528501519091166080830152815260e083015165ffffffffffff908116602083015260c0909301519092169082015290565b6040518363ffffffff1660e01b815260040161034a929190611a28565b602060405180830381865afa158015610367573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038b9190611a45565b905060006001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016639f0982936103cb60208701876117bd565b6103d76102b08861191f565b6040518363ffffffff1660e01b81526004016103f4929190611a28565b602060405180830381865afa158015610411573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104359190611a45565b9050600061044960808601606087016117bd565b6001600160a01b03168261046360c0880160a089016117bd565b6001600160a01b031661047691906117f0565b6104809190611807565b905060008382116104915781610493565b835b905060006104a188836101d6565b905060006104af8884610184565b9050818110156104d257604051633c4d934560e21b815260040160405180910390fd5b5090979650505050505050565b600080866001600160a01b031663777adcf06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610520573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105449190611a5e565b90506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663137c29fe6105816102b08961191f565b61058b30876110bc565b61059860208b018b6117bd565b6105a18b6110ed565b6040516020016105b090611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a60208301396040516020016105e5929190611b8e565b6040516020818303038152906040528b8b6040518863ffffffff1660e01b81526004016106189796959493929190611c04565b600060405180830381600087803b15801561063257600080fd5b505af1158015610646573d6000803e3d6000fd5b5061065b9250505060608701604088016117bd565b60405163095ea7b360e01b81526001600160a01b03838116600483015260248201869052919091169063095ea7b3906044016020604051808303816000875af11580156106ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d09190611c97565b5060006001600160a01b0382166317f565d289866106f26101008c018c611cb9565b6040518563ffffffff1660e01b81526004016107119493929190611d00565b6020604051808303816000875af1158015610730573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107549190611a45565b90506107608782610184565b84111561078057604051633c4d934560e21b815260040160405180910390fd5b6107b161079060208901896117bd565b826107a160a08b0160808c016117bd565b6001600160a01b0316919061123d565b61084b6107c160208901896117bd565b6107d160608a0160408b016117bd565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa158015610817573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083b9190611a45565b6107a160608b0160408c016117bd565b979650505050505050565b61086660a08501608086016117bd565b6001600160a01b031661087f6060890160408a016117bd565b6001600160a01b03161415806108c557506108a060608501604086016117bd565b6001600160a01b03166108b960a0890160808a016117bd565b6001600160a01b031614155b156108e357604051634e0820f160e11b815260040160405180910390fd5b60006108f56040890160208a016117bd565b6001600160a01b0316141580156109245750336109186040890160208a016117bd565b6001600160a01b031614155b15610942576040516303db19b360e31b815260040160405180910390fd5b600061095460408601602087016117bd565b6001600160a01b03161415801561098357503361097760408601602087016117bd565b6001600160a01b031614155b156109a1576040516303db19b360e31b815260040160405180910390fd5b60006109ad88836101d6565b905060006109bb8684610184565b9050818110156109de57604051633c4d934560e21b815260040160405180910390fd5b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663137c29fe610a196102b08c61191f565b610a2330876110bc565b610a3060208e018e6117bd565b610a398e6110ed565b604051602001610a4890611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a6020830139604051602001610a7d929190611b8e565b6040516020818303038152906040528e8e6040518863ffffffff1660e01b8152600401610ab09796959493929190611c04565b600060405180830381600087803b158015610aca57600080fd5b505af1158015610ade573d6000803e3d6000fd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663137c29fe610b1e886102b09061191f565b610b2830856110bc565b610b3560208b018b6117bd565b610b3e8b6110ed565b604051602001610b4d90611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a6020830139604051602001610b82929190611b8e565b6040516020818303038152906040528b8b6040518863ffffffff1660e01b8152600401610bb59796959493929190611c04565b600060405180830381600087803b158015610bcf57600080fd5b505af1158015610be3573d6000803e3d6000fd5b50610c0a9250610bf991505060208801886117bd565b846107a160608d0160408e016117bd565b610c2b610c1a60208b018b6117bd565b836107a160a08d0160808e016117bd565b610c498a610c398484611829565b6107a160a08d0160808e016117bd565b610c5960608a0160408b016117bd565b6001600160a01b03167f8a181b821b6fbc45fb158a5ade70964c9d58849c1ac3cd4078aa9cff7f5d2049610c9060208c018c6117bd565b610c9d60208a018a6117bd565b868d6080016020810190610cb191906117bd565b87610cbc8189611829565b604080516001600160a01b039788168152958716602087015285019390935293166060830152608082019290925260a081019190915260c00160405180910390a250505050505050505050565b610d1d878787878787876101058e8c610265565b50505050505050565b600080866001600160a01b031663777adcf06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d8b9190611a5e565b90506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663137c29fe610dc86102b08961191f565b610dd230876110bc565b610ddf60208b018b6117bd565b610de88b6110ed565b604051602001610df790611a7b565b60408051601f1981840301815260608301909152602e808352909190611e3a6020830139604051602001610e2c929190611b8e565b6040516020818303038152906040528b8b6040518863ffffffff1660e01b8152600401610e5f9796959493929190611c04565b600060405180830381600087803b158015610e7957600080fd5b505af1158015610e8d573d6000803e3d6000fd5b50610ea29250505060608701604088016117bd565b60405163095ea7b360e01b81526001600160a01b03838116600483015260248201869052919091169063095ea7b3906044016020604051808303816000875af1158015610ef3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f179190611c97565b5060006001600160a01b03821663d3b3ca77610f3960608a0160408b016117bd565b8a87610f496101008d018d611cb9565b6040518663ffffffff1660e01b8152600401610f69959493929190611d32565b6020604051808303816000875af1158015610f88573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fac9190611a45565b9050610fb887856101d6565b811015610fd857604051633c4d934560e21b815260040160405180910390fd5b61084b61079060208901896117bd565b7f64d58e5a032b3dff51a1bebcb1818be4d39cf1e8a658e3ca52bba8542b63822461101660208501856117bd565b61102660408601602087016117bd565b61103660608701604088016117bd565b61104660808801606089016117bd565b61105660a0890160808a016117bd565b61106660c08a0160a08b016117bd565b61107660e08b0160c08c01611d66565b6110876101008c0160e08d01611d66565b6110956101008d018d611cb9565b8c8c6040516110af9c9b9a99989796959493929190611d81565b60405180910390a1505050565b604080518082018252600080825260209182015281518083019092526001600160a01b039390931681529182015290565b60006040516020016110fe90611a7b565b60408051601f19818403018152919052805160209182012090611123908401846117bd565b61113360408501602086016117bd565b61114360608601604087016117bd565b61115360808701606088016117bd565b61116360a08801608089016117bd565b61117360c0890160a08a016117bd565b61118360e08a0160c08b01611d66565b6111946101008b0160e08c01611d66565b6111a26101008c018c611cb9565b6040516111b0929190611e0d565b60408051918290038220602083019b909b526001600160a01b03998a16908201529688166060880152948716608087015292861660a086015290851660c085015290931660e083015265ffffffffffff9283166101008301529190911661012082015261014081019190915261016001604051602081830303815290604052805190602001209050919050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b17905261128f908490611294565b505050565b60006112a96001600160a01b038416836112fc565b905080516000141580156112ce5750808060200190518101906112cc9190611c97565b155b1561128f57604051635274afe760e01b81526001600160a01b03841660048201526024015b60405180910390fd5b60606101cd838360006060825160001415801561132157506001600160a01b0384163b155b1561134a57604051639eb1341360e01b81526001600160a01b03851660048201526024016112f3565b600080856001600160a01b031684866040516113669190611e1d565b60006040518083038185875af1925050503d80600081146113a3576040519150601f19603f3d011682016040523d82523d6000602084013e6113a8565b606091505b509150915081156113bc5791506113fc9050565b8051156113cb57805160208201fd5b60405162461bcd60e51b815260206004820152600660248201526519985a5b195960d21b60448201526064016112f3565b9392505050565b6000610120828403121561141657600080fd5b50919050565b6000806040838503121561142f57600080fd5b823567ffffffffffffffff81111561144657600080fd5b61145285828601611403565b95602094909401359450505050565b6000806040838503121561147457600080fd5b823567ffffffffffffffff8082111561148c57600080fd5b61149886838701611403565b935060208501359150808211156114ae57600080fd5b506114bb85828601611403565b9150509250929050565b6001600160a01b03811681146114da57600080fd5b50565b60008083601f8401126114ef57600080fd5b50813567ffffffffffffffff81111561150757600080fd5b60208301915083602082850101111561151f57600080fd5b9250929050565b60008060008060006080868803121561153e57600080fd5b8535611549816114c5565b9450602086013567ffffffffffffffff8082111561156657600080fd5b61157289838a01611403565b9550604088013591508082111561158857600080fd5b50611595888289016114dd565b96999598509660600135949350505050565b80356115b2816114c5565b919050565b60008060008060008060008060c0898b0312156115d357600080fd5b6115dc896115a7565b9750602089013567ffffffffffffffff808211156115f957600080fd5b6116058c838d01611403565b985060408b013591508082111561161b57600080fd5b6116278c838d016114dd565b909850965060608b013591508082111561164057600080fd5b61164c8c838d01611403565b955060808b013591508082111561166257600080fd5b5061166f8b828c016114dd565b999c989b50969995989497949560a00135949350505050565b600080600080600080600060a0888a0312156116a357600080fd5b87356116ae816114c5565b9650602088013567ffffffffffffffff808211156116cb57600080fd5b6116d78b838c01611403565b975060408a01359150808211156116ed57600080fd5b6116f98b838c016114dd565b909750955060608a013591508082111561171257600080fd5b61171e8b838c01611403565b945060808a013591508082111561173457600080fd5b506117418a828b016114dd565b989b979a50959850939692959293505050565b60008060006040848603121561176957600080fd5b833567ffffffffffffffff8082111561178157600080fd5b61178d87838801611403565b945060208601359150808211156117a357600080fd5b506117b0868287016114dd565b9497909650939450505050565b6000602082840312156117cf57600080fd5b81356113fc816114c5565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176101d0576101d06117da565b60008261182457634e487b7160e01b600052601260045260246000fd5b500490565b818103818111156101d0576101d06117da565b634e487b7160e01b600052604160045260246000fd5b604051610120810167ffffffffffffffff811182821017156118765761187661183c565b60405290565b803565ffffffffffff811681146115b257600080fd5b600082601f8301126118a357600080fd5b813567ffffffffffffffff808211156118be576118be61183c565b604051601f8301601f19908116603f011681019082821181831017156118e6576118e661183c565b816040528381528660208588010111156118ff57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000610120823603121561193257600080fd5b61193a611852565b611943836115a7565b8152611951602084016115a7565b6020820152611962604084016115a7565b6040820152611973606084016115a7565b6060820152611984608084016115a7565b608082015261199560a084016115a7565b60a08201526119a660c0840161187c565b60c08201526119b760e0840161187c565b60e08201526101008084013567ffffffffffffffff8111156119d857600080fd5b6119e436828701611892565b918301919091525092915050565b611a1082825180516001600160a01b03168252602090810151910152565b60208101516040830152604081015160608301525050565b6001600160a01b038316815260a081016113fc60208301846119f2565b600060208284031215611a5757600080fd5b5051919050565b600060208284031215611a7057600080fd5b81516113fc816114c5565b66092dce8cadce8560cb1b81526d1859191c995cdcc81bdddb995c8b60921b60078201526e1859191c995cdcc8199a5b1b195c8b608a1b6015820152701859191c995cdcc81d1bdad95b93dd5d0b607a1b6024820152711d5a5b9d0c4d8c08185b5bdd5b9d13dd5d0b60721b60358201526f1859191c995cdcc81d1bdad95b925b8b60821b6047820152701d5a5b9d0c4d8c08185b5bdd5b9d125b8b607a1b6057820152711d5a5b9d0d0e08195e1c1a5c985d1a5bdb8b60721b60688201526c1d5a5b9d0d0e081b9bdb98d94b609a1b607a8201526a627974657320646174612960a81b608782015260920190565b60005b83811015611b85578181015183820152602001611b6d565b50506000910152565b6e496e74656e74207769746e6573732960881b815260008351611bb881600f850160208801611b6a565b835190830190611bcf81600f840160208801611b6a565b01600f01949350505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000610140611c13838b6119f2565b88516001600160a01b03166080840152602089015160a08401526001600160a01b03881660c084015260e083018790526101008301819052855190830181905261016090611c678183860160208a01611b6a565b601f01601f191683018381038201610120850152611c888282018688611bdb565b9b9a5050505050505050505050565b600060208284031215611ca957600080fd5b815180151581146113fc57600080fd5b6000808335601e19843603018112611cd057600080fd5b83018035915067ffffffffffffffff821115611ceb57600080fd5b60200191503681900382131561151f57600080fd5b60018060a01b0385168152836020820152606060408201526000611d28606083018486611bdb565b9695505050505050565b6001600160a01b038681168252851660208201526040810184905260806060820181905260009061084b9083018486611bdb565b600060208284031215611d7857600080fd5b6101cd8261187c565b6001600160a01b038d811682528c811660208301528b811660408301528a811660608301528981166080830152881660a082015265ffffffffffff87811660c0830152861660e08201526101406101008201819052600090611de69083018688611bdb565b828103610120840152611dfa818587611bdb565b9f9e505050505050505050505050505050565b8183823760009101908152919050565b60008251611e2f818460208701611b6a565b919091019291505056fe546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c75696e7432353620616d6f756e7429a2646970667358221220aa3271870e0be5025cbd3fda9a35e253b423bbabbb10e4bee00a2b759175edf464736f6c63430008190033",
  "devdoc": {
    "details": "This contract uses the SignatureTransfer contract for secure transfers with signatures.",
    "errors": {
      "Address_NotTransferNorContract(address)": [
        {
          "params": {
            "target": "Target address to call the function on."
          }
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC20 token failed."
        }
      ]
    },
    "events": {
      "IntentSignal(address,address,address,uint160,address,uint160,uint48,uint48,bytes,bytes)": {
        "details": "Emitted when an intent to trade is signaled.",
        "params": {
          "amountIn": "The amount of the tokenIn the owner wants to receive.",
          "amountOut": "The amount of the tokenOut the owner wants to sell or exchange.",
          "data": "Additional data that may be used in the trade execution.",
          "exp": "The expiration time of the intent.",
          "filler": "The address of the filler, if any, that the intent is specifically directed to.",
          "nonce": "A nonce to ensure the uniqueness of the intent.",
          "owner": "The address of the intent owner.",
          "signature": "The signature of the owner authorizing the intent.",
          "tokenIn": "The address of the token the owner wants to receive in exchange.",
          "tokenOut": "The address of the token the owner wants to sell or exchange."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "buyFromBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)": {
        "details": "This function allows a user to buy tokens from a Brokerbot by transferring the specified amount of investment token to the Brokerbot and receiving the purchased tokens in return. The function ensures that the offer is not too low by comparing the invested amount to the bid price.",
        "params": {
          "amount": "The amount of tokens to invest in the purchase.",
          "bot": "The Brokerbot from which tokens are being bought.",
          "intent": "The trade intent data structure.",
          "signature": "The signature of the intent owner."
        },
        "returns": {
          "_0": "The amount of tokens received from the Brokerbot."
        }
      },
      "getAsk((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)": {
        "details": "Ideally called with an intent where tokenIn is a currency with many (e.g. 18) decimals.TokenOut can have very few decimals.",
        "params": {
          "amount": "The amount of tokenOut.",
          "intent": "The trade intent data structure."
        },
        "returns": {
          "_0": "The calculated asking price."
        }
      },
      "getBid((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)": {
        "details": "Ideally called with an intent where tokenOut is a currency with many (e.g. 18) decimals.TokenIn can have very few decimals.",
        "params": {
          "amount": "The amount of tokenIn.",
          "intent": "The trade intent data structure."
        },
        "returns": {
          "_0": "The calculated bidding price."
        }
      },
      "getMaxValidAmount((address,address,address,uint160,address,uint160,uint48,uint48,bytes),(address,address,address,uint160,address,uint160,uint48,uint48,bytes))": {
        "params": {
          "buyerIntent": "The buyer's trade intent.",
          "sellerIntent": "The seller's trade intent."
        },
        "returns": {
          "_0": "The maximum valid trade amount."
        }
      },
      "process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)": {
        "params": {
          "buyerIntent": "The buyer's trade intent.",
          "buyerSig": "The buyer's signature.",
          "feeRecipient": "The address that will receive the fee.",
          "sellerIntent": "The seller's trade intent.",
          "sellerSig": "The seller's signature."
        }
      },
      "process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)": {
        "params": {
          "amount": "The amount of the token to trade.",
          "buyerIntent": "The buyer's trade intent.",
          "buyerSig": "The buyer's signature.",
          "feeRecipient": "The address that will receive the fee.",
          "sellerIntent": "The seller's trade intent.",
          "sellerSig": "The seller's signature."
        }
      },
      "sellToBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)": {
        "details": "This function allows a user to sell tokens to a Brokerbot by transferring the specified amount of tokens to the Brokerbot and receiving the payment in return. The function ensures that the received amount is not lower than the ask price.",
        "params": {
          "bot": "The Brokerbot to which tokens are being sold.",
          "intent": "The trade intent data structure.",
          "signature": "The signature of the intent owner.",
          "soldShares": "The amount of tokens being sold."
        },
        "returns": {
          "_0": "The amount of payment received from the Brokerbot."
        }
      },
      "signalIntent((address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)": {
        "params": {
          "intent": "The trade intent data structure. ",
          "signature": "The signature of the intent owner."
        }
      }
    },
    "title": "TradeReactor Contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "buyFromBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)": {
        "notice": "Buys tokens from a Brokerbot."
      },
      "getAsk((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)": {
        "notice": "Calculates the asking price for a given amount of tokenOut."
      },
      "getBid((address,address,address,uint160,address,uint160,uint48,uint48,bytes),uint256)": {
        "notice": "Calculates the bidding price for a given amount of tokenIn."
      },
      "getMaxValidAmount((address,address,address,uint160,address,uint160,uint48,uint48,bytes),(address,address,address,uint160,address,uint160,uint48,uint48,bytes))": {
        "notice": "Determines the maximum valid amount that can be traded based on seller and buyer intents."
      },
      "process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)": {
        "notice": "Processes a trade between a seller and a buyer with the maximum valid amount."
      },
      "process(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)": {
        "notice": "Processes a trade between a seller and a buyer for a specified amount."
      },
      "sellToBrokerbot(address,(address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes,uint256)": {
        "notice": "Sells tokens to a Brokerbot."
      },
      "signalIntent((address,address,address,uint160,address,uint160,uint48,uint48,bytes),bytes)": {
        "notice": "A function to publicly signal an intent to buy or sell a token so it can be picked up by the filler for processing. Alternaticely, the owner can directly communicate with the filler, without recording the intent on chain."
      }
    },
    "notice": "This contract handles the signaling and processing of trade intents between buyers and sellers.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}