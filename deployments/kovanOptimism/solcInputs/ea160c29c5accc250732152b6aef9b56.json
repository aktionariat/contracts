{
  "language": "Solidity",
  "sources": {
    "src/bonds/Bond.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Named.sol\";\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\n\n/**\n * @title CompanyName AG Bonds\n * @author Bernhard Ruf, bernhard@aktionariat.com\n *\n * @notice The main addition is a functionality that allows the user to claim that the key for a certain address is lost.\n * @notice In order to prevent malicious attempts, a collateral needs to be posted.\n * @notice The contract owner can delete claims in case of disputes.\n */\ncontract Bond is ERC20Named, ERC20Recoverable {\n\n    string public terms;\n    uint256 public immutable deployTimestamp; // the timestamp of the contract deployment\n    uint256 public immutable termToMaturity; // the duration of the bond\n\n    event Announcement(string message);\n    event TermsChanged(string terms);\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n        string memory _terms,\n        uint256 _termToMaturity,\n        address _owner,\n        IRecoveryHub _recoveryHub\n    ) \n        ERC20Recoverable(_recoveryHub)\n        ERC20Named(_symbol, _name, 0, _owner)\n    {\n        symbol = _symbol;\n        name = _name;\n        terms = _terms;\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        deployTimestamp = block.timestamp;\n        termToMaturity = _termToMaturity;\n    }\n\n    function setTerms(string memory _terms) external onlyOwner {\n        emit TermsChanged(_terms);\n        terms = _terms;\n    }\n\n    /**\n     * Allows the issuer to make public announcements that are visible on the blockchain.\n     */\n    function announcement(string calldata message) external onlyOwner() {\n        emit Announcement(message);\n    }\n\n    /**\n     * See parent method for collateral requirements.\n     */\n    function setCustomClaimCollateral(IERC20 collateral, uint256 rate) external onlyOwner() {\n        super._setCustomClaimCollateral(collateral, rate);\n    }\n\n    function getClaimDeleter() public override view returns (address) {\n        return owner;\n    }\n\n    function mint(address target, uint256 amount) external onlyOwner {\n        _mint(target, amount);\n    }\n\n    function transfer(address to, uint256 value) virtual override(ERC20Flaggable, ERC20Recoverable) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Burns the tokens. Without agreement to the contrary, the legal meaning\n     * of this shall be that the sender forfeits all his rights in connection\n     * with the burned tokens, rendering them unredeemable.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n}   \n"
    },
    "src/ERC20/ERC20Named.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Flaggable.sol\";\nimport \"../utils/Ownable.sol\";\n\ncontract ERC20Named is ERC20Flaggable, Ownable {\n\n    string public override name;\n    string public override symbol;\n\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, address _admin) ERC20Flaggable(_decimals) Ownable(_admin) {\n        setNameInternal(_symbol, _name);\n    }\n\n    function setName(string memory _symbol, string memory _name) external onlyOwner {\n        setNameInternal(_symbol, _name);\n    }\n\n    function setNameInternal(string memory _symbol, string memory _name) internal {\n        symbol = _symbol;\n        name = _name;\n        emit NameChanged(_name, _symbol);\n    }\n\n}"
    },
    "src/recovery/ERC20Recoverable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Flaggable.sol\";\nimport \"./IRecoveryHub.sol\";\nimport \"./IRecoverable.sol\";\n\n/**\n * @title Recoverable\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\n * declareLost function on the recovery hub to post a deposit and claim that the shares assigned to a\n * specific address are lost.\n * If an attacker trying to claim shares belonging to someone else, they risk losing the deposit\n * as it can be claimed at anytime by the rightful owner.\n * Furthermore, if \"getClaimDeleter\" is defined in the subclass, the returned address is allowed to\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\n * function, e.g. cases of front-running.\n * Most functionality is implemented in a shared RecoveryHub.\n */\nabstract contract ERC20Recoverable is ERC20Flaggable, IRecoverable {\n\n    uint8 private constant FLAG_CLAIM_PRESENT = 10;\n\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\n    IERC20 public customCollateralAddress;\n    // Rate the custom collateral currency is multiplied to be valued like one share.\n    uint256 public customCollateralRate;\n\n    uint256 constant CLAIM_PERIOD = 180 days;\n\n    IRecoveryHub public immutable recovery;\n\n    constructor(IRecoveryHub recoveryHub){\n        recovery = recoveryHub;\n    }\n\n    /**\n     * Returns the collateral rate for the given collateral type and 0 if that type\n     * of collateral is not accepted. By default, only the token itself is accepted at\n     * a rate of 1:1.\n     *\n     * Subclasses should override this method if they want to add additional types of\n     * collateral.\n     */\n    function getCollateralRate(IERC20 collateralType) public override virtual view returns (uint256) {\n        if (address(collateralType) == address(this)) {\n            return 1;\n        } else if (collateralType == customCollateralAddress) {\n            return customCollateralRate;\n        } else {\n            return 0;\n        }\n    }\n\n    function claimPeriod() external pure override returns (uint256){\n        return CLAIM_PERIOD;\n    }\n\n    /**\n     * Allows subclasses to set a custom collateral besides the token itself.\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\n     * throws an exception or returns false on failure.\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\n     */\n    function _setCustomClaimCollateral(IERC20 collateral, uint256 rate) internal {\n        customCollateralAddress = collateral;\n        if (address(customCollateralAddress) == address(0)) {\n            customCollateralRate = 0; // disabled\n        } else {\n            require(rate > 0, \"zero\");\n            customCollateralRate = rate;\n        }\n    }\n\n    function getClaimDeleter() virtual public view returns (address);\n\n    function transfer(address recipient, uint256 amount) override(ERC20Flaggable, IERC20) virtual public returns (bool) {\n        require(super.transfer(recipient, amount), \"transfer\");\n        if (hasFlagInternal(msg.sender, FLAG_CLAIM_PRESENT)){\n            recovery.clearClaimFromToken(msg.sender);\n        }\n        return true;\n    }\n\n    function notifyClaimMade(address target) external override {\n        require(msg.sender == address(recovery), \"not recovery\");\n        setFlag(target, FLAG_CLAIM_PRESENT, true);\n    }\n\n    function notifyClaimDeleted(address target) external override {\n        require(msg.sender == address(recovery), \"not recovery\");\n        setFlag(target, FLAG_CLAIM_PRESENT, false);\n    }\n\n    function deleteClaim(address lostAddress) external {\n        require(msg.sender == getClaimDeleter(), \"not claim deleter\");\n        recovery.deleteClaim(lostAddress);\n    }\n\n    function recover(address oldAddress, address newAddress) external override {\n        require(msg.sender == address(recovery), \"not recovery\");\n        _transfer(oldAddress, newAddress, balanceOf(oldAddress));\n    }\n\n}"
    },
    "src/ERC20/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "src/ERC20/ERC20Flaggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n// - use upper 32 bits of balance for flags\n// - add a global settings variable\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\n\nabstract contract ERC20Flaggable is IERC20 {\n\n    // as Documented in /doc/infiniteallowance.md\n    uint256 constant private INFINITE_ALLOWANCE = 2**255;\n\n    uint256 private constant FLAGGING_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\n\n    // Documentation of flags used by subclasses:\n    // NOTE: flags denote the bit number that is being used and must be smaller than 32\n    // ERC20Draggable: uint8 private constant FLAG_INDEX_VOTED = 1;\n    // ERC20Recoverable: uint8 private constant FLAG_INDEX_CLAIM_PRESENT = 10;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_POWERLIST = 22;\n\n    mapping (address => uint256) private _balances; // upper 32 bits reserved for flags\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    uint8 public override decimals;\n\n    event NameChanged(string name, string symbol);\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return uint224 (_balances [account]);\n    }\n\n    function hasFlag(address account, uint8 number) external view returns (bool) {\n        return hasFlagInternal(account, number);\n    }\n\n    function setFlag(address account, uint8 index, bool value) internal {\n        uint256 flagMask = 1 << (index + 224);\n        uint256 balance = _balances [account];\n        if ((balance & flagMask == flagMask) != value) {\n            _balances [account] = balance ^ flagMask;\n        }\n    }\n\n    function hasFlagInternal(address account, uint8 number) internal view returns (bool) {\n        uint256 flag = 0x1 << (number + 224);\n        return _balances[account] & flag == flag;\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        if (currentAllowance < INFINITE_ALLOWANCE){\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in /doc/infiniteallowance.md\n            _allowances[sender][msg.sender] = currentAllowance - amount;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        _beforeTokenTransfer(sender, recipient, amount);\n        decreaseBalance(sender, amount);\n        increaseBalance(recipient, amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external virtual returns (bool) {\n        return transfer (recipient, amount) \n            && IERC677Receiver (recipient).onTokenTransfer (msg.sender, amount, data);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), recipient, amount);\n        _totalSupply += amount;\n        increaseBalance(recipient, amount);\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    function increaseBalance(address recipient, uint256 amount) private {\n        require(recipient != address(0x0), \"0x0\"); // use burn instead\n        uint256 oldBalance = _balances[recipient];\n        uint256 newBalance = oldBalance + amount;\n        require(oldBalance & FLAGGING_MASK == newBalance & FLAGGING_MASK, \"overflow\");\n        _balances[recipient] = newBalance;\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        decreaseBalance(account, amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function decreaseBalance(address sender, uint256 amount) private {\n        uint256 oldBalance = _balances[sender];\n        uint256 newBalance = oldBalance - amount;\n        require(oldBalance & FLAGGING_MASK == newBalance & FLAGGING_MASK, \"underflow\");\n        _balances[sender] = newBalance;\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n     // solhint-disable-next-line no-empty-blocks\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\n        // intentionally left blank\n    }\n\n}"
    },
    "src/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"not owner\");\n        _;\n    }\n}"
    },
    "src/ERC20/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "src/recovery/IRecoveryHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRecoveryHub {\n\n    function setRecoverable(bool flag) external;\n    \n    // deletes claim and transfers collateral back to claimer\n    function deleteClaim(address target) external;\n\n    // clears claim and transfers collateral to holder\n    function clearClaimFromToken(address holder) external;\n\n}"
    },
    "src/recovery/IRecoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IRecoverable is IERC20{\n\n    function claimPeriod() external view returns (uint256);\n    \n    function notifyClaimMade(address target) external;\n\n    function notifyClaimDeleted(address target) external;\n\n    function getCollateralRate(IERC20 collateral) external view returns(uint256);\n\n    function recover(address oldAddress, address newAddress) external;\n\n}"
    },
    "src/shares/Shares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Named.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../shares/IShares.sol\";\n\n/**\n * @title CompanyName AG Shares\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * These tokens represent ledger-based securities according to article 973d of the Swiss Code of Obligations.\n * This smart contract serves as an ownership registry, enabling the token holders to register them as\n * shareholders in the issuer's shareholder registry. This is equivalent to the traditional system\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\n * themselves. For example, in case the company pays out a dividend to a previous shareholder because\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\n * the \"wrong\" shareholder. In relation to the company, only the registered shareholders count as such.\n */\ncontract Shares is ERC20Recoverable, ERC20Named, IShares{\n\n    string public terms;\n\n    uint256 public override totalShares; // total number of shares, maybe not all tokenized\n    uint256 public invalidTokens;\n\n    event Announcement(string message);\n    event TokensDeclaredInvalid(address indexed holder, uint256 amount, string message);\n    event ChangeTerms(string terms);\n    event ChangeTotalShares(uint256 total);\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n        string memory _terms,\n        uint256 _totalShares,\n        address _owner,\n        IRecoveryHub _recoveryHub\n    )\n        ERC20Named(_symbol, _name, 0, _owner) \n        ERC20Recoverable(_recoveryHub)\n    {\n        totalShares = _totalShares;\n        terms = _terms;\n        invalidTokens = 0;\n        _recoveryHub.setRecoverable(false); \n    }\n\n    function setTerms(string memory _terms) external onlyOwner {\n        terms = _terms;\n        emit ChangeTerms(_terms);\n    }\n\n    /**\n     * Declares the number of total shares, including those that have not been tokenized and those\n     * that are held by the company itself. This number can be substiantially higher than totalSupply()\n     * in case not all shares have been tokenized. Also, it can be lower than totalSupply() in case some\n     * tokens have become invalid.\n     */\n    function setTotalShares(uint256 _newTotalShares) external onlyOwner() {\n        require(_newTotalShares >= totalValidSupply(), \"below supply\");\n        totalShares = _newTotalShares;\n        emit ChangeTotalShares(_newTotalShares);\n    }\n\n    /**\n     * Allows the issuer to make public announcements that are visible on the blockchain.\n     */\n    function announcement(string calldata message) external onlyOwner() {\n        emit Announcement(message);\n    }\n\n    /**\n     * See parent method for collateral requirements.\n     */\n    function setCustomClaimCollateral(IERC20 collateral, uint256 rate) external onlyOwner() {\n        super._setCustomClaimCollateral(collateral, rate);\n    }\n\n    function getClaimDeleter() public override view returns (address) {\n        return owner;\n    }\n\n    /**\n     * Signals that the indicated tokens have been declared invalid (e.g. by a court ruling in accordance\n     * with article 973g of the Swiss Code of Obligations) and got detached from\n     * the underlying shares. Invalid tokens do not carry any shareholder rights any more.\n     *\n     * This function is purely declarative. It does not technically immobilize the affected tokens as\n     * that would give the issuer too much power.\n     */\n    function declareInvalid(address holder, uint256 amount, string calldata message) external onlyOwner() {\n        uint256 holderBalance = balanceOf(holder);\n        require(amount <= holderBalance, \"amount too high\");\n        invalidTokens += amount;\n        emit TokensDeclaredInvalid(holder, amount, message);\n    }\n\n    /**\n     * The total number of valid tokens in circulation. In case some tokens have been declared invalid, this\n     * number might be lower than totalSupply(). Also, it will always be lower than or equal to totalShares().\n     */\n    function totalValidSupply() public view returns (uint256) {\n        return totalSupply() - invalidTokens;\n    }\n\n    /**\n     * Allows the company to tokenize shares and transfer them e.g to the draggable contract and wrap them.\n     * If these shares are newly created, setTotalShares must be called first in order to adjust the total number of shares.\n     */\n    function mintAndCall(address shareholder, address callee, uint256 amount, bytes calldata data) external {\n        mint(callee, amount);\n        require(IERC677Receiver(callee).onTokenTransfer(shareholder, amount, data));\n    }\n\n    function mint(address target, uint256 amount) public virtual onlyOwner {\n        _mint(target, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(totalValidSupply() + amount <= totalShares, \"total\");\n        super._mint(account, amount);\n    }\n\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20Flaggable) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Transfers _amount tokens to the company and burns them.\n     * The meaning of this operation depends on the circumstances and the fate of the shares does\n     * not necessarily follow the fate of the tokens. For example, the company itself might call\n     * this function to implement a formal decision to destroy some of the outstanding shares.\n     * Also, this function might be called by an owner to return the shares to the company and\n     * get them back in another form under an according agreement (e.g. printed certificates or\n     * tokens on a different blockchain). It is not recommended to call this function without\n     * having agreed with the company on the further fate of the shares in question.\n     */\n    function burn(uint256 _amount) override external {\n        _transfer(msg.sender, address(this), _amount);\n        _burn(address(this), _amount);\n    }\n\n}"
    },
    "src/shares/IShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IShares {\n\tfunction burn(uint256) external;\n\n\tfunction totalShares() external view returns (uint256);\n}"
    },
    "src/shares/AllowlistShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../ERC20/ERC20Allowlistable.sol\";\nimport \"./Shares.sol\";\n\ncontract AllowlistShares is Shares, ERC20Allowlistable {\n\n  constructor(\n    string memory _symbol,\n    string memory _name,\n    string memory _terms,\n    uint256 _totalShares,\n    IRecoveryHub _recoveryHub,\n    address _owner\n  )\n    Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub)\n    ERC20Allowlistable()\n  {\n    // initialization in shares\n  }\n\n  function transfer(address recipient, uint256 amount) override(ERC20Flaggable, Shares) virtual public returns (bool) {\n    return super.transfer(recipient, amount); \n  }\n\n  function _mint(address account, uint256 amount) internal override(ERC20Flaggable, Shares) {\n      super._mint(account, amount);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Allowlistable) internal {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n}"
    },
    "src/ERC20/ERC20Allowlistable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\n\nimport \"./ERC20Flaggable.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * A very flexible and efficient form to subject ERC-20 tokens to an allowlisting.\n * See ../../doc/allowlist.md for more information.\n */\nabstract contract ERC20Allowlistable is ERC20Flaggable, Ownable {\n\n  uint8 private constant TYPE_DEFAULT = 0x0;\n  uint8 private constant TYPE_ALLOWLISTED = 0x1;\n  uint8 private constant TYPE_FORBIDDEN = 0x2;\n  uint8 private constant TYPE_POWERLISTED = 0x4;\n  // I think TYPE_POWERLISTED should have been 0x3. :) But MOP was deployed like this so we keep it. Does not hurt.\n\n  uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\n  uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\n  uint8 private constant FLAG_INDEX_POWERLIST = 22;\n\n  event AddressTypeUpdate(address indexed account, uint8 addressType);\n\n  bool public restrictTransfers;\n\n  constructor(){\n    setApplicableInternal(true);\n  }\n\n  /**\n   * Configures whether the allowlisting is applied.\n   * Also sets the powerlist and allowlist flags on the null address accordingly.\n   * It is recommended to also deactivate the powerlist flag on other addresses.\n   */\n  function setApplicable(bool transferRestrictionsApplicable) external onlyOwner {\n    setApplicableInternal(transferRestrictionsApplicable);\n  }\n\n  function setApplicableInternal(bool transferRestrictionsApplicable) internal {\n    restrictTransfers = transferRestrictionsApplicable;\n    // if transfer restrictions are applied, we guess that should also be the case for newly minted tokens\n    // if the admin disagrees, it is still possible to change the type of the null address\n    if (transferRestrictionsApplicable){\n      setTypeInternal(address(0x0), TYPE_POWERLISTED);\n    } else {\n      setTypeInternal(address(0x0), TYPE_DEFAULT);\n    }\n  }\n\n  function setType(address account, uint8 typeNumber) public onlyOwner {\n    setTypeInternal(account, typeNumber);\n  }\n\n  /**\n   * If TYPE_DEFAULT all flags are set to 0\n   */\n  function setTypeInternal(address account, uint8 typeNumber) internal {\n    setFlag(account, FLAG_INDEX_ALLOWLIST, typeNumber == TYPE_ALLOWLISTED);\n    setFlag(account, FLAG_INDEX_FORBIDDEN, typeNumber == TYPE_FORBIDDEN);\n    setFlag(account, FLAG_INDEX_POWERLIST, typeNumber == TYPE_POWERLISTED);\n    emit AddressTypeUpdate(account, typeNumber);\n  }\n\n  function setType(address[] calldata addressesToAdd, uint8 value) public onlyOwner {\n    for (uint i=0; i<addressesToAdd.length; i++){\n      setType(addressesToAdd, value);\n    }\n  }\n\n  /**\n   * If true, this address is allowlisted and can only transfer tokens to other allowlisted addresses.\n   */\n  function canReceiveFromAnyone(address account) public view returns (bool) {\n    return hasFlagInternal(account, FLAG_INDEX_ALLOWLIST) || hasFlagInternal(account, FLAG_INDEX_POWERLIST);\n  }\n\n  /**\n   * If true, this address can only transfer tokens to allowlisted addresses and not receive from anyone.\n   */\n  function isForbidden(address account) public view returns (bool){\n    return hasFlagInternal(account, FLAG_INDEX_FORBIDDEN);\n  }\n\n  /**\n   * If true, this address can automatically allowlist target addresses if necessary.\n   */\n  function isPowerlisted(address account) public view returns (bool) {\n    return hasFlagInternal(account, FLAG_INDEX_POWERLIST);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) override virtual internal {\n    super._beforeTokenTransfer(from, to, amount);\n    // empty block for gas saving fall through\n    // solhint-disable-next-line no-empty-blocks\n    if (canReceiveFromAnyone(to)){\n      // ok, transfers to allowlisted addresses are always allowed\n    } else if (isForbidden(to)){\n      // Target is forbidden, but maybe restrictions have been removed and we can clean the flag\n      require(!restrictTransfers, \"not allowed\");\n      setFlag(to, FLAG_INDEX_FORBIDDEN, false);\n    } else {\n      if (isPowerlisted(from)){\n        // it is not allowlisted, but we can make it so\n        // we know the recipient is neither forbidden, allowlisted or powerlisted, so we can set flag directly\n        setFlag(to, FLAG_INDEX_ALLOWLIST, true);\n      }\n      // if we made it to here, the target must be a free address and we are not powerlisted\n      else if (hasFlagInternal(from, FLAG_INDEX_ALLOWLIST)){\n        // We cannot send to free addresses, but maybe the restrictions have been removed and we can clean the flag?\n        require(!restrictTransfers, \"not allowed\");\n        setFlag(from, FLAG_INDEX_ALLOWLIST, false);\n      } else if (isForbidden(from)){\n        require(!restrictTransfers, \"not allowed\");\n        setFlag(from, FLAG_INDEX_FORBIDDEN, false);\n      }\n    }\n  }\n\n}\n"
    },
    "src/shares/AllowlistDraggableShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/ERC20Allowlistable.sol\";\nimport \"./DraggableShares.sol\";\n\ncontract AllowlistDraggableShares is ERC20Allowlistable, DraggableShares {\n\n  constructor(\n    string memory _terms,\n    IERC20 _wrappedToken,\n    uint256 _quorum,\n    uint256 _votePeriod,\n    IRecoveryHub _recoveryHub,\n    IOfferFactory _offerFactory,\n    address _oracle,\n    address _owner\n  )\n    DraggableShares(_terms, _wrappedToken, _quorum, _votePeriod, _recoveryHub, _offerFactory, _oracle)\n    Ownable(_owner)\n  {\n    // initialization is done in ERC20Allowlistbale and DraggableShares\n  }\n\n  function transfer(address to, uint256 value) virtual override(ERC20Flaggable, DraggableShares) public returns (bool) {\n      return super.transfer(to, value);\n  }\n  \n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Allowlistable, DraggableShares) internal {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n}"
    },
    "src/shares/DraggableShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../draggable/ERC20Draggable.sol\";\n\n/**\n * @title CompanyName AG Shares SHA\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * This is an ERC-20 token representing share tokens of CompanyName AG that are bound to\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\n */\ncontract DraggableShares is ERC20Draggable, ERC20Recoverable {\n\n    string public terms;\n\n    constructor(\n        string memory _terms,\n        IERC20 _wrappedToken,\n        uint256 _quorumBps,\n        uint256 _votePeriodSeconds,\n        IRecoveryHub _recoveryHub,\n        IOfferFactory _offerFactory,\n        address _oracle\n    )\n        ERC20Draggable(_wrappedToken, _quorumBps, _votePeriodSeconds, _offerFactory, _oracle)\n        ERC20Recoverable(_recoveryHub) \n    {\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\n        _recoveryHub.setRecoverable(false);\n    }\n\n    function transfer(address to, uint256 value) virtual override(ERC20Flaggable, ERC20Recoverable) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Let the oracle act as deleter of invalid claims. In earlier versions, this was referring to the claim deleter\n     * of the wrapped token. But that stops working after a successful acquisition as the acquisition currency most\n     * likely does not have a claim deleter.\n     */\n    function getClaimDeleter() public view override returns (address) {\n        return oracle;\n    }\n\n    function getCollateralRate(IERC20 collateralType) public view override returns (uint256) {\n        uint256 rate = super.getCollateralRate(collateralType);\n        if (rate > 0) {\n            return rate;\n        } else {\n            // as long as it is binding, the conversion rate is 1:1\n            uint256 factor = isBinding() ? 1 : unwrapConversionFactor;\n            if (address(collateralType) == address(wrapped)) {\n                // allow wrapped token as collateral\n                return factor;\n            } else {\n                // If the wrapped contract allows for a specific collateral, we should too.\n                // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\n                return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * factor;\n            }\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Flaggable, ERC20Draggable) internal {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n}"
    },
    "src/draggable/ERC20Draggable.sol": {
      "content": "/**\n * SPDX-License-Identifier: LicenseRef-Aktionariat\n *\n * MIT License with Automated License Fee Payments\n *\n * Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n *\n * Permission is hereby granted to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - All automated license fee payments integrated into this and related Software\n *   are preserved.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-20 tokens subject to a drag-along agreement\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * This is an ERC-20 token that is bound to a shareholder or other agreement that contains\n * a drag-along clause. The smart contract can help enforce this drag-along clause in case\n * an acquirer makes an offer using the provided functionality. If a large enough quorum of\n * token holders agree, the remaining token holders can be automatically \"dragged along\" or\n * squeezed out. For shares non-tokenized shares, the contract relies on an external Oracle\n * to provide the votes of those.\n *\n * Subclasses should provide a link to a human-readable form of the agreement.\n */\n\nimport \"./IDraggable.sol\";\nimport \"../ERC20/ERC20Flaggable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\nimport \"./IOffer.sol\";\nimport \"./IOfferFactory.sol\";\nimport \"../shares/IShares.sol\";\n\nabstract contract ERC20Draggable is IERC677Receiver, IDraggable, ERC20Flaggable {\n    \n\t// If flag is not present, one can be sure that the address did not vote. If the \n\t// flag is present, the address might have voted and one needs to check with the\n\t// current offer (if any) when transferring tokens.\n\tuint8 private constant FLAG_VOTE_HINT = 1;\n\n\tIERC20 public wrapped; // The wrapped contract\n\tIOfferFactory public immutable factory;\n\n\t// If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\n\tuint256 public unwrapConversionFactor = 0;\n\n\t// The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\n\tIOffer public offer;\n\n\tuint256 private constant QUORUM_MULTIPLIER = 10000;\n\n\tuint256 public immutable quorum; // BPS (out of 10'000)\n\tuint256 public immutable votePeriod; // In seconds\n\n\taddress public override oracle;\n\n\tevent MigrationSucceeded(address newContractAddress, uint256 yesVotes, uint256 oracleVotes, uint256 totalVotingPower);\n\tevent ChangeOracle(address oracle);\n\n    /**\n\t * Note that the Brokerbot only supports tokens that revert on failure and where transfer never returns false.\n     */\n\tconstructor(\n\t\tIERC20 _wrappedToken,\n\t\tuint256 _quorum,\n\t\tuint256 _votePeriod,\n\t\tIOfferFactory _offerFactory,\n\t\taddress _oracle\n\t) \n\t\tERC20Flaggable(0)\n\t{\n\t\twrapped = _wrappedToken;\n\t\tquorum = _quorum;\n\t\tvotePeriod = _votePeriod;\n\t\tfactory = _offerFactory;\n\t\toracle = _oracle;\n\t}\n\n\tfunction onTokenTransfer(\n\t\taddress from, \n\t\tuint256 amount, \n\t\tbytes calldata\n\t) external override returns (bool) {\n\t\trequire(msg.sender == address(wrapped), \"sender\");\n\t\t_mint(from, amount);\n\t\treturn true;\n\t}\n\n\t/** Wraps additional tokens, thereby creating more ERC20Draggable tokens. */\n\tfunction wrap(address shareholder, uint256 amount) external {\n\t\trequire(wrapped.transferFrom(msg.sender, address(this), amount), \"transfer\");\n\t\t_mint(shareholder, amount);\n\t}\n\n\t/**\n\t * Indicates that the token holders are bound to the token terms and that:\n\t * - Conversion back to the wrapped token (unwrap) is not allowed\n\t * - A drag-along can be performed by making an according offer\n\t * - They can be migrated to a new version of this contract in accordance with the terms\n\t */\n\tfunction isBinding() public view returns (bool) {\n\t\treturn unwrapConversionFactor == 0;\n\t}\n\n    /**\n\t * Current recommended naming convention is to add the postfix \"SHA\" to the plain shares\n\t * in order to indicate that this token represents shares bound to a shareholder agreement.\n\t */\n\tfunction name() public view override returns (string memory) {\n\t\tstring memory wrappedName = wrapped.name();\n\t\tif (isBinding()) {\n\t\t\treturn string(abi.encodePacked(wrappedName, \" SHA\"));\n\t\t} else {\n\t\t\treturn string(abi.encodePacked(wrappedName, \" (Wrapped)\"));\n\t\t}\n\t}\n\n\tfunction symbol() public view override returns (string memory) {\n\t\t// ticker should be less dynamic than name\n\t\treturn string(abi.encodePacked(wrapped.symbol(), \"S\"));\n\t}\n\n\t/**\n\t * Deactivates the drag-along mechanism and enables the unwrap function.\n\t */\n\tfunction deactivate(uint256 factor) internal {\n\t\trequire(factor >= 1, \"factor\");\n\t\tunwrapConversionFactor = factor;\n\t\temit NameChanged(name(), symbol());\n\t}\n\n\t/** Decrease the number of drag-along tokens. The user gets back their shares in return */\n\tfunction unwrap(uint256 amount) external {\n\t\trequire(!isBinding(), \"factor\");\n\t\tunwrap(msg.sender, amount, unwrapConversionFactor);\n\t}\n\n\tfunction unwrap(address owner, uint256 amount, uint256 factor) internal {\n\t\t_burn(owner, amount);\n\t\trequire(wrapped.transfer(owner, amount * factor), \"transfer\");\n\t}\n\n\t/**\n\t * Burns both the token itself as well as the wrapped token!\n\t * If you want to get out of the shareholder agreement, use unwrap after it has been\n\t * deactivated by a majority vote or acquisition.\n\t *\n\t * Burning only works if wrapped token supports burning. Also, the exact meaning of this\n\t * operation might depend on the circumstances. Burning and reussing the wrapped token\n\t * does not free the sender from the legal obligations of the shareholder agreement.\n\t */\n\tfunction burn(uint256 amount) external {\n\t\t_burn(msg.sender, amount);\n\t\tIShares(address(wrapped)).burn (isBinding() ? amount : amount * unwrapConversionFactor);\n\t}\n\n\tfunction makeAcquisitionOffer(\n\t\tbytes32 salt, \n\t\tuint256 pricePerShare, \n\t\tIERC20 currency\n\t) external payable {\n\t\trequire(isBinding(), \"factor\");\n\t\tIOffer newOffer = factory.create{value: msg.value}(\n\t\t\tsalt, msg.sender, pricePerShare, currency, quorum, votePeriod);\n\n\t\tif (offerExists()) {\n\t\t\toffer.makeCompetingOffer(newOffer);\n\t\t}\n\t\toffer = newOffer;\n\t}\n\n\tfunction drag(address buyer, IERC20 currency) external override offerOnly {\n\t\tunwrap(buyer, balanceOf(buyer), 1);\n\t\treplaceWrapped(currency, buyer);\n\t}\n\n\tfunction notifyOfferEnded() external override offerOnly {\n\t\toffer = IOffer(address(0));\n\t}\n\n\tfunction replaceWrapped(IERC20 newWrapped, address oldWrappedDestination) internal {\n\t\trequire(isBinding(), \"factor\");\n\t\t// Free all old wrapped tokens we have\n\t\trequire(wrapped.transfer(oldWrappedDestination, wrapped.balanceOf(address(this))), \"transfer\");\n\t\t// Count the new wrapped tokens\n\t\twrapped = newWrapped;\n\t\tdeactivate(newWrapped.balanceOf(address(this)) / totalSupply());\n\t}\n\n\tfunction setOracle(address newOracle) external {\n\t\trequire(msg.sender == oracle, \"not oracle\");\n\t\toracle = newOracle;\n\t\temit ChangeOracle(oracle);\n\t}\n\n\tfunction migrateWithExternalApproval(address successor, uint256 additionalVotes) external {\n\t\trequire(msg.sender == oracle, \"not oracle\");\n\t\t// Additional votes cannot be higher than the votes not represented by these tokens.\n\t\t// The assumption here is that more shareholders are bound to the shareholder agreement\n\t\t// that this contract helps enforce and a vote among all parties is necessary to change\n\t\t// it, with an oracle counting and reporting the votes of the others.\n\t\trequire(totalSupply() + additionalVotes <= totalVotingTokens(), \"votes\");\n\t\tmigrate(successor, additionalVotes);\n\t}\n\n\tfunction migrate() external {\n\t\tmigrate(msg.sender, 0);\n\t}\n\n\tfunction migrate(address successor, uint256 additionalVotes) internal {\n\t\tuint256 yesVotes = additionalVotes + balanceOf(successor);\n\t\tuint256 totalVotes = totalVotingTokens();\n\t\trequire(yesVotes <= totalVotes, \"votes\");\n\t\trequire(!offerExists(), \"no offer\"); // if you have the quorum, you can cancel the offer first if necessary\n\t\trequire(yesVotes * QUORUM_MULTIPLIER >= totalVotes * quorum, \"quorum\");\n\t\treplaceWrapped(IERC20(successor), successor);\n\t\temit MigrationSucceeded(successor, yesVotes, additionalVotes, totalVotes);\n\t}\n\n\tfunction votingPower(address voter) external view override returns (uint256) {\n\t\treturn balanceOf(voter);\n\t}\n\n\tfunction totalVotingTokens() public view override returns (uint256) {\n\t\treturn IShares(address(wrapped)).totalShares();\n\t}\n\n\tfunction hasVoted(address voter) internal view returns (bool) {\n\t\treturn hasFlagInternal(voter, FLAG_VOTE_HINT);\n\t}\n\n\tfunction notifyVoted(address voter) external override offerOnly {\n\t\tsetFlag(voter, FLAG_VOTE_HINT, true);\n\t}\n\n\tmodifier offerOnly(){\n\t\trequire(msg.sender == address(offer), \"sender\");\n\t\t_;\n\t}\n\n\tfunction _beforeTokenTransfer(address from, address to,\tuint256 amount) internal virtual override {\n\t\tif (hasVoted(from) || hasVoted(to)) {\n\t\t\tif (offerExists()) {\n\t\t\t\toffer.notifyMoved(from, to, amount);\n\t\t\t} else {\n\t\t\t\tsetFlag(from, FLAG_VOTE_HINT, false);\n\t\t\t\tsetFlag(to, FLAG_VOTE_HINT, false);\n\t\t\t}\n\t\t}\n\t\tsuper._beforeTokenTransfer(from, to, amount);\n\t}\n\n\tfunction offerExists() internal view returns (bool) {\n\t\treturn address(offer) != address(0);\n\t}\n}\n"
    },
    "src/draggable/IDraggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\ninterface IDraggable {\n    \n    function oracle() external view returns (address);\n    function drag(address buyer, IERC20 currency) external;\n    function notifyOfferEnded() external;\n    function votingPower(address voter) external returns (uint256);\n    function totalVotingTokens() external view returns (uint256);\n    function notifyVoted(address voter) external;\n\n}"
    },
    "src/draggable/IOffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IOffer {\n\tfunction makeCompetingOffer(IOffer newOffer) external;\n\n\t// if there is a token transfer while an offer is open, the votes get transfered too\n\tfunction notifyMoved(address from, address to, uint256 value) external;\n\n\tfunction currency() external view returns (IERC20);\n\n\tfunction price() external view returns (uint256);\n\n\tfunction isWellFunded() external view returns (bool);\n}"
    },
    "src/draggable/IOfferFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IOffer.sol\";\n\ninterface IOfferFactory {\n\n\tfunction create(\n\t\tbytes32 salt, address buyer, uint256 pricePerShare,\tIERC20 currency,\tuint256 quorum,\tuint256 votePeriod\n\t) external payable returns (IOffer);\n}"
    },
    "src/draggable/OfferFactory.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./Offer.sol\";\nimport \"./IOffer.sol\";\nimport \"./IOfferFactory.sol\";\n\ncontract OfferFactory is IOfferFactory{\n\n    // It must be possible to predict the address of the offer so one can pre-fund the allowance.\n    function predictOfferAddress(bytes32 salt, address buyer, IDraggable token, uint256 pricePerShare, IERC20 currency, uint256 quorum, uint256 votePeriod) external view returns (address) {\n        bytes32 initCodeHash = keccak256(abi.encodePacked(type(Offer).creationCode, abi.encode(buyer, token, pricePerShare, currency, quorum, votePeriod)));\n        bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash));\n        return address(uint160(uint256(hashResult)));\n    }\n\n    // Do not call directly, msg.sender must be the token to be acquired\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, IERC20 currency, uint256 quorum, uint256 votePeriod) override external payable returns (IOffer) {\n        IOffer offer = new Offer{value: msg.value, salt: salt}(buyer, IDraggable(msg.sender), pricePerShare, currency, quorum, votePeriod);\n        return offer;\n    }\n}"
    },
    "src/draggable/Offer.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IDraggable.sol\";\nimport \"./IOffer.sol\";\n/**\n * @title A public offer to acquire all tokens\n * @author Luzius Meisser, luzius@aktionariat.com\n */\n\ncontract Offer is IOffer {\n\n    address private constant LICENSE_FEE_ADDRESS = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D;\n\n    uint256 private constant AQUISITION_GRACE_PERIOD = 30 days;     // buyer has thirty days to complete acquisition after voting ends\n    \n    uint256 private constant BPS_MUL = 10000;           // basis point multiplier to be used with quorum\n\n    uint256 public immutable quorum;                    // Percentage of votes needed to start drag-along process in BPS, i.e. 10'000 = 100%\n\n    IDraggable public immutable token;\n    address public immutable buyer;                     // who made the offer\n    \n    IERC20 override public immutable currency;\n    uint256 override public immutable price;            // the price offered per share\n\n    enum Vote { NONE, YES, NO }                         // Used internally, represents not voted yet or yes/no vote.\n    mapping (address => Vote) private votes;            // Who votes what\n    uint256 public yesVotes;                            // total number of yes votes, including external votes\n    uint256 public noVotes;                             // total number of no votes, including external votes\n    uint256 public noExternal;                          // number of external no votes reported by oracle\n    uint256 public yesExternal;                         // number of external yes votes reported by oracle\n\n    uint256 public immutable voteEnd;                   // end of vote period in block time (seconds after 1.1.1970)\n\n    event VotesChanged(uint256 yesVotes, uint256 noVotes);\n    event OfferCreated(address indexed buyer, IDraggable indexed token, uint256 pricePerShare, IERC20 indexed currency);\n    event OfferEnded(address indexed buyer, bool indexed success, string message);\n\n    // Not checked here, but buyer should make sure it is well funded from the beginning\n    constructor(\n        address _buyer,\n        IDraggable _token,\n        uint256 _price,\n        IERC20 _currency,\n        uint256 _quorum,\n        uint256 _votePeriod\n    ) \n        payable \n    {\n        buyer = _buyer;\n        token = _token;\n        currency = _currency;\n        price = _price;\n        quorum = _quorum;\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        voteEnd = block.timestamp + _votePeriod;\n        emit OfferCreated(_buyer, _token, _price, _currency);\n        // License Fee to Aktionariat AG, also ensures that offer is serious.\n        // Any circumvention of this license fee payment is a violation of the copyright terms.\n        payable(LICENSE_FEE_ADDRESS).transfer(3 ether);\n    }\n\n    function makeCompetingOffer(IOffer betterOffer) external override {\n        require(msg.sender == address(token), \"invalid caller\");\n        require(!isAccepted(), \"old already accepted\");\n        require(currency == betterOffer.currency() && betterOffer.price() > price, \"old offer better\");\n        require(betterOffer.isWellFunded(), \"not funded\");\n        kill(false, \"replaced\");\n    }\n\n    function hasExpired() internal view returns (bool) {\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > voteEnd + AQUISITION_GRACE_PERIOD; \n    }\n\n    function contest() external {\n        if (hasExpired()) {\n            kill(false, \"expired\");\n        } else if (isDeclined()) {\n            kill(false, \"declined\");\n        } else if (!isWellFunded()) {\n            kill(false, \"lack of funds\");\n        }\n    }\n\n    function cancel() external {\n        require(msg.sender == buyer, \"invalid caller\");\n        kill(false, \"cancelled\");\n    }\n\n    function execute() external {\n        require(msg.sender == buyer, \"not buyer\");\n        require(isAccepted(), \"not accepted\");\n        uint256 totalPrice = getTotalPrice();\n        require(currency.transferFrom(buyer, address(token), totalPrice), \"transfer failed\");\n        token.drag(buyer, currency);\n        kill(true, \"success\");\n    }\n\n    function getTotalPrice() internal view returns (uint256) {\n        IERC20 tok = IERC20(address(token));\n        return (tok.totalSupply() - tok.balanceOf(buyer)) * price;\n    }\n\n    function isWellFunded() public view override returns (bool) {\n        uint256 buyerBalance = currency.balanceOf(buyer);\n        uint256 totalPrice = getTotalPrice();\n        return totalPrice <= buyerBalance;\n    }\n\n    function isAccepted() public view returns (bool) {\n        if (isVotingOpen()) {\n            // is it already clear that more than the quorum requiered will vote yes even though the vote is not over yet?\n            return yesVotes * BPS_MUL  >= quorum * token.totalVotingTokens();\n        } else {\n            // did more than the quorum requiered votes say 'yes'?\n            return yesVotes * BPS_MUL >= quorum * (yesVotes + noVotes);\n        }\n    }\n\n    function isDeclined() public view returns (bool) {\n        if (isVotingOpen()) {\n            // is it already clear that 25% will vote no even though the vote is not over yet?\n            uint256 supply = token.totalVotingTokens();\n            return (supply - noVotes) * BPS_MUL < quorum * supply;\n        } else {\n            // did quorum% of all cast votes say 'no'?\n            return BPS_MUL * yesVotes < quorum * (yesVotes + noVotes);\n        }\n    }\n\n    function notifyMoved(address from, address to, uint256 value) external override {\n        require(msg.sender == address(token), \"invalid caller\");\n        if (isVotingOpen()) {\n            Vote fromVoting = votes[from];\n            Vote toVoting = votes[to];\n            update(fromVoting, toVoting, value);\n        }\n    }\n\n    function update(Vote previousVote, Vote newVote, uint256 votes_) internal {\n        if (previousVote != newVote) {\n            if (previousVote == Vote.NO) {\n                noVotes -= votes_;\n            } else if (previousVote == Vote.YES) {\n                yesVotes -= votes_;\n            }\n            if (newVote == Vote.NO) {\n                noVotes += votes_;\n            } else if (newVote == Vote.YES) {\n                yesVotes += votes_;\n            }\n            emit VotesChanged(yesVotes, noVotes);\n        }\n    }\n\n    function isVotingOpen() public view returns (bool) {\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp <= voteEnd;\n    }\n\n    modifier votingOpen() {\n        require(isVotingOpen(), \"vote ended\");\n        _;\n    }\n\n    /**\n     * Function to allow the oracle to report the votes of external votes (e.g. shares tokenized on other blockchains).\n     * This functions is idempotent and sets the number of external yes and no votes. So when more votes come in, the\n     * oracle should always report the total number of yes and no votes. Abstentions are not counted.\n     */\n    function reportExternalVotes(uint256 yes, uint256 no) external {\n        require(msg.sender == token.oracle(), \"not oracle\");\n        require(yes + no + IERC20(address(token)).totalSupply() <= token.totalVotingTokens(), \"too many votes\");\n        // adjust total votes taking into account that the oralce might have reported different counts before\n        yesVotes = yesVotes - yesExternal + yes;\n        noVotes = noVotes - noExternal + no;\n        // remember how the oracle voted in case the oracle later reports updated numbers\n        yesExternal = yes;\n        noExternal = no;\n    }\n\n    function voteYes() external {\n        vote(Vote.YES);\n    }\n\n    function voteNo() external { \n        vote(Vote.NO);\n    }\n\n    function vote(Vote newVote) internal votingOpen() {\n        Vote previousVote = votes[msg.sender];\n        votes[msg.sender] = newVote;\n        if(previousVote == Vote.NONE){\n            token.notifyVoted(msg.sender);\n        }\n        update(previousVote, newVote, token.votingPower(msg.sender));\n    }\n\n    function hasVotedYes(address voter) external view returns (bool) {\n        return votes[voter] == Vote.YES;\n    }\n\n    function hasVotedNo(address voter) external view returns (bool) {\n        return votes[voter] == Vote.NO;\n    }\n\n    function kill(bool success, string memory message) internal {\n        emit OfferEnded(buyer, success, message);\n        token.notifyOfferEnded();\n        selfdestruct(payable(buyer));\n    }\n\n}"
    },
    "src/recovery/RecoveryHub.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./IRecoveryHub.sol\";\nimport \"./IRecoverable.sol\";\nimport \"../ERC20/IERC20.sol\";\n\ncontract RecoveryHub is IRecoveryHub {\n\n    // A struct that represents a claim made\n    struct Claim {\n        address claimant; // the person who created the claim\n        uint256 collateral; // the amount of collateral deposited\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\n        IERC20 currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\n    }\n\n    mapping(IRecoverable => mapping (address => Claim)) public claims; // there can be at most one claim per token and claimed address\n    mapping(address => bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\n\n    event ClaimMade(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 balance);\n    event ClaimCleared(IRecoverable indexed token, address indexed lostAddress, uint256 collateral);\n    event ClaimDeleted(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\n    event ClaimResolved(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\n\n    function setRecoverable(bool enabled) external override {\n        recoveryDisabled[msg.sender] = !enabled;\n    }\n\n    /**\n     * Some users might want to disable claims for their address completely.\n     * For example if they use a deep cold storage solution or paper wallet.\n     */\n    function isRecoverable(address target) public view returns (bool) {\n        return !recoveryDisabled[target];\n    }\n\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\n    * 2) The \"lost\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\n    *    whenever someone transfers funds to let claims be resolved automatically when the \"lost\" private key is\n    *    used again.\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\n    *    rightful owner of the deposit.\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\n    * through a shareholder register).\n    */\n    function declareLost(IRecoverable token, IERC20 collateralType, address lostAddress) external {\n        require(isRecoverable(lostAddress), \"disabled\");\n        uint256 collateralRate = IRecoverable(token).getCollateralRate(collateralType);\n        require(collateralRate > 0, \"bad collateral\");\n        uint256 balance = IERC20(token).balanceOf(lostAddress);\n        require(balance > 0, \"empty\");\n        uint256 collateral = balance * collateralRate;\n        IERC20 currency = IERC20(collateralType);\n        require(claims[token][lostAddress].collateral == 0, \"already claimed\");\n\n        claims[token][lostAddress] = Claim({\n            claimant: msg.sender,\n            collateral: collateral,\n            // rely on time stamp is ok, no exact time stamp needed\n            // solhint-disable-next-line not-rely-on-time\n            timestamp: block.timestamp,\n            currencyUsed: collateralType\n        });\n        emit ClaimMade(token, lostAddress, msg.sender, balance);\n        \n        require(currency.transferFrom(msg.sender, address(this), collateral), \"transfer failed\");\n\n        IRecoverable(token).notifyClaimMade(lostAddress);\n    }\n\n    function getClaimant(IRecoverable token, address lostAddress) external view returns (address) {\n        return claims[token][lostAddress].claimant;\n    }\n\n    function getCollateral(IRecoverable token, address lostAddress) external view returns (uint256) {\n        return claims[token][lostAddress].collateral;\n    }\n\n    function getCollateralType(IRecoverable token, address lostAddress) external view returns (IERC20) {\n        return claims[token][lostAddress].currencyUsed;\n    }\n\n    function getTimeStamp(IRecoverable token, address lostAddress) external view returns (uint256) {\n        return claims[token][lostAddress].timestamp;\n    }\n\n    /**\n     * Clears a claim after the key has been found again and assigns the collateral to the \"lost\" address.\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\n     */\n    function clearClaimFromToken(address holder) external override {\n        clearClaim(IRecoverable(msg.sender), holder);\n    }\n\n    function clearClaimFromUser(IRecoverable token) external {\n        clearClaim(token, msg.sender);\n    }\n\n    function clearClaim(IRecoverable token, address holder) private {\n        Claim memory claim = claims[token][holder];\n        if (claim.collateral > 0){\n            IERC20 currency = IERC20(claim.currencyUsed);\n            delete claims[token][holder];\n            require(currency.transfer(holder, claim.collateral), \"could not return collateral\");\n            emit ClaimCleared(token, holder, claim.collateral);\n        }\n        IRecoverable(token).notifyClaimDeleted(holder);\n    }\n\n   /**\n    * After the claim period has passed, the claimant can call this function to send the\n    * tokens on the lost address as well as the collateral to himself.\n    */\n    function recover(IRecoverable token, address lostAddress) external {\n        Claim memory claim = claims[token][lostAddress];\n        address claimant = claim.claimant;\n        require(claimant == msg.sender, \"not claimant\");\n        uint256 collateral = claim.collateral;\n        IERC20 currency = IERC20(claim.currencyUsed);\n        require(collateral != 0, \"not found\");\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        require(claim.timestamp + IRecoverable(token).claimPeriod() <= block.timestamp, \"too early\");\n        delete claims[token][lostAddress];\n        emit ClaimResolved(token, lostAddress, claimant, collateral);\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\n        require(currency.transfer(claimant, collateral), \"transfer failed\");\n        IRecoverable(token).recover(lostAddress, claimant);\n    }\n\n    /**\n     * The token contract can delete claims. It is the responsibility of the token contract to make sure\n     * only authorized parties can trigger such a call.\n     */\n    function deleteClaim(address lostAddress) external override {\n        IRecoverable token = IRecoverable(msg.sender);\n        Claim memory claim = claims[token][lostAddress];\n        IERC20 currency = IERC20(claim.currencyUsed);\n        require(claim.collateral != 0, \"not found\");\n        delete claims[token][lostAddress];\n        emit ClaimDeleted(token, lostAddress, claim.claimant, claim.collateral);\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\n        require(currency.transfer(claim.claimant, claim.collateral), \"transfer failed\");\n    }\n\n}"
    },
    "src/ERC20/ERC20Basic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Named.sol\";\n\ncontract ERC20Basic is ERC20Named {\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, address _admin) ERC20Named(_symbol, _name, _decimals, _admin) {\n        // intentially left empty\n    }\n\n    function mint(address target, uint256 amount) external onlyOwner {\n        _mint(target, amount);\n    }\n\n}"
    },
    "src/brokerbot/PaymentHub.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IUniswapV3.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"./IBrokerbot.sol\";\nimport \"../utils/PriceAware.sol\";\n\n/**\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\n * Instead, an allowance needs to be set only once, namely for this contract.\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap or the reception of Ether\n * using the current exchange rate as found in the chainlink oracle.\n */\ncontract PaymentHub is PriceAware{\n\n    uint24 private constant DEFAULT_FEE = 3000;\n    uint256 private constant DENOMINATOR = 1e8;\n    address private constant CHF_TOKEN = 0xB4272071eCAdd69d933AdcD19cA99fe80664fc08;\n    address private constant TRUSTED_SIGNER = 0x0C39486f770B26F5527BBBf942726537986Cd7eb; // redstone main demo provider\n\n    uint8 private constant KEEP_ETHER = 0x4; // copied from brokerbot\n    \n    IQuoter private immutable uniswapQuoter;\n    ISwapRouter private immutable uniswapRouter;\n\n    constructor(IQuoter _quoter, ISwapRouter swapRouter) {\n        uniswapQuoter = _quoter;\n        uniswapRouter = swapRouter;\n    }\n\n    function isSignerAuthorized(address _receviedSigner) public override virtual view returns (bool) {\n        return _receviedSigner == TRUSTED_SIGNER;\n    }\n\n    /*  \n     * Get price in ERC20\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\n     * @param amountInBase The amount of the base currency for the exact output.\n     * @param path The encoded path of the swap from erc20 to base.\n     * @return amount quoted to pay\n     */\n    function getPriceInERC20(uint256 amountInBase, bytes memory path) public returns (uint256) {\n        return uniswapQuoter.quoteExactOutput(\n            path,\n            amountInBase\n        );\n    }\n\n    /**\n     * Get price in Ether depding on brokerbot setting.\n     * If keep ETH is set price is from oracle.\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\n     * @return The price in wei.\n     */\n    function getPriceInEther(uint256 amountInBase, IBrokerbot brokerBot) public returns (uint256) {\n        if ((address(brokerBot) != address(0)) && hasSettingKeepEther(brokerBot)) {\n            return getPriceInEtherFromOracle(amountInBase, IBrokerbot(brokerBot).base());\n        } else {\n            return uniswapQuoter.quoteExactOutputSingle(uniswapQuoter.WETH9(), address(brokerBot.base()), DEFAULT_FEE, amountInBase, 0);\n        }\n    }\n\n    /**\n     * Price in ETH with 18 decimals\n     */\n    function getPriceInEtherFromOracle(uint256 amountInBase, IERC20 base) public view returns (uint256) {\n        if(address(base) == CHF_TOKEN) {\n            return getLatestPriceCHFUSD() * amountInBase / getLatestPriceETHUSD();\n        } else {\n            return amountInBase * DENOMINATOR / getLatestPriceETHUSD();\n        }\n    }\n\n    /**\n     * Returns the latest price of eth/usd pair from chainlink with 8 decimals\n     */\n    function getLatestPriceETHUSD() public view returns (uint256) {\n        return getPriceFromMsg(bytes32(\"ETH\"));\n    }\n\n    /**\n     * Returns the latest price of chf/usd pair from redstoneainlink with 8 decimals\n     */\n    function getLatestPriceCHFUSD() public view returns (uint256) {\n        return getPriceFromMsg(bytes32(\"CHF\"));\n    }\n\n    /**\n     * Convenience method to swap ether into base and pay a target address\n     */\n    function payFromEther(address recipient, uint256 amountInBase, IERC20 base) public payable {\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\n            // rely on time stamp is ok, no exact time stamp needed\n            // solhint-disable-next-line not-rely-on-time\n            uniswapQuoter.WETH9(), address(base), DEFAULT_FEE, recipient, block.timestamp, amountInBase, msg.value, 0);\n\n        ISwapRouter swapRouter = uniswapRouter;\n        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.\n        uint256 amountIn = swapRouter.exactOutputSingle{value: msg.value}(params);\n\n        // For exact output swaps, the amountInMaximum may not have all been spent.\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\n        if (amountIn < msg.value) {\n            swapRouter.refundETH();\n            (bool success, ) = msg.sender.call{value:msg.value - amountIn}(\"\"); // return change\n            require(success, \"Transfer failed.\");\n        }\n    }\n\n    /// @dev The calling address must approve this contract to spend its ERC20 for this function to succeed. As the amount of input ERC20 is variable,\n    /// the calling address will need to approve for a slightly higher or infinit amount, anticipating some variance.\n    /// @param amountOut The desired amount of baseCurrency.\n    /// @param amountInMaximum The maximum amount of ERC20 willing to be swapped for the specified amountOut of baseCurrency.\n    /// @param erc20In The address of the erc20 token to pay with.\n    /// @param path The encoded path of the swap from erc20 to base.\n    /// @param recipient The reciving address - brokerbot.\n    /// @return amountIn The amountIn of ERC20 actually spent to receive the desired amountOut.\n    function payFromERC20(uint256 amountOut, uint256 amountInMaximum, address erc20In, bytes memory path, address recipient) public returns (uint256 amountIn) {\n        ISwapRouter swapRouter = uniswapRouter;\n        // Transfer the specified `amountInMaximum` to this contract.\n        IERC20(erc20In).transferFrom(msg.sender, address(this), amountInMaximum);\n\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\n        ISwapRouter.ExactOutputParams memory params =\n            ISwapRouter.ExactOutputParams({\n                path: path,\n                recipient: recipient,\n                // solhint-disable-next-line not-rely-on-time\n                deadline: block.timestamp,\n                amountOut: amountOut,\n                amountInMaximum: amountInMaximum\n            });\n\n        // Executes the swap, returning the amountIn actually spent.\n        amountIn = swapRouter.exactOutput(params);\n\n        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.\n        if (amountIn < amountInMaximum) {\n            IERC20(erc20In).transfer(msg.sender, amountInMaximum - amountIn);\n        }\n    }\n\n    ///This function appoves infinite allowance for Uniswap, this is safe as the paymenthub should never hold any token (see also recover() ).\n    ///@dev This function needs to be called before using the PaymentHub the first time with a new ERC20 token.\n    ///@param erc20In The erc20 addresse to approve.\n    function approveERC20(address erc20In) external {\n        IERC20(erc20In).approve(address(uniswapRouter), 0x8000000000000000000000000000000000000000000000000000000000000000);\n    }\n\n    function multiPay(IERC20 token, address[] calldata recipients, uint256[] calldata amounts) public {\n        for (uint i=0; i<recipients.length; i++) {\n            require(IERC20(token).transferFrom(msg.sender, recipients[i], amounts[i]));\n        }\n    }\n\n    /**\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\n     */\n    function multiPayAndNotify(IERC20 token, address[] calldata recipients, uint256[] calldata amounts, bytes calldata ref) external {\n        for (uint i=0; i<recipients.length; i++) {\n            payAndNotify(token, recipients[i], amounts[i], ref);\n        }\n    }\n\n    // Allows to make a payment from the sender to an address given an allowance to this contract\n    // Equivalent to xchf.transferAndCall(recipient, amountInBase)\n    function payAndNotify(address recipient, uint256 amountInBase, bytes calldata ref) external {\n        payAndNotify(IBrokerbot(recipient).base(), recipient, amountInBase, ref);\n    }\n\n    function payAndNotify(IERC20 token, address recipient, uint256 amount, bytes calldata ref) public {\n        require(IERC20(token).transferFrom(msg.sender, recipient, amount));\n        IBrokerbot(recipient).processIncoming(token, msg.sender, amount, ref);\n    }\n\n    function payFromEtherAndNotify(IBrokerbot recipient, uint256 amountInBase, bytes calldata ref) external payable {\n        IERC20 base = recipient.base();\n        // Check if the brokerbot has setting to keep ETH\n        if (hasSettingKeepEther(recipient)) {\n            uint256 priceInEther = getPriceInEtherFromOracle(amountInBase, base);\n            recipient.processIncoming{value: priceInEther}(base, msg.sender, amountInBase, ref);\n\n            // Pay back ETH that was overpaid\n            if (priceInEther < msg.value) {\n                (bool success, ) = msg.sender.call{value:msg.value - priceInEther}(\"\"); // return change\n                require(success, \"Transfer failed.\");\n            }\n\n        } else {\n            payFromEther(address(recipient), amountInBase, base);\n            recipient.processIncoming(base, msg.sender, amountInBase, ref);\n        }\n    }\n\n    /***\n     * Pay from any ERC20 token (which has Uniswapv3 ERC20-ETH pool) and send swapped base currency to brokerbot.\n     * The needed amount needs to be approved at the ERC20 contract beforehand\n     */\n    function payFromERC20AndNotify(address recipient, uint256 amountBase, address erc20, uint256 amountInMaximum, bytes memory path, bytes calldata ref) external {\n        IERC20 base = IBrokerbot(recipient).base();\n        uint256 balanceBefore = IERC20(base).balanceOf(recipient);\n        payFromERC20(amountBase, amountInMaximum, erc20, path, recipient);\n        uint256 balanceAfter = IERC20(base).balanceOf(recipient);\n        require(amountBase == (balanceAfter - balanceBefore), \"swap error\");\n        IBrokerbot(recipient).processIncoming(base, msg.sender, balanceAfter - balanceBefore, ref);\n    }\n\n    /**\n     * Checks if the recipient(brokerbot) has setting enabled to keep ether\n     */\n    function hasSettingKeepEther(IBrokerbot recipient) public view returns (bool) {\n        return recipient.settings() & KEEP_ETHER == KEEP_ETHER;\n    }\n\n    /**\n     * In case tokens have been accidentally sent directly to this contract.\n     * Make sure to be fast as anyone can call this!\n     */\n    function recover(IERC20 ercAddress, address to, uint256 amount) external {\n        require(ercAddress.transfer(to, amount));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {\n        // Important to receive ETH refund from Uniswap\n    }\n}\n"
    },
    "src/brokerbot/IUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\npragma solidity ^0.8.0;\n\ninterface IQuoter {\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n    \n    // solhint-disable-next-line func-name-mixedcase\n    function WETH9() external view returns (address);\n}\n\ninterface ISwapRouter {\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n    \n    function refundETH() external payable;\n}"
    },
    "src/brokerbot/IBrokerbot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IBrokerbot {\n\n  function base() external view returns (IERC20);\n  \n  function settings() external view returns (uint256);\n\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\n\n}"
    },
    "src/utils/PriceAware.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/redstone-finance/redstone-evm-connector/blob/master/contracts/message-based/PriceAware.sol\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\nabstract contract PriceAware {\n  using ECDSA for bytes32;\n\n  uint256 constant _MAX_DATA_TIMESTAMP_DELAY = 3 * 60; // 3 minutes\n  uint256 constant _MAX_BLOCK_TIMESTAMP_DELAY = 15; // 15 seconds\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDEN IN CHILD CONTRACTS) ========== */\n\n  function getMaxDataTimestampDelay() public virtual view returns (uint256) {\n    return _MAX_DATA_TIMESTAMP_DELAY;\n  }\n\n  function getMaxBlockTimestampDelay() public virtual view returns (uint256) {\n    return _MAX_BLOCK_TIMESTAMP_DELAY;\n  }\n\n  function isSignerAuthorized(address _receviedSigner) public virtual view returns (bool);\n\n  function isTimestampValid(uint256 _receivedTimestamp) public virtual view returns (bool) {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    require(\n      (block.timestamp + getMaxBlockTimestampDelay()) > _receivedTimestamp,\n      \"Data with future timestamps is not allowed\");\n\n    return block.timestamp < _receivedTimestamp\n      || block.timestamp - _receivedTimestamp < getMaxDataTimestampDelay();\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDEN) ========== */\n\n  function getPriceFromMsg(bytes32 symbol) internal view returns (uint256) {bytes32[] memory symbols = new bytes32[](1); symbols[0] = symbol;\n    return getPricesFromMsg(symbols)[0];\n  }\n\n  function getPricesFromMsg(bytes32[] memory symbols) internal view returns (uint256[] memory) {\n    // The structure of calldata witn n - data items:\n    // The data that is signed (symbols, values, timestamp) are inside the {} brackets\n    // [origina_call_data| ?]{[[symbol | 32][value | 32] | n times][timestamp | 32]}[size | 1][signature | 65]\n\n    // 1. First we extract dataSize - the number of data items (symbol,value pairs) in the message\n    uint8 dataSize; //Number of data entries\n    assembly {\n      // Calldataload loads slots of 32 bytes\n      // The last 65 bytes are for signature\n      // We load the previous 32 bytes and automatically take the 2 least significant ones (casting to uint16)\n      dataSize := calldataload(sub(calldatasize(), 97))\n    }\n\n    // 2. We calculate the size of signable message expressed in bytes\n    // ((symbolLen(32) + valueLen(32)) * dataSize + timeStamp length\n    uint16 messageLength = uint16(dataSize) * 64 + 32; //Length of data message in bytes\n\n    // 3. We extract the signableMessage\n\n    // (That's the high level equivalent 2k gas more expensive)\n    // bytes memory rawData = msg.data.slice(msg.data.length - messageLength - 65, messageLength);\n\n    bytes memory signableMessage;\n    assembly {\n      signableMessage := mload(0x40)\n      mstore(signableMessage, messageLength)\n      // The starting point is callDataSize minus length of data(messageLength), signature(65) and size(1) = 66\n      calldatacopy(\n        add(signableMessage, 0x20),\n        sub(calldatasize(), add(messageLength, 66)),\n        messageLength\n      )\n      mstore(0x40, add(signableMessage, 0x20))\n    }\n\n    // 4. We first hash the raw message and then hash it again with the prefix\n    // Following the https://github.com/ethereum/eips/issues/191 standard\n    bytes32 hash = keccak256(signableMessage);\n    bytes32 hashWithPrefix = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n    );\n\n    // 5. We extract the off-chain signature from calldata\n\n    // (That's the high level equivalent 2k gas more expensive)\n    // bytes memory signature = msg.data.slice(msg.data.length - 65, 65);\n    bytes memory signature;\n    assembly {\n      signature := mload(0x40)\n      mstore(signature, 65)\n      calldatacopy(add(signature, 0x20), sub(calldatasize(), 65), 65)\n      mstore(0x40, add(signature, 0x20))\n    }\n\n    // 6. We verify the off-chain signature against on-chain hashed data\n\n    address signer = hashWithPrefix.recover(signature);\n    require(isSignerAuthorized(signer), \"Signer not authorized\");\n\n    // 7. We extract timestamp from callData\n\n    uint256 dataTimestamp;\n    assembly {\n      // Calldataload loads slots of 32 bytes\n      // The last 65 bytes are for signature + 1 for data size\n      // We load the previous 32 bytes\n      dataTimestamp := calldataload(sub(calldatasize(), 98))\n    }\n\n    // 8. We validate timestamp\n    require(isTimestampValid(dataTimestamp), \"Data timestamp is invalid\");\n\n    return _readFromCallData(symbols, uint256(dataSize), messageLength);\n  }\n\n  function _readFromCallData(bytes32[] memory symbols, uint256 dataSize, uint16 messageLength) private pure returns (uint256[] memory) {\n    uint256[] memory values;\n    uint256 i;\n    uint256 j;\n    uint256 readyAssets;\n    bytes32 currentSymbol;\n\n    // We iterate directly through call data to extract the values for symbols\n    assembly {\n      let start := sub(calldatasize(), add(messageLength, 66))\n\n      values := msize()\n      mstore(values, mload(symbols))\n      mstore(0x40, add(add(values, 0x20), mul(mload(symbols), 0x20)))\n\n      for { i := 0 } lt(i, dataSize) { i := add(i, 1) } {\n        currentSymbol := calldataload(add(start, mul(i, 64)))\n\n        for { j := 0 } lt(j, mload(symbols)) { j := add(j, 1) } {\n          if eq(mload(add(add(symbols, 32), mul(j, 32))), currentSymbol) {\n            mstore(\n              add(add(values, 32), mul(j, 32)),\n              calldataload(add(add(start, mul(i, 64)), 32))\n            )\n            readyAssets := add(readyAssets, 1)\n          }\n\n          if eq(readyAssets, mload(symbols)) {\n            i := dataSize\n          }\n        }\n      }\n    }\n\n    return (values);\n  }\n}"
    },
    "src/utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol\n\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}"
    },
    "src/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}"
    },
    "src/brokerbot/Brokerbot.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* Proprietary License\n*\n* This code cannot be used without an explicit permission from the copyright holder.\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\n*\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com), All rights reserved.\n*/\npragma solidity ^0.8.0;\n\nimport \"../utils/Ownable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\nimport \"./IBrokerbot.sol\";\n\ncontract Brokerbot is IBrokerbot, Ownable {\n\n    address public paymenthub;\n\n    IERC20 public override immutable base;  // ERC-20 currency\n    IERC20 public immutable token; // ERC-20 share token\n\n    uint256 private price; // current offer price in base currency, without drift\n    uint256 public increment; // increment step the price in/decreases when buying/selling\n\n    uint256 public driftStart;\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\n    int256 public driftIncrement;\n\n    // Note that these settings might be hard-coded in various places, so better not change these values.\n    uint8 private constant BUYING_ENABLED = 0x1;\n    uint8 private constant SELLING_ENABLED = 0x2;\n    // note that in the UI, we call the setting \"convert ether\", which is the opposite\n    uint8 private constant KEEP_ETHER = 0x4;\n\n    // Version history\n    // Version 2: added ability to process bank orders even if buying disabled\n    // Version 3: added various events, removed license fee\n    uint8 private constant VERSION = 0x3;\n\n    // more bits to be used by payment hub\n    uint256 public override settings = BUYING_ENABLED | SELLING_ENABLED | (VERSION<<248);\n\n    event Trade(IERC20 indexed token, address who, bytes ref, int amount, IERC20 base, uint totPrice, uint fee, uint newprice);\n    event PaymentHubUpdate(address indexed paymentHub);\n    event PriceSet(uint256 price, uint256 increment);\n    event DriftSet(uint256 timeToDrift, int256 driftIncrement);\n    event SettingsChange(uint256 setting);\n\n    constructor(\n        IERC20 _token,\n        uint256 _price,\n        uint256 _increment,\n        IERC20 _base,\n        address _owner,\n        address _paymentHub\n    )\n        Ownable(_owner)\n    {\n        base = _base;\n        token = _token;\n        price = _price;\n        increment = _increment;\n        paymenthub = _paymentHub;\n        // Should we disabled recoverability in the recovery hub here?\n        // No, if someone attacks us, we can always trigger a transfer and recover the tokens as well as the collateral.\n    }\n\n    function setPrice(uint256 _price, uint256 _increment) external onlyOwner {\n        anchorPrice(_price);\n        increment = _increment;\n        emit PriceSet(_price, _increment);\n    }\n\n    function hasDrift() public view returns (bool) {\n        return timeToDrift != 0;\n    }\n\n    // secondsPerStep should be negative for downwards drift\n    function setDrift(uint256 secondsPerStep, int256 _driftIncrement) external onlyOwner {\n        anchorPrice(getPrice());\n        timeToDrift = secondsPerStep;\n        driftIncrement = _driftIncrement;\n        emit DriftSet(secondsPerStep, _driftIncrement);\n    }\n\n    function anchorPrice(uint256 currentPrice) private {\n        price = currentPrice;\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        driftStart = block.timestamp;\n    }\n\n    function getPrice() public view returns (uint256) {\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        return getPriceAtTime(block.timestamp);\n    }\n\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\n        if (hasDrift()){\n            uint256 passed = timestamp - driftStart;\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\n            int256 driftedPrice = int256(price) + drifted;\n            if (driftedPrice < 0){\n                return 0;\n            } else {\n                return uint256(driftedPrice);\n            }\n        } else {\n            return price;\n        }\n    }\n\n    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\n        require(hasSetting(BUYING_ENABLED), \"buying disabled\");\n        uint shares = getShares(paid);\n        uint costs = notifyTraded(from, shares, ref);\n        if (costs < paid){\n            IERC20(base).transfer(from, paid - costs);\n        }\n        IERC20(token).transfer(from, shares);\n        return shares;\n    }\n\n    // Callers must verify that (hasSetting(BUYING_ENABLED) || msg.sender == owner) holds!\n    function notifyTraded(address from, uint256 shares, bytes calldata ref) internal returns (uint256) {\n        // disabling the requirement below for efficiency as this always holds once we reach this point\n        // require(hasSetting(BUYING_ENABLED) || msg.sender == owner, \"buying disabled\");\n        uint costs = getBuyPrice(shares);\n        price = price + (shares * increment);\n        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\n        return costs;\n    }\n\n    function notifyTrade(address buyer, uint256 shares, bytes calldata ref) external onlyOwner {\n        notifyTraded(buyer, shares, ref);\n    }\n\n    function notifyTradeAndTransfer(address buyer, uint256 shares, bytes calldata ref) public onlyOwner {\n        notifyTraded(buyer, shares, ref);\n        IERC20(token).transfer(buyer, shares);\n    }\n\n    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTraded(buyers[i], shares[i], ref[i]);\n        }\n    }\n\n    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTradeAndTransfer(buyers[i], shares[i], ref[i]);\n        }\n    }\n\n    /**\n     * Payment hub might actually have sent another accepted token, including Ether.\n     */\n    function processIncoming(IERC20 incomingAsset, address from, uint256 amount, bytes calldata ref) public override payable returns (uint256) {\n        require(msg.sender == address(incomingAsset) || msg.sender == paymenthub, \"invalid caller\");\n        if (incomingAsset == token){\n            return sell(from, amount, ref);\n        } else if (incomingAsset == base){\n            return buy(from, amount, ref);\n        } else {\n            revert(\"invalid token\");\n        }\n    }\n\n    // ERC-677 recipient\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) external returns (bool) {\n        processIncoming(IERC20(msg.sender), from, amount, ref);\n        return true;\n    }\n\n    function hasSetting(uint256 setting) private view returns (bool) {\n        return settings & setting == setting;\n    }\n\n    /**\n     * ref 0x01 or old format sells shares for base currency.\n     * ref 0x02 indicates a sell via bank transfer.\n     */\n    function isDirectSale(bytes calldata ref) internal pure returns (bool) {\n        if (ref.length == 0 || ref.length == 20) {\n            return true; // old format\n        } else {\n            if (ref[0] == bytes1(0x01)){\n                return true;\n            } else if (ref[0] == bytes1(0x02)) {\n                return false;\n            } else {\n                revert(\"unknown ref\");\n            }\n        }\n    }\n\n\n    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\n        require(hasSetting(SELLING_ENABLED), \"selling disabled\");\n        uint256 totPrice = getSellPrice(amount);\n        IERC20 baseToken = IERC20(base);\n        price -= amount * increment;\n        if (isDirectSale(ref)){\n            baseToken.transfer(recipient, totPrice);\n        }\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, 0, getPrice());\n        return totPrice;\n    }\n\n    function getSellPrice(uint256 shares) public view returns (uint256) {\n        return getPrice(getPrice() - (shares * increment), shares);\n    }\n\n    function getBuyPrice(uint256 shares) public view returns (uint256) {\n        return getPrice(getPrice(), shares);\n    }\n\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\n        if (shares == 0) {\n            return 0;\n        } else {\n            uint256 highest = lowest + (shares - 1) * increment;\n            return ((lowest + highest) / 2) * shares;\n        }\n    }\n\n    function getShares(uint256 money) public view returns (uint256) {\n        uint256 currentPrice = getPrice();\n        uint256 min = 0;\n        uint256 max = money / currentPrice;\n        while (min < max){\n            uint256 middle = (min + max)/2;\n            uint256 totalPrice = getPrice(currentPrice, middle);\n            if (money > totalPrice){\n                min = middle + 1;\n            } else {\n                max = middle;\n            }\n        }\n        return min;\n    }\n\n    function withdrawEther(uint256 amount) external ownerOrHub() {\n        (bool success, ) = msg.sender.call{value:amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function approve(address erc20, address who, uint256 amount) external onlyOwner() {\n        IERC20(erc20).approve(who, amount);\n    }\n\n    function withdraw(address ercAddress, address to, uint256 amount) external ownerOrHub() {\n        IERC20(ercAddress).transfer(to, amount);\n    }\n\n    function setPaymentHub(address hub) external onlyOwner() {\n        paymenthub = hub;\n        emit PaymentHubUpdate(paymenthub);\n    }\n\n    function setSettings(uint256 _settings) public onlyOwner() {\n        settings = _settings;\n        emit SettingsChange(_settings);\n    }\n\n    function setEnabled(bool _buyingEnabled, bool _sellingEnabled) external onlyOwner() {\n        uint256 _settings = settings;\n        if (_buyingEnabled != hasSetting(BUYING_ENABLED)){\n            _settings ^= BUYING_ENABLED;\n        }\n        if (_sellingEnabled != hasSetting(SELLING_ENABLED)){\n            _settings ^= SELLING_ENABLED;\n        }\n        setSettings(_settings);\n    }\n    \n    modifier ownerOrHub() {\n        require(owner == msg.sender || paymenthub == msg.sender, \"not owner nor hub\");\n        _;\n    }\n}"
    },
    "src/ERC20/IL2StandardERC20.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"./IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IL2StandardERC20 is IERC20, IERC165 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/optimism/OptimismShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../shares/Shares.sol\";\n import { IL2StandardERC20 } from \"../ERC20/IL2StandardERC20.sol\";\n\ncontract OptimismShares is Shares, IL2StandardERC20 {\n    address public override l1Token;\n    address public l2Bridge;\n\n    constructor(\n    address _l2Bridge,\n    address _l1Token,\n    string memory _symbol,\n    string memory _name,\n    string memory _terms,\n    uint256 _totalShares,\n    IRecoveryHub _recoveryHub,\n    address _owner\n    )\n      Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub)\n    {\n      l2Bridge = _l2Bridge;\n      l1Token = _l1Token;\n    }\n\n    modifier onlyL2Bridge() {\n      require(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");\n      _;\n    }\n\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure override returns (bool) {\n        bytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^\n            IL2StandardERC20.mint.selector ^\n            IL2StandardERC20.burn.selector;\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual override(Shares, IL2StandardERC20) onlyL2Bridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual override onlyL2Bridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n\n}"
    },
    "@eth-optimism/contracts/standards/IL2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IL2StandardERC20 is IERC20, IERC165 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/optimism/SimpleXCHF.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IL2StandardERC20 } from \"@eth-optimism/contracts/standards/IL2StandardERC20.sol\";\n\n\ncontract SimpleCryptoFranc is IL2StandardERC20, ERC20, Ownable {\n    address public l1Token;\n    address public l2Bridge;\n\n    string constant public version = \"1.0.0.0\";\n\n    // EVENTS\n    event ChangeL2Bridge(address indexed from, address indexed to);\n    event ChangeL1Token(address indexed from, address indexed to);\n\n    // CONSTRUCTORS\n\n    constructor(\n        address _l2Bridge,\n        address _l1Token\n    ) ERC20(\"CryptoFranc\", \"XCHF\") {\n        l1Token = _l1Token;\n        l2Bridge = _l2Bridge;\n    }\n\n    modifier onlyL2Bridge() {\n        require(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\n        bytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^\n            IL2StandardERC20.mint.selector ^\n            IL2StandardERC20.burn.selector;\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n\n    function setL2Bridge(address _l2Bridge) external onlyOwner {\n        emit ChangeL2Bridge(l2Bridge, _l2Bridge);\n        l2Bridge = _l2Bridge;\n    }\n\n    function setL1Token(address _l1Token) external onlyOwner {\n        emit ChangeL1Token(l1Token, _l1Token);\n        l1Token = _l1Token;\n    }\n\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual onlyL2Bridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual onlyL2Bridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n\n\n    /*\n        Helper FUNCTIONS\n    */\n\n    /// @dev helper function to return foreign tokens accidental send to contract address\n    /// @param _tokenaddress Address of foreign ERC20 contract\n    /// @param _to Address to send foreign tokens to\n    function refundForeignTokens(address _tokenaddress,address _to) public onlyOwner {\n        IERC20 token = IERC20(_tokenaddress);\n        // transfer current balance for this contract to _to  in token contract\n        token.transfer(_to, token.balanceOf(address(this)));\n    }\n}"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "src/multisig/MultiSigCloneFactory.sol": {
      "content": "\n/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.0;\n\nimport \"./MultiSigWallet.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract MultiSigCloneFactory {\n\n  address immutable public multiSigImplementation;\n\n  event ContractCreated(address indexed contractAddress, string indexed typeName);\n\n  constructor(address _multiSigImplementation) {\n    multiSigImplementation = _multiSigImplementation;\n  }\n  \n  function predict(bytes32 salt) external view returns (address) {\n    return Clones.predictDeterministicAddress(multiSigImplementation, salt);\n  }\n\n  function create(address owner, bytes32 salt) external returns (MultiSigWallet) {\n    address payable instance = payable(Clones.cloneDeterministic(multiSigImplementation, salt));\n    MultiSigWallet(instance).initialize(owner);\n    emit ContractCreated(instance, \"MultiSigWallet\");\n    return MultiSigWallet(instance);\n  }\n}"
    },
    "src/multisig/MultiSigWallet.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Address.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"./RLPEncode.sol\";\nimport \"./Nonce.sol\";\n\n/**\n * Documented in ../../doc/multisig.md\n */\ncontract MultiSigWallet is Nonce, Initializable {\n\n  mapping (address => uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\n\n  uint16 public signerCount;\n  bytes public contractId; // most likely unique id of this contract\n\n  event SignerChange(\n    address indexed signer,\n    uint8 signaturesNeeded\n  );\n\n  event Transacted(\n    address indexed toAddress,  // The address the transaction was sent to\n    bytes4 selector, // selected operation\n    address[] signers // Addresses of the signers used to initiate the transaction\n  );\n\n  event Received(address indexed sender, uint amount);\n\n  function initialize(address owner) external initializer {\n    // We use the gas price field to get a unique id into our transactions.\n    // Note that 32 bits do not guarantee that no one can generate a contract with the\n    // same id, but it practically rules out that someone accidentally creates two\n    // two multisig contracts with the same id, and that's all we need to prevent\n    // replay-attacks.\n    contractId = toBytes(uint32(uint160(address(this))));\n    signerCount = 0;\n    _setSigner(owner, 1); // set initial owner\n  }\n\n  /**\n   * It should be possible to store ether on this address.\n   */\n  receive() external payable {\n    emit Received(msg.sender, msg.value);\n  }\n\n  /**\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\n   */\n  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external view returns (address[] memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\n    return verifySignatures(transactionHash, v, r, s);\n  }\n\n  /**\n   * Checks if the execution of a transaction would succeed if it was properly signed.\n   */\n  function checkExecution(address to, uint value, bytes calldata data) external {\n    Address.functionCallWithValue(to, data, value);\n    revert(\"Test passed. Reverting.\");\n  }\n\n  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external returns (bytes memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\n    flagUsed(nonce);\n    emit Transacted(to, extractSelector(data), found);\n    return returndata;\n  }\n\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\n    if (data.length < 4){\n      return bytes4(0);\n    } else {\n      return bytes4(data[0]) | (bytes4(data[1]) >> 8) | (bytes4(data[2]) >> 16) | (bytes4(data[3]) >> 24);\n    }\n  }\n\n  function toBytes(uint number) internal pure returns (bytes memory){\n    uint len = 0;\n    uint temp = 1;\n    while (number >= temp){\n      temp = temp << 8;\n      len++;\n    }\n    temp = number;\n    bytes memory data = new bytes(len);\n    for (uint i = len; i>0; i--) {\n      data[i-1] = bytes1(uint8(temp));\n      temp = temp >> 8;\n    }\n    return data;\n  }\n\n  // Note: does not work with contract creation\n  function calculateTransactionHash(uint128 sequence, bytes memory id, address to, uint value, bytes calldata data)\n    internal view returns (bytes32){\n    bytes[] memory all = new bytes[](9);\n    all[0] = toBytes(sequence); // sequence number instead of nonce\n    all[1] = id; // contract id instead of gas price\n    all[2] = toBytes(21000); // gas limit\n    all[3] = abi.encodePacked(to);\n    all[4] = toBytes(value);\n    all[5] = data;\n    all[6] = toBytes(block.chainid);\n    all[7] = toBytes(0);\n    for (uint i = 0; i<8; i++){\n      all[i] = RLPEncode.encodeBytes(all[i]);\n    }\n    all[8] = all[7];\n    return keccak256(RLPEncode.encodeList(all));\n  }\n\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\n    public view returns (address[] memory) {\n    address[] memory found = new address[](r.length);\n    for (uint i = 0; i < r.length; i++) {\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\n      uint8 signaturesNeeded = signers[signer];\n      require(signaturesNeeded > 0 && signaturesNeeded <= r.length, \"cosigner error\");\n      found[i] = signer;\n    }\n    requireNoDuplicates(found);\n    return found;\n  }\n\n  function requireNoDuplicates(address[] memory found) private pure {\n    for (uint i = 0; i < found.length; i++) {\n      for (uint j = i+1; j < found.length; j++) {\n        require(found[i] != found[j], \"duplicate signature\");\n      }\n    }\n  }\n\n  /**\n   * Call this method through execute\n   */\n  function setSigner(address signer, uint8 signaturesNeeded) external authorized {\n    _setSigner(signer, signaturesNeeded);\n    require(signerCount > 0, \"signer count 0\");\n  }\n\n  function migrate(address destination) external {\n    _migrate(msg.sender, destination);\n  }\n\n  function migrate(address source, address destination) external authorized {\n    _migrate(source, destination);\n  }\n\n  function _migrate(address source, address destination) private {\n    require(signers[destination] == 0, \"destination not new\"); // do not overwrite existing signer!\n    _setSigner(destination, signers[source]);\n    _setSigner(source, 0);\n  }\n\n  function _setSigner(address signer, uint8 signaturesNeeded) private {\n    require(!Address.isContract(signer), \"signer cannot be a contract\");\n    require(signer != address(0x0), \"0x0 signer\");\n    uint8 prevValue = signers[signer];\n    signers[signer] = signaturesNeeded;\n    if (prevValue > 0 && signaturesNeeded == 0){\n      signerCount--;\n    } else if (prevValue == 0 && signaturesNeeded > 0){\n      signerCount++;\n    }\n    emit SignerChange(signer, signaturesNeeded);\n  }\n\n  modifier authorized() {\n    require(address(this) == msg.sender || signers[msg.sender] == 1, \"not authorized\");\n    _;\n  }\n\n}"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "src/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n        return account.code.length > 0;\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\n        require(data.length == 0 || isContract(target), \"transfer or contract\");\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            assembly{\n                revert (add (returndata, 0x20), mload (returndata))\n            }\n        } else {\n           revert(\"failed\");\n        }\n    }\n}"
    },
    "src/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Modifier to protect the initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(!_initialized, \"already initialized\");\n        _;\n        _initialized = true;\n    }\n\n}"
    },
    "src/multisig/RLPEncode.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n/**\n * @title RLPEncode\n * @dev A simple RLP encoding library.\n * @author Bakaoh\n */\nlibrary RLPEncode {\n    /*\n     * Internal functions\n     */\n\n    /**\n     * @dev RLP encodes a byte string.\n     * @param self The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        bytes memory encoded;\n        if (self.length == 1 && uint8(self[0]) <= 128) {\n            encoded = self;\n        } else {\n            encoded = abi.encodePacked(encodeLength(self.length, 128), self);\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        bytes memory list = flatten(self);\n        return abi.encodePacked(encodeLength(list.length, 192), list);\n    }\n\n    /*\n     * Private functions\n     */\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint len, uint offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint lenLen;\n            uint i = 1;\n            while (len >= i) {\n                lenLen++;\n                i <<= 8;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen-i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function memcpy(uint _dest, uint _src, uint _len) private pure {\n        uint dest = _dest;\n        uint src = _src;\n        uint len = _len;\n\n        for(; len >= 32; len -= 32) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint mask = type(uint).max >> (len << 3);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint len;\n        uint i;\n        for (i = 0; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint flattenedPtr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n            \n            uint listPtr;\n            // solhint-disable-next-line no-inline-assembly\n            assembly { listPtr := add(item, 0x20)}\n\n            memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += item.length;\n        }\n\n        return flattened;\n    }\n\n}"
    },
    "src/multisig/Nonce.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\ncontract Nonce {\n\n    uint256 public constant MAX_INCREASE = 100;\n    \n    uint256 private compound;\n    \n    constructor(){\n        setBoth(128, 0);\n    }\n    \n    /**\n     * The next recommended nonce, which is the highest nonce ever used plus one.\n     * The initial nonce is 129.\n     */\n    function nextNonce() external view returns (uint128){\n        return getMax() + 1;\n    }\n\n    /**\n     * Returns whether the provided nonce can be used.\n     * For the 100 nonces in the interval [nextNonce(), nextNonce + 99], this is always true.\n     * For the nonces in the interval [nextNonce() - 129, nextNonce() - 1], this is true for the nonces that have not been used yet.\n     */ \n    function isFree(uint128 nonce) external view returns (bool){\n        uint128 max = getMax();\n        return isValidHighNonce(max, nonce) || isValidLowNonce(max, getRegister(), nonce);\n    }\n\n    /**\n     * Flags the given nonce as used.\n     * Reverts if the provided nonce is not free.\n     */\n    function flagUsed(uint128 nonce) internal {\n        uint256 comp = compound;\n        uint128 max = uint128(comp);\n        uint128 reg = uint128(comp >> 128);\n        if (isValidHighNonce(max, nonce)){\n            setBoth(nonce, ((reg << 1) | 0x1) << (nonce - max - 1));\n        } else if (isValidLowNonce(max, reg, nonce)){\n            setBoth(max, uint128(reg | 0x1 << (max - nonce - 1)));\n        } else {\n            revert(\"used\");\n        }\n    }\n    \n    function getMax() private view returns (uint128) {\n        return uint128(compound);\n    }\n    \n    function getRegister() private view returns (uint128) {\n        return uint128(compound >> 128);\n    }\n    \n    function setBoth(uint128 max, uint128 reg) private {\n        compound = uint256(reg) << 128 | max;\n    }\n\n    function isValidHighNonce(uint128 max, uint128 nonce) private pure returns (bool){\n        return nonce > max && nonce <= max + MAX_INCREASE;\n    }\n\n    function isValidLowNonce(uint128 max, uint128 reg, uint128 nonce) private pure returns (bool){\n        uint256 diff = max - nonce;\n        return diff > 0 && diff <= 128 && ((0x1 << (diff - 1)) & reg == 0);\n    }\n    \n}"
    },
    "src/multisig/MultiSigWalletV2.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Address.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"./RLPEncode.sol\";\nimport \"./Nonce.sol\";\n\n/**\n * Documented in ../../doc/multisig.md\n */\ncontract MultiSigWalletV2 is Nonce, Initializable {\n\n  mapping (address => uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\n\n  uint16 public signerCount;\n  bytes public contractId; // most likely unique id of this contract\n\n  event SignerChange(\n    address indexed signer,\n    uint8 signaturesNeeded\n  );\n\n  event Transacted(\n    address indexed toAddress,  // The address the transaction was sent to\n    bytes4 selector, // selected operation\n    address[] signers // Addresses of the signers used to initiate the transaction\n  );\n\n  event Received(address indexed sender, uint amount);\n\n  function initialize(address owner) external initializer {\n    // We use the gas price field to get a unique id into our transactions.\n    // Note that 32 bits do not guarantee that no one can generate a contract with the\n    // same id, but it practically rules out that someone accidentally creates two\n    // two multisig contracts with the same id, and that's all we need to prevent\n    // replay-attacks.\n    contractId = toBytes(uint32(uint160(address(this))));\n    signerCount = 0;\n    _setSigner(owner, 1); // set initial owner\n  }\n\n  /**\n   * It should be possible to store ether on this address.\n   */\n  receive() external payable {\n    emit Received(msg.sender, msg.value);\n  }\n\n  /**\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\n   */\n  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external view returns (address[] memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\n    return verifySignatures(transactionHash, v, r, s);\n  }\n\n  /**\n   * Checks if the execution of a transaction would succeed if it was properly signed.\n   */\n  function checkExecution(address to, uint value, bytes calldata data) external {\n    Address.functionCallWithValue(to, data, value);\n    revert(\"Test passed. Reverting.\");\n  }\n\n  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external returns (bytes memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\n    flagUsed(nonce);\n    emit Transacted(to, extractSelector(data), found);\n    return returndata;\n  }\n\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\n    if (data.length < 4){\n      return bytes4(0);\n    } else {\n      return bytes4(data[0]) | (bytes4(data[1]) >> 8) | (bytes4(data[2]) >> 16) | (bytes4(data[3]) >> 24);\n    }\n  }\n\nfunction toBytes (uint256 x) public pure returns (bytes memory result) {\n  uint l = 0;\n  uint xx = x;\n  if (x >= 0x100000000000000000000000000000000) { x >>= 128; l += 16; }\n  if (x >= 0x10000000000000000) { x >>= 64; l += 8; }\n  if (x >= 0x100000000) { x >>= 32; l += 4; }\n  if (x >= 0x10000) { x >>= 16; l += 2; }\n  if (x >= 0x100) { x >>= 8; l += 1; }\n  if (x > 0x0) { l += 1; }\n  assembly {\n    result := mload (0x40)\n    mstore (0x40, add (result, add (l, 0x20)))\n    mstore (add (result, l), xx)\n    mstore (result, l)\n  }\n}\n\n  // Note: does not work with contract creation\n  function calculateTransactionHash(uint128 sequence, bytes memory id, address to, uint value, bytes calldata data)\n    internal view returns (bytes32){\n    bytes[] memory all = new bytes[](9);\n    all[0] = toBytes(sequence); // sequence number instead of nonce\n    all[1] = id; // contract id instead of gas price\n    all[2] = bytes(\"\\x82\\x52\\x08\"); // 21000 gas limit\n    all[3] = abi.encodePacked (bytes1 (0x94), to);\n    all[4] = toBytes(value);\n    all[5] = data;\n    all[6] = toBytes(block.chainid);\n    all[7] = new bytes(0);\n    for (uint i = 0; i<8; i++){\n      if (i != 2 && i!= 3) {\n        all[i] = RLPEncode.encodeBytes(all[i]);\n      }\n    }\n    all[8] = all[7];\n    return keccak256(RLPEncode.encodeList(all));\n  }\n\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\n    public view returns (address[] memory) {\n    address[] memory found = new address[](r.length);\n    for (uint i = 0; i < r.length; i++) {\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\n      uint8 signaturesNeeded = signers[signer];\n      require(signaturesNeeded > 0 && signaturesNeeded <= r.length, \"cosigner error\");\n      found[i] = signer;\n    }\n    requireNoDuplicates(found);\n    return found;\n  }\n\n  function requireNoDuplicates(address[] memory found) private pure {\n    for (uint i = 0; i < found.length; i++) {\n      for (uint j = i+1; j < found.length; j++) {\n        require(found[i] != found[j], \"duplicate signature\");\n      }\n    }\n  }\n\n  /**\n   * Call this method through execute\n   */\n  function setSigner(address signer, uint8 signaturesNeeded) external authorized {\n    _setSigner(signer, signaturesNeeded);\n    require(signerCount > 0, \"signer count 0\");\n  }\n\n  function migrate(address destination) external {\n    _migrate(msg.sender, destination);\n  }\n\n  function migrate(address source, address destination) external authorized {\n    _migrate(source, destination);\n  }\n\n  function _migrate(address source, address destination) private {\n    require(signers[destination] == 0, \"destination not new\"); // do not overwrite existing signer!\n    _setSigner(destination, signers[source]);\n    _setSigner(source, 0);\n  }\n\n  function _setSigner(address signer, uint8 signaturesNeeded) private {\n    require(!Address.isContract(signer), \"signer cannot be a contract\");\n    require(signer != address(0x0), \"0x0 signer\");\n    uint8 prevValue = signers[signer];\n    signers[signer] = signaturesNeeded;\n    if (prevValue > 0 && signaturesNeeded == 0){\n      signerCount--;\n    } else if (prevValue == 0 && signaturesNeeded > 0){\n      signerCount++;\n    }\n    emit SignerChange(signer, signaturesNeeded);\n  }\n\n  modifier authorized() {\n    require(address(this) == msg.sender || signers[msg.sender] == 1, \"not authorized\");\n    _;\n  }\n\n}"
    },
    "src/utils/XCHF.sol": {
      "content": "/**\n * SPDX-License-Identifier: Apache-2.0\n **/\n\npragma solidity ^0.8.0;\n// input  C:\\projects\\BTCS.CHFToken\\contracts\\Chftoken\\CryptoFranc.sol\ninterface InterestRateInterface {\n\n    /// @notice get compounding level for currenct day\n    function getCurrentCompoundingLevel() external view returns (uint256);\n\n    /// @notice get compounding level for _date `_date`\n    /// @param _date The date \n    function getCompoundingLevelDate(uint256 _date) external view returns (uint256);\n\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ninterface ERC20Interface {\n    /// total amount of tokens\n    function totalSupply() external view returns(uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    // EVENTS\n    \n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IL2StandardERC20 is ERC20Interface, IERC165 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n\nabstract contract Ownable {\n    address public owner;\n    address public newOwner;\n\n    // MODIFIERS\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only Owner\");\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the new owner.\n    modifier onlyNewOwner() {\n        require(msg.sender == newOwner, \"Only New Owner\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0),\"address is Null\");\n        _;\n    }\n\n    // CONSTRUCTORS\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n    /// @param _newOwner The address to transfer ownership to.\n    \n    function transferOwnership(address _newOwner) public notNull(_newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    /// @dev Allow the new owner to claim ownership and so proving that the newOwner is valid.\n    function acceptOwnership() public onlyNewOwner {\n        address oldOwner = owner;\n        owner = newOwner;\n        newOwner = address(0);\n        emit OwnershipTransferred(oldOwner, owner);\n    }\n\n    // EVENTS\n    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n}\n\nabstract contract InterestRateNone is InterestRateInterface {\n\n    uint256 public constant SCALEFACTOR = 1e18;\n    \n    /// @notice get compounding level for currenct day\n    function getCurrentCompoundingLevel() public pure override returns (uint256) {\n        return SCALEFACTOR;\n    }\n\n    /// @notice get compounding level for day `_date`\n    /// param _date The daynumber \n    function getCompoundingLevelDate(uint256 /* _date */) public pure override returns (uint256) {\n        return SCALEFACTOR;\n    }\n\n}\nabstract contract MigrationAgent is Ownable {\n\n    address public migrationToContract; // the contract to migrate to\n    address public migrationFromContract; // the conttactto migate from\n\n    // MODIFIERS\n    \n    modifier onlyMigrationFromContract() {\n        require(msg.sender == migrationFromContract, \"Only from migration contract\");\n        _;\n    }\n    // EXTERNAL FUNCTIONS\n\n    // PUBLIC FUNCTIONS\n\n    /// @dev set contract to migrate to \n    /// @param _toContract Then contract address to migrate to\n    function startMigrateToContract(address _toContract) public onlyOwner {\n        migrationToContract = _toContract;\n        require(MigrationAgent(migrationToContract).isMigrationAgent(), \"not a migratable contract\");\n        emit StartMigrateToContract(address(this), _toContract);\n    }\n\n    /// @dev set contract to migrate from\n    /// @param _fromConstract Then contract address to migrate from\n    function startMigrateFromContract(address _fromConstract) public onlyOwner {\n        migrationFromContract = _fromConstract;\n        require(MigrationAgent(migrationFromContract).isMigrationAgent(), \"not a migratable contract\");\n        emit StartMigrateFromContract(_fromConstract, address(this));\n    }\n\n    /// @dev Each user calls the migrate function on the original contract to migrate the users tokens to the migration agent migrateFrom on the `migrationToContract` contract\n    function migrate() public virtual;   \n\n    /// @dev migrageFrom is called from the migrating contract `migrationFromContract`\n    /// @param _from The account to be migrated into new contract\n    /// @param _value The token balance to be migrated\n    function migrateFrom(address _from, uint256 _value) public virtual returns(bool);\n\n    /// @dev is a valid migration agent\n    /// @return true if contract is a migratable contract\n    function isMigrationAgent() public pure returns(bool) {\n        return true;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    // PRIVATE FUNCTIONS\n\n    // EVENTS\n\n    event StartMigrateToContract(address indexed fromConstract, address indexed toContract);\n\n    event StartMigrateFromContract(address indexed fromConstract, address indexed toContract);\n\n    event MigratedTo(address indexed owner, address indexed _contract, uint256 value);\n\n    event MigratedFrom(address indexed owner, address indexed _contract, uint256 value);\n}\ncontract Pausable is Ownable {\n\n    bool public paused = false;\n\n    // MODIFIERS\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused, \"only when not paused\");\n        _;\n    }\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused, \"only when paused\");\n        _;\n    }\n\n    /**\n    * @dev called by the owner to pause, triggers stopped state\n    */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n    * @dev called by the owner to unpause, returns to normal state\n    */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n\n    // EVENTS\n\n    event Pause();\n\n    event Unpause();\n}\n\nabstract contract Operator is Ownable {\n\n    address public operator;\n\n    // MODIFIERS\n\n    /**\n     * @dev modifier check for operator\n     */\n    modifier onlyOperator {\n        require(msg.sender == operator, \"Only Operator\");\n        _;\n    }\n\n    // CONSTRUCTORS\n\n    constructor() {\n        operator = msg.sender;\n    }\n\n    /**\n     * @dev Transfer operator to `newOperator`.\n     *\n     * @param _newOperator   The address of the new operator\n     */\n    function transferOperator(address _newOperator) public notNull(_newOperator) onlyOwner {\n        operator = _newOperator;\n        emit TransferOperator(operator, _newOperator);\n    }\n\n    // EVENTS\n    \n    event TransferOperator(address indexed from, address indexed to);\n}\n\nabstract contract ERC20Token is Ownable, ERC20Interface {\n\n    using SafeMath for uint256;\n\n    mapping(address => uint256) internal balances;\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    // CONSTRUCTORS\n\n    constructor() {\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public virtual override returns (bool success) {\n\n        return transferInternal(msg.sender, _to, _value);\n    }\n\n    /* ALLOW FUNCTIONS */\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    *\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    */\n   \n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens   \n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public virtual override notNull(_spender) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public virtual override returns (bool success) {\n        require(_value <= allowed[_from][msg.sender], \"insufficient tokens\");\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        return transferInternal(_from, _to, _value);\n    }\n\n    /**\n     * @dev Returns balance of the `_owner`.\n     *\n     * @param _owner   The address whose balance will be returned.\n     * @return balance Balance of the `_owner`.\n     */\n    function balanceOf(address _owner) public virtual override view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) public override view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @notice internal send `_value` token to `_to` from `_from` \n    /// @param _from The address of the sender (null check performed in subTokens)\n    /// @param _to The address of the recipient (null check performed in addTokens)\n    /// @param _value The amount of token to be transferred \n    /// @return Whether the transfer was successful or not\n    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool) {\n        uint256 value = subTokens(_from, _value);\n        addTokens(_to, value);\n        emit Transfer(_from, _to, value);\n        return true;\n    }\n   \n    /// @notice add tokens `_value` tokens to `owner`\n    /// @param _owner The address of the account\n    /// @param _value The amount of tokens to be added\n    function addTokens(address _owner, uint256 _value) internal virtual;\n\n    /// @notice subtract tokens `_value` tokens from `owner`\n    /// @param _owner The address of the account\n    /// @param _value The amount of tokens to be subtracted\n    function subTokens(address _owner, uint256 _value) internal virtual returns (uint256 _valueDeducted );\n    \n    /// @notice set balance of account `owner` to `_value`\n    /// @param _owner The address of the account\n    /// @param _value The new balance \n    function setBalance(address _owner, uint256 _value) internal virtual notNull(_owner) {\n        balances[_owner] = _value;\n    }\n\n    // PRIVATE FUNCTIONS\n\n}\n\nabstract contract PausableToken is ERC20Token, Pausable {\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public override whenNotPaused returns (bool success) {\n        return super.transfer(_to, _value);\n    }\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public override whenNotPaused returns (bool success) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public override whenNotPaused returns (bool success) {\n        return super.approve(_spender, _value);\n    }\n}\n\nabstract contract MintableToken is PausableToken\n{\n    using SafeMath for uint256;\n\n    address public minter; // minter\n\n    uint256 internal minted; // total minted tokens\n    uint256 internal burned; // total burned tokens\n\n    // MODIFIERS\n\n    modifier onlyMinter {\n        assert(msg.sender == minter);\n        _; \n    }\n\n    constructor() {\n        minter = msg.sender;   // Set the owner to minter\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    // PUBLIC FUNCTIONS\n\n    /// @dev  mint tokens to address\n    /// @notice mint `_value` token to `_to`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be minted\n    function _mint(address _to, uint256 _value) internal notNull(_to) {\n        addTokens(_to, _value);\n        notifyMinted(_to, _value);\n    }\n\n    /// @dev burn tokens, e.g. when migrating\n    /// @notice burn `_value` token to `_to`\n    /// @param _value The amount of token to be burned from the callers account\n    function _burn(uint256 _value) internal whenNotPaused {\n        uint256 value = subTokens(msg.sender, _value);\n        notifyBurned(msg.sender, value);\n    }\n\n    /// @dev transfer minter to new address\n    /// @notice transfer minter addres from  `minter` to `_newMinter`\n    /// @param _newMinter The address of the recipient\n    function transferMinter(address _newMinter) public notNull(_newMinter) onlyOwner {\n        address oldMinter = minter;\n        minter = _newMinter;\n        emit TransferMinter(oldMinter, _newMinter);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev update burned and emit Transfer event of burned tokens\n    /// @notice burn `_value` token from `_owner`\n    /// @param _owner The address of the owner\n    /// @param _value The amount of token burned\n    function notifyBurned(address _owner, uint256 _value) internal {\n        burned = burned.add(_value);\n        emit Transfer(_owner, address(0), _value);\n    }\n\n    /// @dev update burned and emit Transfer event of burned tokens\n    /// @notice mint `_value` token to `_to`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token minted\n    function notifyMinted(address _to, uint256 _value) internal {\n        minted = minted.add(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    /// @dev helper function to update token supply state and emit events \n    /// @notice checkMintOrBurn for account `_owner` tokens chainging  from `_balanceBefore` to `_balanceAfter`\n    /// @param _owner The address of the owner\n    /// @param _balanceBefore The balance before the transaction\n    /// @param _balanceAfter The balance after the tranaaction\n    function checkMintOrBurn(address _owner, uint256 _balanceBefore, uint256 _balanceAfter) internal {\n        if (_balanceBefore > _balanceAfter) {\n            uint256 burnedTokens = _balanceBefore.sub(_balanceAfter);\n            notifyBurned(_owner, burnedTokens);\n        } else if (_balanceBefore < _balanceAfter) {\n            uint256 mintedTokens = _balanceAfter.sub(_balanceBefore);\n            notifyMinted(_owner, mintedTokens);\n        }\n    }\n\n    /// @dev return total amount of tokens\n    function totalSupply() public view override returns(uint256 supply) {\n        return minted.sub(burned);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    // EVENTS\n    \n    event TransferMinter(address indexed from, address indexed to);\n}\n\ncontract CryptoFranc is MintableToken, MigrationAgent, Operator, InterestRateNone {\n\n    using SafeMath for uint256;\n\n    string constant public name = \"CryptoFranc\";\n    string constant public symbol = \"XCHF\";\n    uint256 constant public decimals = 18;\n    string constant public version = \"1.0.0.0\";\n    uint256 public dustAmount;\n\n    // Changes as the token is converted to the next vintage\n    string public currentFullName;\n    string public announcedFullName;\n    uint256 public currentMaturityDate;\n    uint256 public announcedMaturityDate;\n    uint256 public currentTermEndDate;\n    uint256 public announcedTermEndDate;\n    InterestRateInterface public currentTerms;\n    InterestRateInterface public announcedTerms;\n\n    mapping(address => uint256) internal compoundedInterestFactor;\n\n    // CONSTRUCTORS\n\n    constructor(string memory _initialFullName, uint256 _dustAmount) {\n        // initially, there is no interest. This contract has an interest-free default implementation\n        // of the InterestRateInterface. Having this internalized saves gas in comparison to having an\n        // external, separate smart contract.\n        currentFullName = _initialFullName;\n        announcedFullName = _initialFullName;\n        dustAmount = _dustAmount;    \n        currentTerms = this;\n        announcedTerms = this;\n        announcedMaturityDate = block.timestamp;\n        announcedTermEndDate = block.timestamp;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    // PUBLIC FUNCTIONS\n\n    /// @dev Invoked by the issuer to convert all the outstanding tokens into bonds of the latest vintage.\n    /// @param _newName Name of announced bond\n    /// @param _newTerms Address of announced bond\n    /// @param _newMaturityDate Maturity Date of announced bond\n    /// @param _newTermEndDate End Date of announced bond\n    function announceRollover(string memory _newName, address _newTerms, uint256 _newMaturityDate, uint256 _newTermEndDate) public notNull(_newTerms) onlyOperator {\n        // a new term can not be announced before the current is expired\n        require(block.timestamp >= announcedMaturityDate);\n\n        // for test purposes\n        uint256 newMaturityDate;\n        if (_newMaturityDate == 0)\n            newMaturityDate = block.timestamp;\n        else\n            newMaturityDate = _newMaturityDate;\n\n        // new newMaturityDate must be at least or greater than the existing announced terms end date\n        require(newMaturityDate >= announcedTermEndDate);\n\n        //require new term dates not too far in the future\n        //this is to prevent severe operator time calculaton errors\n        require(newMaturityDate <= block.timestamp.add(100 days),\"sanitycheck on newMaturityDate\");\n        require(newMaturityDate <= _newTermEndDate,\"term must start before it ends\");\n        require(_newTermEndDate <= block.timestamp.add(200 days),\"sanitycheck on newTermEndDate\");\n\n        InterestRateInterface terms = InterestRateInterface(_newTerms);\n        \n        // ensure that _newTerms begins at the compoundLevel that the announcedTerms ends\n        // they must align\n        uint256 newBeginLevel = terms.getCompoundingLevelDate(newMaturityDate);\n        uint256 annEndLevel = announcedTerms.getCompoundingLevelDate(newMaturityDate);\n        require(annEndLevel == newBeginLevel,\"new initialCompoundingLevel <> old finalCompoundingLevel\");\n\n        //rollover\n        currentTerms = announcedTerms;\n        currentFullName = announcedFullName;\n        currentMaturityDate = announcedMaturityDate;\n        currentTermEndDate = announcedTermEndDate;\n        announcedTerms = terms;\n        announcedFullName = _newName;\n        announcedMaturityDate = newMaturityDate;\n        announcedTermEndDate = _newTermEndDate;\n\n        emit AnnounceRollover(_newName, _newTerms, newMaturityDate, _newTermEndDate);\n    }\n\n    /// @dev collectInterest is called to update the internal state of `_owner` balance and force a interest payment\n    /// This function does not change the effective amount of the `_owner` as returned by balanceOf\n    /// and thus, can be called by anyone willing to pay for the gas.\n    /// The designed usage for this function is to allow the CryptoFranc owner to collect interest from inactive accounts, \n    /// since interest collection is updated automatically in normal transfers\n    /// calling collectInterest is functional equivalent to transfer 0 tokens to `_owner`\n    /// @param _owner The account being updated\n    function collectInterest( address _owner) public notNull(_owner) whenNotPaused {\n        uint256 rawBalance = super.balanceOf(_owner);\n        uint256 adjustedBalance = getAdjustedValue(_owner);\n        setBalance(_owner, adjustedBalance);\n        checkMintOrBurn(_owner, rawBalance, adjustedBalance);\n    }\n\n    /*\n        MIGRATE FUNCTIONS\n     */\n    // safe migrate function\n    /// @dev migrageFrom is called from the migrating contract `migrationFromContract`\n    /// @param _from The account to be migrated into new contract\n    /// @param _value The token balance to be migrated\n    function migrateFrom(address _from, uint256 _value) public override onlyMigrationFromContract returns(bool) {\n        addTokens(_from, _value);\n        notifyMinted(_from, _value);\n\n        emit MigratedFrom(_from, migrationFromContract, _value);\n        return true;\n    }\n\n    /// @dev Each user calls the migrate function on the original contract to migrate the users tokens to the migration agent migrateFrom on the `migrationToContract` contract\n    function migrate() public override whenNotPaused {\n        require(migrationToContract != address(0), \"not in migration mode\"); // revert if not in migrate mode\n        uint256 value = balanceOf(msg.sender);\n        require (value > 0, \"no balance\"); // revert if not value left to transfer\n        value = subTokens(msg.sender, value);\n        notifyBurned(msg.sender, value);\n        require(MigrationAgent(migrationToContract).migrateFrom(msg.sender, value)==true, \"migrateFrom must return true\");\n\n        emit MigratedTo(msg.sender, migrationToContract, value);\n    }\n\n    /*\n        Helper FUNCTIONS\n    */\n\n    /// @dev helper function to return foreign tokens accidental send to contract address\n    /// @param _tokenaddress Address of foreign ERC20 contract\n    /// @param _to Address to send foreign tokens to\n    function refundForeignTokens(address _tokenaddress,address _to) public notNull(_to) onlyOperator {\n        ERC20Interface token = ERC20Interface(_tokenaddress);\n        // transfer current balance for this contract to _to  in token contract\n        token.transfer(_to, token.balanceOf(address(this)));\n    }\n\n    /// @dev get fullname of active interest contract\n    function getFullName() public view returns (string memory) {\n        if ((block.timestamp <= announcedMaturityDate))\n            return currentFullName;\n        else\n            return announcedFullName;\n    }\n\n    /// @dev get compounding level of an owner account\n    /// @param _owner tokens address\n    /// @return The compouding level\n    function getCompoundingLevel(address _owner) public view returns (uint256) {\n        uint256 level = compoundedInterestFactor[_owner];\n        if (level == 0) {\n            // important note that for InterestRateNone or empty accounts the compoundedInterestFactor is newer stored by setBalance\n            return SCALEFACTOR;\n        } else {\n            return level;\n        }\n    }\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) public view override returns (uint256) {\n        return getAdjustedValue(_owner);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @notice add tokens `_value` tokens to `owner`\n    /// @param _owner The address of the account\n    /// @param _value The amount of tokens to be added\n    function addTokens(address _owner,uint256 _value) internal override notNull(_owner) {\n        uint256 rawBalance = super.balanceOf(_owner);\n        uint256 adjustedBalance = getAdjustedValue(_owner);\n        setBalance(_owner, adjustedBalance.add(_value));\n        checkMintOrBurn(_owner, rawBalance, adjustedBalance);\n    }\n\n    /// @notice subtract tokens `_value` tokens from `owner`\n    /// @param _owner The address of the account\n    /// @param _value The amount of tokens to be subtracted\n    /// @return _valueDeducted The value deducted\n    function subTokens(address _owner, uint256 _value) internal override notNull(_owner) returns (uint256 _valueDeducted ) {\n        uint256 rawBalance = super.balanceOf(_owner);\n        uint256 adjustedBalance = getAdjustedValue(_owner);\n        uint256 newBalance = adjustedBalance.sub(_value);\n        if (newBalance <= dustAmount) {\n            // dont leave balance below dust, empty account\n            _valueDeducted = _value.add(newBalance);\n            newBalance =  0;\n        } else {\n            _valueDeducted = _value;\n        }\n        setBalance(_owner, newBalance);\n        checkMintOrBurn(_owner, rawBalance, adjustedBalance);\n    }\n\n    /// @notice set balance of account `owner` to `_value`\n    /// @param _owner The address of the account\n    /// @param _value The new balance \n    function setBalance(address _owner, uint256 _value) internal override {\n        super.setBalance(_owner, _value);\n        // update `owner`s compoundLevel\n        if (_value == 0) {\n            // stall account release storage\n            delete compoundedInterestFactor[_owner];\n        } else {\n            // only update compoundedInterestFactor when value has changed \n            // important note: for InterestRateNone the compoundedInterestFactor is newer stored because the default value for getCompoundingLevel is SCALEFACTOR\n            uint256 currentLevel = getInterestRate().getCurrentCompoundingLevel();\n            if (currentLevel != getCompoundingLevel(_owner)) {\n                compoundedInterestFactor[_owner] = currentLevel;\n            }\n        }\n    }\n\n    /// @dev get address of active bond\n    function getInterestRate() internal view returns (InterestRateInterface) {\n        if ((block.timestamp <= announcedMaturityDate))\n            return currentTerms;\n        else\n            return announcedTerms;\n    }\n\n    /// @notice get adjusted balance of account `owner`\n    /// @param _owner The address of the account\n    function getAdjustedValue(address _owner) internal view returns (uint256) {\n        uint256 _rawBalance = super.balanceOf(_owner);\n        // if _rawBalance is 0 dont perform calculations\n        if (_rawBalance == 0)\n            return 0;\n        // important note: for empty/new account the getCompoundingLevel value is not meaningfull\n        uint256 startLevel = getCompoundingLevel(_owner);\n        uint256 currentLevel = getInterestRate().getCurrentCompoundingLevel();\n        return _rawBalance.mul(currentLevel).div(startLevel);\n    }\n\n    /// @notice get adjusted balance of account `owner` at data `date`\n    /// @param _owner The address of the account\n    /// @param _date The date of the balance NB: MUST be within valid current and announced Terms date range\n    function getAdjustedValueDate(address _owner,uint256 _date) public view returns (uint256) {\n        uint256 _rawBalance = super.balanceOf(_owner);\n        // if _rawBalance is 0 dont perform calculations\n        if (_rawBalance == 0)\n            return 0;\n        // important note: for empty/new account the getCompoundingLevel value is not meaningfull\n        uint256 startLevel = getCompoundingLevel(_owner);\n\n        InterestRateInterface dateTerms;\n        if (_date <= announcedMaturityDate)\n            dateTerms = currentTerms;\n        else\n            dateTerms = announcedTerms;\n\n        uint256 dateLevel = dateTerms.getCompoundingLevelDate(_date);\n        return _rawBalance.mul(dateLevel).div(startLevel);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    // EVENTS\n\n    event AnnounceRollover(string newName, address indexed newTerms, uint256 indexed newMaturityDate, uint256 indexed newTermEndDate);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}