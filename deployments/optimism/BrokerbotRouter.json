{
  "address": "0xfA0f2b98AeC990cd011Aa9071D86051491b1dFcD",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract BrokerbotRegistry",
          "name": "_registry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "Address_NotTransferNorContract",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Brokerbot_Deadline_Reached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Brokerbot_Not_Found",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "brokerbotRegistry",
      "outputs": [
        {
          "internalType": "contract BrokerbotRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "path",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountOutMinimum",
              "type": "uint256"
            }
          ],
          "internalType": "struct ISwapRouter.ExactInputParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "exactInput",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountOutMinimum",
              "type": "uint256"
            },
            {
              "internalType": "uint160",
              "name": "sqrtPriceLimitX96",
              "type": "uint160"
            }
          ],
          "internalType": "struct ISwapRouter.ExactInputSingleParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "exactInputSingle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "path",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountOut",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountInMaximum",
              "type": "uint256"
            }
          ],
          "internalType": "struct ISwapRouter.ExactOutputParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "exactOutput",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountOut",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountInMaximum",
              "type": "uint256"
            },
            {
              "internalType": "uint160",
              "name": "sqrtPriceLimitX96",
              "type": "uint160"
            }
          ],
          "internalType": "struct ISwapRouter.ExactOutputSingleParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "exactOutputSingle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "refundERC20",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "refundETH",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x9528462c34b5b2f46a6ce1d797210038bf0dcd0ff74d38ed0b963f1f5fbacb08",
  "receipt": {
    "to": null,
    "from": "0xCc59c42d05bd66fe22FBA27016f783af43f68fa7",
    "contractAddress": "0xfA0f2b98AeC990cd011Aa9071D86051491b1dFcD",
    "transactionIndex": 1,
    "gasUsed": "1500523",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa2a528cf0066d578c8daad162e9304942bbbf185c262b689aca7104d4bb45cfe",
    "transactionHash": "0x9528462c34b5b2f46a6ce1d797210038bf0dcd0ff74d38ed0b963f1f5fbacb08",
    "logs": [],
    "blockNumber": 114685656,
    "cumulativeGasUsed": "1547436",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2C9b9b9143A9Ef5051A299EF3CC8039b06927093"
  ],
  "numDeployments": 1,
  "solcInputHash": "9cfbcacdb8225a5ce2d06a060ad650b1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract BrokerbotRegistry\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Address_NotTransferNorContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Brokerbot_Deadline_Reached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Brokerbot_Not_Found\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"brokerbotRegistry\",\"outputs\":[{\"internalType\":\"contract BrokerbotRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapRouter.ExactInputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct ISwapRouter.ExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapRouter.ExactOutputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct ISwapRouter.ExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"refundERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"Bernhard Ruf, bernhard@aktionariat.com \",\"errors\":{\"Address_NotTransferNorContract(address)\":[{\"params\":{\"target\":\"Target address to call the function on.\"}}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC20 token failed.\"}]},\"kind\":\"dev\",\"methods\":{\"exactInput((bytes,address,uint256,uint256,uint256))\":{\"params\":{\"params\":\"The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata.\"},\"returns\":{\"amountOut\":\"The amount of the received token\"}},\"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\":{\"details\":\"Only use it for selling shares, else there will be no brokerbot found. Output can't be ETH you have to swap WETH to ETH on your integration.\",\"params\":{\"params\":\"The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata.\"},\"returns\":{\"amountOut\":\"The amountOut actually received.\"}},\"exactOutput((bytes,address,uint256,uint256,uint256))\":{\"details\":\"If ETH is sent this function will try to swap ETH for share tokens directly and will ignore the path.\",\"params\":{\"params\":\"Params struct for swap. See @ISwapRouter for struct definition.\"},\"returns\":{\"amountIn\":\"The amountIn actually spent.\"}},\"exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\":{\"details\":\"not usable to sell shares for excact output, as shares is not divisible (decimals is 0).Single swap with ETH works, but base currency address has to be provided as tokenIn.\",\"params\":{\"params\":\"Params struct for swap. See @ISwapRouter for struct definition.\"}},\"refundETH()\":{\"details\":\"Remember to call this function if you make a swap with ETH.\"}},\"title\":\"Brokerbot Swap Router\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"exactInput((bytes,address,uint256,uint256,uint256))\":{\"notice\":\"Sell `amountIn` of share tokens for as much as possible of another along the specified path.\"},\"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\":{\"notice\":\"Sell `amountIn` of share tokens for base currency.\"},\"exactOutput((bytes,address,uint256,uint256,uint256))\":{\"notice\":\"Buy share tokens with any erc20 by given a uniswap routing path\"},\"exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\":{\"notice\":\"Buy share tokens with base currency.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/brokerbot/BrokerbotRouter.sol\":\"BrokerbotRouter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0xf2b6c9adb3552254df1445b73563cf014434ff5e78663e9b961b6c059506ceb5\",\"license\":\"MIT\"},\"src/ERC20/IERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\",\"keccak256\":\"0x2224189bcdeb28cbadfdb8d126c278df60ec39875c7929e7ffa9e2055cded960\",\"license\":\"MIT\"},\"src/ERC20/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n\\t//////////////////////////////////////////////////////////////*/\\n    /// Block timestamp must to be before deadline.\\n    /// @param deadline The deadline of the permit.\\n    /// @param blockTimestamp The timestamp of the execution block.\\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\\n    /// Recovered address must be owner and not zero address.\\n    /// @param signerAddress The recovered signer address.\\n    error Permit_InvalidSigner(address signerAddress);\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\",\"keccak256\":\"0x9c6c4c49deffc8176f13b34150dd580526b45dd85ce1b71fe2ed340ff0489ebd\",\"license\":\"MIT\"},\"src/ERC20/IERC677.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\\ninterface IERC677 {\\n   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool success);\\n}\",\"keccak256\":\"0x012eadc7dce021eb13f1cb6f8e323c476ff0b26a3c163450db5d02d72093a545\",\"license\":\"MIT\"},\"src/ERC20/IERC677Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\\ninterface IERC677Receiver {\\n\\n    error IERC677_OnTokenTransferFailed();\\n    \\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\\n\\n}\",\"keccak256\":\"0xcca2937791e78a77e83f586e21a84fcc46fa910062f929145bf4159ef3f9d73c\",\"license\":\"MIT\"},\"src/brokerbot/Brokerbot.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* Proprietary License\\n*\\n* This code cannot be used without an explicit permission from the copyright holder.\\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\\n*\\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com), All rights reserved.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\nimport \\\"../ERC20/IERC677Receiver.sol\\\";\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract Brokerbot is IBrokerbot, Ownable {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address public override paymenthub;\\n\\n    IERC20 public override immutable base;  // ERC-20 currency\\n    IERC20Permit public override immutable token; // ERC-20 share token\\n\\n    uint256 private price; // current offer price in base currency, without drift\\n    uint256 public increment; // increment step the price in/decreases when buying/selling\\n\\n    uint256 public driftStart;\\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\\n    int256 public driftIncrement;\\n\\n    // Note that these settings might be hard-coded in various places, so better not change these values.\\n    uint8 private constant BUYING_ENABLED = 0x1;\\n    uint8 private constant SELLING_ENABLED = 0x2;\\n    // note that in the UI, we call the setting \\\"convert ether\\\", which is the opposite\\n    uint8 private constant KEEP_ETHER = 0x4;\\n\\n    // Version history\\n    // Version 2: added ability to process bank orders even if buying disabled\\n    // Version 3: added various events, removed license fee\\n    // Version 4: made version field public so it is actually usable\\n    // Version 5: added target address for withdrawEther\\n    // Version 6: added costs field to notifyTrade\\n    // Version 7: added withdraw eth event\\n    // Version 8: use SafeERC20\\n    uint8 public constant VERSION = 0x8;\\n\\n    // more bits to be used by payment hub\\n    uint256 public override settings = BUYING_ENABLED | SELLING_ENABLED;\\n\\n    event Trade(IERC20Permit indexed token, address who, bytes ref, int amount, IERC20 base, uint totPrice, uint fee, uint newprice);\\n    event PaymentHubUpdate(address indexed paymentHub);\\n    event PriceSet(uint256 price, uint256 increment);\\n    event DriftSet(uint256 timeToDrift, int256 driftIncrement);\\n    event SettingsChange(uint256 setting);\\n    // ETH in/out events\\n    event Received(address indexed from, uint amountETH, uint amountBase);\\n    event Withdrawn(address indexed target, uint amountETH);\\n    \\n    constructor(\\n        IERC20Permit _token,\\n        uint256 _price,\\n        uint256 _increment,\\n        IERC20 _base,\\n        address _owner,\\n        address _paymentHub\\n    )\\n        Ownable(_owner)\\n    {\\n        base = _base;\\n        token = _token;\\n        price = _price;\\n        increment = _increment;\\n        paymenthub = _paymentHub;\\n        // Should we disabled recoverability in the recovery hub here?\\n        // No, if someone attacks us, we can always trigger a transfer and recover the tokens as well as the collateral.\\n    }\\n\\n    function setPrice(uint256 _price, uint256 _increment) external onlyOwner {\\n        anchorPrice(_price);\\n        increment = _increment;\\n        emit PriceSet(_price, _increment);\\n    }\\n\\n    function hasDrift() public view returns (bool) {\\n        return timeToDrift != 0;\\n    }\\n\\n    // secondsPerStep should be negative for downwards drift\\n    function setDrift(uint256 secondsPerStep, int256 _driftIncrement) external onlyOwner {\\n        anchorPrice(getPrice());\\n        timeToDrift = secondsPerStep;\\n        driftIncrement = _driftIncrement;\\n        emit DriftSet(secondsPerStep, _driftIncrement);\\n    }\\n\\n    function anchorPrice(uint256 currentPrice) private {\\n        price = currentPrice;\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        driftStart = block.timestamp;\\n    }\\n\\n    function getPrice() public view returns (uint256) {\\n        // rely on time stamp is ok, no exact time stamp needed\\n        // solhint-disable-next-line not-rely-on-time\\n        return getPriceAtTime(block.timestamp);\\n    }\\n\\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\\n        if (hasDrift()){\\n            uint256 passed = timestamp - driftStart;\\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\\n            int256 driftedPrice = int256(price) + drifted;\\n            if (driftedPrice < 0){\\n                return 0;\\n            } else {\\n                return uint256(driftedPrice);\\n            }\\n        } else {\\n            return price;\\n        }\\n    }\\n\\n    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\\n        if (!hasSetting(BUYING_ENABLED)) {\\n            revert Brokerbot_BuyingDisabled();\\n        }\\n        uint shares = getShares(paid);\\n        uint costs = getBuyPrice(shares);\\n        notifyTraded(from, shares, costs, ref);\\n        if (costs < paid){\\n            base.safeTransfer(from, paid - costs);\\n        }\\n        IERC20(token).safeTransfer(from, shares);\\n        return shares;\\n    }\\n\\n    // Callers must verify that (hasSetting(BUYING_ENABLED) || msg.sender == owner) holds!\\n    function notifyTraded(address from, uint256 shares, uint256 costs, bytes calldata ref) internal returns (uint256) {\\n        // disabling the requirement below for efficiency as this always holds once we reach this point\\n        // require(hasSetting(BUYING_ENABLED) || msg.sender == owner, \\\"buying disabled\\\");\\n        price = price + (shares * increment);\\n        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\\n        return costs;\\n    }\\n\\n    function notifyTrade(address buyer, uint256 shares, uint256 costs, bytes calldata ref) external onlyOwner {\\n        notifyTraded(buyer, shares, costs, ref);\\n    }\\n\\n    function notifyTradeAndTransfer(address buyer, uint256 shares, uint256 costs, bytes calldata ref) public onlyOwner {\\n        notifyTraded(buyer, shares, costs, ref);\\n        IERC20(token).safeTransfer(buyer, shares);\\n    }\\n\\n    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, uint256[] calldata costs, bytes[] calldata ref) external onlyOwner {\\n        for (uint i = 0; i < buyers.length; i++) {\\n            notifyTraded(buyers[i], shares[i], costs[i], ref[i]);\\n        }\\n    }\\n\\n    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, uint256[] calldata costs, bytes[] calldata ref) external onlyOwner {\\n        for (uint i = 0; i < buyers.length; i++) {\\n            notifyTradeAndTransfer(buyers[i], shares[i], costs[i], ref[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Payment hub might actually have sent another accepted token, including Ether.\\n     * @dev Is either called from payment hub or from transferAndCall of the share token (via onTokenTransfer).\\n     * @param incomingAsset the erc20 address of either base currency or the share token.\\n     * @param from Who iniciated the sell/buy.\\n     * @param amount The amount of shares the are sold / The base amount paid to buy sharees.\\n     * @param ref Reference data blob.\\n     * @return The amount of shares bought / The amount received for selling the shares. \\n     */\\n    function processIncoming(IERC20 incomingAsset, address from, uint256 amount, bytes calldata ref) public override payable returns (uint256) {\\n        if (msg.sender != address(incomingAsset) && msg.sender != paymenthub) {\\n            revert Brokerbot_InvalidSender(msg.sender);\\n        }\\n        if(msg.value > 0) {\\n            emit Received(from, msg.value, amount);\\n        }\\n        if (incomingAsset == token){\\n            return sell(from, amount, ref);\\n        } else if (incomingAsset == base){\\n            return buy(from, amount, ref);\\n        } else {\\n            revert(\\\"invalid token\\\");\\n        }\\n    }\\n\\n    // ERC-677 recipient\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) external returns (bool) {\\n        processIncoming(IERC20(msg.sender), from, amount, ref);\\n        return true;\\n    }\\n\\n    function hasSetting(uint256 setting) private view returns (bool) {\\n        return settings & setting == setting;\\n    }\\n\\n    /**\\n     * ref 0x01 or old format sells shares for base currency.\\n     * ref 0x02 indicates a sell via bank transfer.\\n     */\\n    function isDirectSale(bytes calldata ref) internal pure returns (bool) {\\n        if (ref.length == 0 || ref.length == 20) {\\n            return true; // old format\\n        } else {\\n            if (ref[0] == bytes1(0x01)){\\n                return true;\\n            } else if (ref[0] == bytes1(0x02)) {\\n                return false;\\n            } else {\\n                revert(\\\"unknown ref\\\");\\n            }\\n        }\\n    }\\n\\n\\n    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\\n        if (!hasSetting(SELLING_ENABLED)) {\\n            revert Brokerbot_SellingDisabled();\\n        }\\n        uint256 totPrice = getSellPrice(amount);\\n        price -= amount * increment;\\n        if (isDirectSale(ref)){\\n            base.safeTransfer(recipient, totPrice);\\n        }\\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, 0, getPrice());\\n        return totPrice;\\n    }\\n\\n    function getSellPrice(uint256 shares) public view override returns (uint256) {\\n        return getPrice(getPrice() - (shares * increment), shares);\\n    }\\n\\n    function getBuyPrice(uint256 shares) public view override returns (uint256) {\\n        return getPrice(getPrice(), shares);\\n    }\\n\\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\\n        if (shares == 0) {\\n            return 0;\\n        } else {\\n            uint256 highest = lowest + (shares - 1) * increment;\\n            return ((lowest + highest) / 2) * shares;\\n        }\\n    }\\n\\n    function getShares(uint256 money) public view returns (uint256) {\\n        uint256 currentPrice = getPrice();\\n        uint256 min = 0;\\n        uint256 max = money / currentPrice;\\n        while (min < max){\\n            uint256 middle = (min + max)/2;\\n            uint256 totalPrice = getPrice(currentPrice, middle);\\n            if (money > totalPrice){\\n                min = middle + 1;\\n            } else {\\n                max = middle;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    function withdrawEther(address target, uint256 amount) public ownerOrHub() {\\n        (bool success, ) = payable(target).call{value:amount}(\\\"\\\");\\n        if (!success) {\\n            revert Brokerbot_WithdrawFailed(target, amount);\\n        }\\n        emit Withdrawn(target, amount);\\n    }\\n\\n    function withdrawEther(uint256 amount) external ownerOrHub() {\\n        withdrawEther(msg.sender, amount);\\n    }\\n\\n    function approve(address erc20, address who, uint256 amount) external onlyOwner() {\\n        IERC20(erc20).approve(who, amount);\\n    }\\n\\n    function withdraw(IERC20 ercAddress, address to, uint256 amount) external ownerOrHub() {\\n        ercAddress.safeTransfer(to, amount);\\n    }\\n\\n    function setPaymentHub(address hub) external onlyOwner() {\\n        paymenthub = hub;\\n        emit PaymentHubUpdate(paymenthub);\\n    }\\n\\n    function setSettings(uint256 _settings) public onlyOwner() {\\n        settings = _settings;\\n        emit SettingsChange(_settings);\\n    }\\n\\n    function setEnabled(bool _buyingEnabled, bool _sellingEnabled) external onlyOwner() {\\n        uint256 _settings = settings;\\n        if (_buyingEnabled != hasSetting(BUYING_ENABLED)){\\n            _settings ^= BUYING_ENABLED;\\n        }\\n        if (_sellingEnabled != hasSetting(SELLING_ENABLED)){\\n            _settings ^= SELLING_ENABLED;\\n        }\\n        setSettings(_settings);\\n    }\\n    \\n    modifier ownerOrHub() {\\n        if (owner != msg.sender && paymenthub != msg.sender) {\\n            revert Brokerbot_NotAuthorized(msg.sender);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x5f6a6a07bb27a3c717573ac96da4cdb1b0b95a0c7f62f1659d88fd47f9f29710\",\"license\":\"LicenseRef-Aktionariat\"},\"src/brokerbot/BrokerbotRegistry.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* Proprietary License\\n*\\n* This code cannot be used without an explicit permission from the copyright holder.\\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com), All rights reserved.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/// @title Brokerbot Registry\\n/// @notice Holds a registry from all deployed active brokerbots\\ncontract BrokerbotRegistry is Ownable {\\n  /// @notice Returns the brokerbot address for a given pair base and share token, or address 0 if it does not exist\\n  /// @dev mapping is [base][token] = brokerbotAddress\\n  /// @return brokerbot The brokerbot address\\n  mapping(IERC20 => mapping(IERC20 => IBrokerbot)) public getBrokerbot;\\n\\n  /// @notice Emitted when brokerbot is registered.\\n  /// @param brokerbot The address of the brokerbot\\n  /// @param base The address of the base currency\\n  /// @param token The address of the share token\\n  event RegisterBrokerbot(IBrokerbot brokerbot, IERC20 indexed base, IERC20 indexed token);\\n\\n  /// @notice Emmitted when calling syncBrokerbot function\\n  /// @param brokerbot The brokerbot address that is synced\\n  event SyncBrokerbot(IBrokerbot indexed brokerbot);\\n\\n  constructor(address _owner) Ownable(_owner) {}\\n\\n  /// @notice Per network only one active brokerbot should exist per base/share pair\\n  /// @param _brokerbot The brokerbot contract that should be registered.\\n  /// @param _base The contract of the base currency of the brokerbot.\\n  /// @param _token The contract of the share token of the brokerbot.\\n  function registerBrokerbot(IBrokerbot _brokerbot, IERC20 _base, IERC20 _token ) external onlyOwner() {\\n    getBrokerbot[_base][_token] = _brokerbot;\\n    emit RegisterBrokerbot(_brokerbot, _base, _token);\\n  }\\n\\n  /// @notice This event is usful for indexers/subgraphs to update token balances which are not tracked with other events\\n  /// @param _brokerbot The brokerbot that should be synced\\n  function syncBrokerbot(IBrokerbot _brokerbot) external {\\n    emit SyncBrokerbot(_brokerbot);\\n  }\\n\\n}\",\"keccak256\":\"0xd58d816746540b20822823f97e360df6b1204ce7395556338757eb2e6e965553\",\"license\":\"LicenseRef-Aktionariat\"},\"src/brokerbot/BrokerbotRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IUniswapV3.sol\\\";\\nimport \\\"./Brokerbot.sol\\\";\\nimport \\\"./PaymentHub.sol\\\";\\nimport \\\"./BrokerbotRegistry.sol\\\";\\nimport \\\"../ERC20/IERC677.sol\\\";\\nimport \\\"../utils/Path.sol\\\";\\nimport \\\"../utils/BrokerbotLib.sol\\\";\\n\\n/**\\n * @title Brokerbot Swap Router\\n * @author Bernhard Ruf, bernhard@aktionariat.com \\n */ \\ncontract BrokerbotRouter is ISwapRouter {\\n\\tusing Path for bytes;\\n\\tusing SafeERC20 for IERC20;\\n\\n\\tBrokerbotRegistry public immutable brokerbotRegistry;\\n\\n\\terror Brokerbot_Deadline_Reached();\\n\\n\\tconstructor(BrokerbotRegistry _registry) {\\n\\t\\tbrokerbotRegistry = _registry;\\n\\t}\\n\\n\\tmodifier checkDeadline(uint256 deadline) {\\n\\t\\tif (deadline < block.timestamp) revert Brokerbot_Deadline_Reached();\\n\\t\\t_;\\n\\t}\\n\\n\\t// solhint-disable-next-line no-empty-blocks\\n\\treceive() external payable {\\n\\t\\t// Important to receive ETH refund from PaymentHub\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buy share tokens with base currency.\\n\\t * @dev not usable to sell shares for excact output, as shares is not divisible (decimals is 0).\\n\\t * @dev Single swap with ETH works, but base currency address has to be provided as tokenIn.\\n\\t * @param params Params struct for swap. See @ISwapRouter for struct definition.\\n\\t */\\n\\tfunction exactOutputSingle(\\n\\t\\tExactOutputSingleParams calldata params\\n\\t) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\\n\\t\\t(IBrokerbot brokerbot, PaymentHub paymentHub) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(params.tokenIn), IERC20(params.tokenOut));\\n\\t\\tif (msg.value > 0) {\\n\\t\\t\\tamountIn = _buyWithEther(brokerbot, paymentHub, params.amountOut, msg.value);\\n\\t\\t\\trefundETH();\\n\\t\\t} else {\\n\\t\\t\\tamountIn = _exactOutputInternalPrepare(brokerbot, paymentHub, params.amountOut, params.amountInMaximum, IERC20(params.tokenIn));\\n\\t\\t\\t// call paymenthub to buy shares with base currency\\n\\t\\t\\tpaymentHub.payAndNotify(brokerbot, amountIn,  bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\trefundERC20(IERC20(params.tokenIn));\\n\\t\\t}\\n\\t\\tIERC20(params.tokenOut).safeTransfer(params.recipient, params.amountOut);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Buy share tokens with any erc20 by given a uniswap routing path\\n\\t * @dev If ETH is sent this function will try to swap ETH for share tokens directly and will ignore the path.\\n\\t * @param params Params struct for swap. See @ISwapRouter for struct definition.\\n\\t * @return amountIn The amountIn actually spent.\\n\\t */\\n\\tfunction exactOutput(ExactOutputParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\\n\\t\\tbytes memory modifiedPath = params.path;\\n\\t\\t(address shareToken, address baseToken, ) = params.path.decodeFirstPool();\\n\\t\\t(, address firstTokenIn, ) = params.path.getLastPool().decodeFirstPool();\\n\\t\\t(IBrokerbot brokerbot, PaymentHub paymentHub) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(baseToken), IERC20(shareToken));\\n\\t\\tif (msg.value > 0) {\\n\\t\\t\\tamountIn = _buyWithEther(brokerbot, paymentHub, params.amountOut, msg.value);\\n\\t\\t\\trefundETH();\\n\\t\\t} else {\\n\\t\\t\\tamountIn = _exactOutputInternalPrepare(brokerbot, paymentHub, params.amountOut, params.amountInMaximum, IERC20(firstTokenIn));\\n\\t\\t\\tif (params.path.hasMultiplePools()) {\\n\\t\\t\\t\\tmodifiedPath = params.path.skipToken();\\n\\t\\t\\t\\t(amountIn, ) = paymentHub.payFromERC20AndNotify(brokerbot, amountIn, firstTokenIn, params.amountInMaximum, modifiedPath, bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpaymentHub.payAndNotify(brokerbot, amountIn,  bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\t}\\n\\t\\t\\trefundERC20(IERC20(firstTokenIn));\\n\\t\\t}\\n\\t\\tIERC20(shareToken).safeTransfer(params.recipient, params.amountOut);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sell `amountIn` of share tokens for base currency.\\n\\t * @dev Only use it for selling shares, else there will be no brokerbot found. Output can't be ETH you have to swap WETH to ETH on your integration.\\n\\t * @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata.\\n\\t * @return amountOut The amountOut actually received.\\n\\t */\\n\\tfunction exactInputSingle(\\n\\t\\tExactInputSingleParams calldata params\\n\\t) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\\n\\t\\t(IBrokerbot brokerbot,) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(params.tokenOut), IERC20(params.tokenIn));\\n\\t\\tIERC20(params.tokenIn).safeTransferFrom(msg.sender, address(this), params.amountIn); // transfer shares into this contract\\n\\t\\t// send shares to brokerbot to sell them against base currency\\n\\t\\tIERC677(params.tokenIn).transferAndCall(address(brokerbot), params.amountIn, bytes(\\\"\\\\x01\\\"));\\n\\t\\t// transfer base currency to recipient\\n\\t\\tamountOut = IERC20(params.tokenOut).balanceOf(address(this));\\n\\t\\tIERC20(params.tokenOut).safeTransfer(params.recipient, amountOut);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sell `amountIn` of share tokens for as much as possible of another along the specified path.\\n\\t * @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata.\\n\\t * @return amountOut The amount of the received token\\n\\t */ \\n\\tfunction exactInput(ExactInputParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\\n\\t\\t(address shareToken, address baseToken,) = params.path.decodeFirstPool();\\n\\t\\t(IBrokerbot brokerbot, PaymentHub paymentHub) = BrokerbotLib.getBrokerbotAndPaymentHub(brokerbotRegistry, IERC20(baseToken), IERC20(shareToken));\\n\\n\\t\\tIERC20(shareToken).safeTransferFrom(msg.sender, address(this), params.amountIn); // transfer shares into this contract\\n\\t\\tif (IERC20(shareToken).allowance(address(this), address(paymentHub)) == 0){\\n\\t\\t\\t// max is fine as the router shouldn't hold any funds, so this should be ever only needed to be set once per token/paymenthub\\n\\t\\t\\tIERC20(shareToken).approve(address(paymentHub), type(uint256).max); \\n\\t\\t}\\n\\t\\tif (params.path.hasMultiplePools()) {\\n\\t\\t\\tExactInputParams memory modifiedParams = params;\\n\\t\\t\\tmodifiedParams.path = params.path.skipToken();\\n\\t\\t\\tamountOut = paymentHub.sellSharesAndSwap(brokerbot, IERC20(shareToken), params.amountIn, bytes(\\\"\\\\x01\\\"), modifiedParams, false);\\n\\t\\t} else {\\n\\t\\t\\tIERC677(shareToken).transferAndCall(address(brokerbot), params.amountIn, bytes(\\\"\\\\x01\\\"));\\n\\t\\t\\t// transfer base currency to recipient\\n\\t\\t\\tamountOut = IERC20(baseToken).balanceOf(address(this));\\n\\t\\t\\tIERC20(baseToken).safeTransfer(params.recipient, amountOut);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Remember to call this function if you make a swap with ETH.\\n\\t */\\n\\tfunction refundETH() public payable override {\\n\\t\\tif(address(this).balance > 0) {\\n\\t\\t\\t(bool success, ) = msg.sender.call{value: address(this).balance}(new bytes(0));\\n\\t\\t\\trequire(success, 'STF');\\n\\t\\t}\\n\\t}\\n\\n\\tfunction refundERC20(IERC20 token) public {\\n\\t\\tuint256 erc20Balance = token.balanceOf(address(this));\\n\\t\\tif(erc20Balance > 0) {\\n\\t\\t\\ttoken.safeTransfer(msg.sender, erc20Balance);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _buyWithEther(IBrokerbot brokerbot, PaymentHub paymentHub, uint256 shareAmount, uint256 ethAmount) internal returns (uint256 amountIn) {\\n\\t\\tuint256 baseAmount = brokerbot.getBuyPrice(shareAmount);\\n\\t\\t(amountIn,) = paymentHub.payFromEtherAndNotify{value: ethAmount}(brokerbot, baseAmount, bytes(\\\"\\\\x01\\\"));\\n\\t}\\n\\n\\tfunction _exactOutputInternalPrepare(IBrokerbot brokerbot, PaymentHub paymentHub, uint256 amountShares, uint256 amountInMaximum, IERC20 tokenIn) internal  returns (uint256 amountIn) {\\n\\t\\tamountIn = brokerbot.getBuyPrice(amountShares); // get current price, so nothing needs to be refunded\\n\\t\\ttokenIn.safeTransferFrom(msg.sender, address(this), amountInMaximum); // transfer base currency into this contract\\n\\t\\tif (tokenIn.allowance(address(this), address(paymentHub)) == 0){\\n\\t\\t\\t// max is fine as the router shouldn't hold any funds, so this should be ever only needed to be set once per token/paymenthub\\n\\t\\t\\ttokenIn.approve(address(paymentHub), type(uint256).max); \\n\\t\\t}\\n\\t}\\n}\",\"keccak256\":\"0x1cc7c4ed10c5929fa9dea45ae687ee2cde2dee7acf8842b950fc2ebde7d8003d\",\"license\":\"GPL-2.0-or-later\"},\"src/brokerbot/IBrokerbot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\n\\ninterface IBrokerbot {\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n  //////////////////////////////////////////////////////////////*/\\n  error Brokerbot_BuyingDisabled();\\n  error Brokerbot_SellingDisabled();\\n  /// Sender(msg.sender) has to be incoming token or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_InvalidSender(address sender);\\n  /// target.call() wasn't successful.\\n  /// @param target The receiver of the Eth.\\n  /// @param amount The withdraw amount.\\n  error Brokerbot_WithdrawFailed(address target, uint256 amount);\\n  /// Sender(msg.sender) needs to be owner or paymenthub.\\n  /// @param sender The msg.sender.\\n  error Brokerbot_NotAuthorized(address sender);\\n\\n  function paymenthub() external view returns (address);\\n\\n  function base() external view returns (IERC20);\\n\\n  function token() external view returns (IERC20Permit);\\n  \\n  function settings() external view returns (uint256);\\n\\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\\n\\n  function getBuyPrice(uint256 shares) external view returns (uint256);\\n\\n  function getSellPrice(uint256 shares) external view returns (uint256);\\n\\n}\",\"keccak256\":\"0xb41ad02c5b587309ecd6c84d4677d457e4cdb9f993447e97a605b10ec24de7b5\",\"license\":\"MIT\"},\"src/brokerbot/IUniswapV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied from \\n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\\n// https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IQuoter {\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n    \\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH9() external view returns (address);\\n}\\n\\ninterface ISwapRouter {\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n    \\n    function refundETH() external payable;\\n}\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\",\"keccak256\":\"0xd1fe06efa70710c24624abbfe0ed5ab69a47e9d3ec70734ea6e813711ff69784\",\"license\":\"MIT\"},\"src/brokerbot/PaymentHub.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/IERC20Permit.sol\\\";\\nimport \\\"./IUniswapV3.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"./IBrokerbot.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\n/**\\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\\n * Instead, an allowance needs to be set only once, namely for this contract.\\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap or the reception of Ether\\n * using the current exchange rate as found in the chainlink oracle.\\n */\\ncontract PaymentHub {\\n\\n    using SafeERC20 for IERC20;\\n\\n    // Version history\\n    // Version 4: added path to pay with any ecr20 via uniswap\\n    // Version 5: added sell via permit\\n    // Version 6: added transferEther function\\n    // Version 7: added sell against eth and erc20, version, add permitinfo/swapinfo struct\\n    // Version 8: use SafeERC20 for transfers\\n    uint8 public constant VERSION = 0x8;\\n\\n    address public trustedForwarder;\\n\\n    uint24 private constant DEFAULT_FEE = 3000;\\n    uint24 private constant LOW_FEE = 500;\\n    address private constant XCHF = 0xE4F27b04cC7729901876B44f4EAA5102EC150265;\\n    address private constant DAI = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\\n    \\n    IQuoter private immutable uniswapQuoter;\\n    ISwapRouter private immutable uniswapRouter;\\n\\n    struct PermitInfo {\\n        uint256 exFee;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    // event to when new forwarder is set\\n    event ForwarderChanged(address indexed _oldForwarder, address indexed _newForwarder);\\n\\n\\t/*//////////////////////////////////////////////////////////////\\n                            Custom errors\\n    //////////////////////////////////////////////////////////////*/\\n    /// Failguard when an erc20 transfer returns false.\\n    error PaymentHub_TransferFailed();\\n    /// Sender not trusted.\\n    /// @param sender The msg.sender of this transaction.\\n    error PaymentHub_InvalidSender(address sender);\\n    /// swap with less base token as required.\\n    /// @param amountBase Required amount.\\n    /// @param swappedAmount Swapped amount.\\n    error PaymentHub_SwapError(uint256 amountBase, uint256 swappedAmount);\\n\\n    constructor(address _trustedForwarder, IQuoter _quoter, ISwapRouter swapRouter) {\\n        trustedForwarder = _trustedForwarder;\\n        uniswapQuoter = _quoter;\\n        uniswapRouter = swapRouter;\\n    }\\n\\n    modifier onlySellerAndForwarder(address seller) {\\n        if (msg.sender != trustedForwarder && msg.sender != seller) {\\n            revert PaymentHub_InvalidSender(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyForwarder() {\\n        if (msg.sender != trustedForwarder) {\\n            revert PaymentHub_InvalidSender(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Change the trusted forwarder.\\n     * @param newForwarder The new trusted forwarder.\\n     */\\n     function changeForwarder(address newForwarder) external onlyForwarder {\\n        trustedForwarder = newForwarder;\\n        emit ForwarderChanged(msg.sender, newForwarder);\\n    }\\n\\n    /**\\n     * Get price in ERC20\\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\\n     * @param amountInBase The amount of the base currency for the exact output.\\n     * @param path The encoded path of the swap from erc20 to base.\\n     * @return amount quoted to pay\\n     */\\n    function getPriceInERC20(uint256 amountInBase, bytes memory path) public returns (uint256) {\\n        return getPriceERC20(amountInBase, path, true);\\n    }\\n\\n    /**\\n     * @notice Get price for given amount and path swapped via uniswap.\\n     * @param amount The exact amount which you want get out (exactOutput) or you put in (exactInput).\\n     * @param path The path of the swap (inreverse order for exactOutput).\\n     * @param exactOutput True if exactOutput should be used or false if exactInput should be used.\\n     */\\n    function getPriceERC20(uint256 amount, bytes memory path, bool exactOutput) public returns (uint256) {\\n        if (exactOutput) {\\n            return uniswapQuoter.quoteExactOutput(\\n                path,\\n                amount\\n            );\\n        } else {\\n            return uniswapQuoter.quoteExactInput(\\n                path,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\\n     * @return The price in wei.\\n     */\\n    function getPriceInEther(uint256 amountInBase, IBrokerbot brokerBot) public returns (uint256) {\\n        address base = address(brokerBot.base());\\n        if (base == XCHF) {\\n            return uniswapQuoter.quoteExactOutput(\\n                abi.encodePacked(base, LOW_FEE, DAI, DEFAULT_FEE, uniswapQuoter.WETH9()),\\n                amountInBase);\\n        } else {\\n            return uniswapQuoter.quoteExactOutputSingle(uniswapQuoter.WETH9(), base, DEFAULT_FEE, amountInBase, 0);\\n        }\\n    }\\n\\n    /**\\n     * Convenience method to swap ether into base and pay a target address\\n     */\\n    function payFromEther(address recipient, uint256 amountInBase, IERC20 base) public payable returns (uint256 amountIn) {\\n        ISwapRouter swapRouter = uniswapRouter;\\n        if (address(base) == XCHF) {\\n            ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams(\\n                abi.encodePacked(base, LOW_FEE, DAI, DEFAULT_FEE, uniswapQuoter.WETH9()),\\n                recipient,\\n                block.timestamp,\\n                amountInBase,\\n                msg.value\\n            );\\n            amountIn = swapRouter.exactOutput{value: msg.value}(params);\\n        } else {\\n            ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\\n                // rely on time stamp is ok, no exact time stamp needed\\n                // solhint-disable-next-line not-rely-on-time\\n                uniswapQuoter.WETH9(), address(base), DEFAULT_FEE, recipient, block.timestamp, amountInBase, msg.value, 0);\\n\\n            // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.\\n            amountIn = swapRouter.exactOutputSingle{value: msg.value}(params);\\n        }\\n\\n        // For exact output swaps, the amountInMaximum may not have all been spent.\\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\\n        if (amountIn < msg.value) {\\n            swapRouter.refundETH();\\n            (bool success, ) = msg.sender.call{value:msg.value - amountIn}(\\\"\\\"); // return change\\n            if (!success) {\\n                revert PaymentHub_TransferFailed();\\n            }\\n        }\\n    }\\n\\n    /// @dev The calling address must approve this contract to spend its ERC20 for this function to succeed. As the amount of input ERC20 is variable,\\n    /// the calling address will need to approve for a slightly higher or infinit amount, anticipating some variance.\\n    /// @param amountOut The desired amount of baseCurrency.\\n    /// @param amountInMaximum The maximum amount of ERC20 willing to be swapped for the specified amountOut of baseCurrency.\\n    /// @param erc20In The address of the erc20 token to pay with.\\n    /// @param path The encoded path of the swap from erc20 to base.\\n    /// @param recipient The reciving address - brokerbot.\\n    /// @return amountIn The amountIn of ERC20 actually spent to receive the desired amountOut.\\n    function payFromERC20(uint256 amountOut, uint256 amountInMaximum, address erc20In, bytes memory path, address recipient) public returns (uint256 amountIn) {\\n        ISwapRouter swapRouter = uniswapRouter;\\n        // Transfer the specified `amountInMaximum` to this contract.\\n        IERC20(erc20In).safeTransferFrom(msg.sender, address(this), amountInMaximum);\\n\\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\\n        ISwapRouter.ExactOutputParams memory params =\\n            ISwapRouter.ExactOutputParams({\\n                path: path,\\n                recipient: recipient,\\n                // solhint-disable-next-line not-rely-on-time\\n                deadline: block.timestamp,\\n                amountOut: amountOut,\\n                amountInMaximum: amountInMaximum\\n            });\\n\\n        // Executes the swap, returning the amountIn actually spent.\\n        amountIn = swapRouter.exactOutput(params);\\n\\n        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.\\n        if (amountIn < amountInMaximum) {\\n            IERC20(erc20In).safeTransfer(msg.sender, amountInMaximum - amountIn);\\n        }\\n    }\\n\\n    ///This function appoves infinite allowance for Uniswap, this is safe as the paymenthub should never hold any token (see also recover() ).\\n    ///@dev This function needs to be called before using the PaymentHub the first time with a new ERC20 token.\\n    ///@param erc20In The erc20 addresse to approve.\\n    function approveERC20(address erc20In) external {\\n        IERC20(erc20In).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    function multiPay(IERC20 token, address[] calldata recipients, uint256[] calldata amounts) public {\\n        for (uint i=0; i<recipients.length; i++) {\\n            IERC20(token).safeTransferFrom(msg.sender, recipients[i], amounts[i]);\\n        }\\n    }\\n\\n    /**\\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\\n     */\\n    function multiPayAndNotify(IERC20 token, IBrokerbot[] calldata brokerbots, uint256[] calldata amounts, bytes calldata ref) external {\\n        for (uint i=0; i<brokerbots.length; i++) {\\n            payAndNotify(token, brokerbots[i], amounts[i], ref);\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows to make a base currency payment from the sender to the brokerbot, given an allowance to this contract.\\n     * @dev Equivalent to xchf.transferAndCall(brokerbot, amountInBase)\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountInBase The amount of base currency used to buy shares.\\n     * @param ref The reference data blob.\\n     * @return The amount of shares bought\\n     */\\n    function payAndNotify(IBrokerbot brokerbot, uint256 amountInBase, bytes calldata ref) external returns (uint256) {\\n        return payAndNotify(brokerbot.base(), brokerbot, amountInBase, ref);\\n    }\\n\\n    function payAndNotify(IERC20 token, IBrokerbot brokerbot, uint256 amount, bytes calldata ref) public returns (uint256) {\\n        token.safeTransferFrom(msg.sender, address(brokerbot), amount);\\n        return brokerbot.processIncoming(token, msg.sender, amount, ref);\\n    }\\n\\n    function payFromEtherAndNotify(IBrokerbot recipient, uint256 amountInBase, bytes calldata ref) external payable returns (uint256 priceInEther, uint256 sharesOut) {\\n        IERC20 base = recipient.base();\\n        priceInEther = payFromEther(address(recipient), amountInBase, base);\\n        sharesOut = recipient.processIncoming(base, msg.sender, amountInBase, ref);\\n    }\\n\\n    /***\\n     * @notice Pay from any ERC20 token (which has Uniswapv3 ERC20-ETH pool) and send swapped base currency to brokerbot.\\n     * @notice The needed amount needs to be approved at the ERC20 contract beforehand\\n     * @param brokerbot The brokerbot to pay and receive the shares from.\\n     * @param amountBase The amount of base currency used to buy shares.\\n     * @param erc20 The address of the ERC20 token to pay.\\n     * @param amountInMaximum The maximum amount of the ERC20 to pay (should include some slippage).\\n     * @param path The encoded path of the swap from erc20 to base currency.\\n     * @param ref Reference data blob.\\n     * @return amountIn The amount erc20 spent to buy shares.\\n     * @return amountOut The amount of shares received by the brokerbot.\\n     */\\n    function payFromERC20AndNotify(IBrokerbot brokerbot, uint256 amountBase, address erc20, uint256 amountInMaximum, bytes memory path, bytes calldata ref) external returns (uint256 amountIn, uint256 amountOut) {\\n        IERC20 base = brokerbot.base();\\n        uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\\n        amountIn = payFromERC20(amountBase, amountInMaximum, erc20, path, address(brokerbot));\\n        uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\\n        if (amountBase != (balanceAfter - balanceBefore)) {\\n            revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\\n        }\\n        amountOut = brokerbot.processIncoming(base, msg.sender, balanceAfter - balanceBefore, ref);\\n    }\\n\\n    /**\\n     * @notice Sell shares with permit\\n     * @param brokerbot The brokerbot to recive the shares.\\n     * @param seller The address of the seller.\\n     * @param recipient The address of the recipient of the sell preceeds.\\n     * @param amountToSell The amount the seller wants to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param permitInfo Information about the permit.\\n     * @return The base currency amount for the selling of the shares.\\n     */\\n    function sellSharesWithPermit(IBrokerbot brokerbot, IERC20Permit shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo) public onlySellerAndForwarder(seller) returns (uint256) {\\n        // Call permit to set allowance\\n        shares.permit(seller, address(this), amountToSell, permitInfo.deadline, permitInfo.v, permitInfo.r,permitInfo.s);\\n        // process sell\\n        if (permitInfo.exFee > 0){\\n            uint256 proceeds = _sellShares(brokerbot, shares, seller, address(this), amountToSell, ref);\\n            IERC20 currency = brokerbot.base();\\n            currency.safeTransfer(msg.sender, permitInfo.exFee);\\n            currency.safeTransfer(recipient, proceeds - permitInfo.exFee);\\n            return proceeds - permitInfo.exFee;\\n        } else {\\n            return _sellShares(brokerbot, shares, seller, recipient, amountToSell, ref);\\n        }\\n    }\\n\\n    /**\\n     * @notice With this function a user can sell shares with permit and swap them to a desired token.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param seller The seller address.\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param permitInfo Information about the permit.\\n     * @param params Information about the swap.\\n     * @return The output amount of the swap to the desired token.\\n     */\\n    function sellSharesWithPermitAndSwap(IBrokerbot brokerbot, IERC20Permit shares, address seller,  uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external onlySellerAndForwarder(seller) returns (uint256) {\\n        params.amountIn = sellSharesWithPermit(brokerbot, shares, seller, address(this), amountToSell, ref, permitInfo);\\n        return _swap(params, unwrapWeth);\\n    }\\n\\n    /**\\n     * @notice With this function a user can sell shares and swap them to a desired token. The user has to approve the paymenthub before on the shares contract.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @param params Information about the swap.\\n     * @return The output amount of the swap to the desired token.\\n     */\\n    function sellSharesAndSwap(IBrokerbot brokerbot, IERC20 shares, uint256 amountToSell,  bytes calldata ref, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external returns (uint256) {\\n        params.amountIn = _sellShares(brokerbot, shares, msg.sender, address(this), amountToSell, ref);\\n        return _swap(params, unwrapWeth);\\n    }\\n\\n    /**\\n     * @notice Transfers shares to brokerbot and executes the selling.\\n     * @param brokerbot The brokerbot of the shares to sell.\\n     * @param shares The (draggable)shares address.\\n     * @param seller The seller address.\\n     * @param recipient The recipient of the base currency tokens. (this can be a 3rd party to off-ramp or the paymenthub itself if a swap will be done direct after)\\n     * @param amountToSell The amount of shares to sell.\\n     * @param ref Reference e.g. insider declaration and the type of sell.\\n     * @return The base currency amount for the selling of the shares.\\n     */\\n    function _sellShares(IBrokerbot brokerbot, IERC20 shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref ) internal returns (uint256) {\\n        // send shares token to brokerbot\\n        shares.safeTransferFrom(seller, address(brokerbot), amountToSell);\\n        // process sell on brokerbot\\n        return brokerbot.processIncoming(shares, recipient, amountToSell, ref);\\n    }\\n\\n    /**\\n     * @notice Swap (base currency) token according to given path and unwrap weth if needed.\\n     * @param params Information about the swap (includes path).\\n     * @return amountOut The output amount of the swap to the desired token.\\n     */\\n    function _swap(ISwapRouter.ExactInputParams memory params, bool unwrapWeth) internal returns(uint256 amountOut) {\\n        // if weth should be unwrapped, swap recipient is this contract and eth is send to seller\\n        if (unwrapWeth){\\n            address seller = params.recipient;\\n            params.recipient = address(this);\\n            amountOut = _swapToERC20(params);\\n            IWETH9(uniswapQuoter.WETH9()).withdraw(amountOut);\\n            (bool success, ) = payable(seller).call{value:amountOut}(\\\"\\\");\\n            if (!success) revert PaymentHub_TransferFailed();\\n        } else {\\n            amountOut = _swapToERC20(params);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calls the Uniswap router to swap tokens according to given path.\\n     * @param params Information about the swap (includes path).\\n     * @return amountOut The output amount of the swap to the desired token.\\n     */\\n    function _swapToERC20(ISwapRouter.ExactInputParams memory params) internal returns(uint256 amountOut) {\\n        amountOut = uniswapRouter.exactInput(params);\\n        if (amountOut < params.amountOutMinimum){\\n            revert PaymentHub_SwapError(params.amountOutMinimum, amountOut);\\n        }\\n    }\\n\\n    /**\\n     * @notice In case tokens have been accidentally sent directly to this contract. Only Forwarder can withdraw, else a MEV bot will intercept it.\\n     * @param ercAddress The erc20 address.\\n     * @param to The address to transfer tokens to.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function recover(IERC20 ercAddress, address to, uint256 amount) external onlyForwarder {\\n        ercAddress.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer ether to a given address. Only Forwarder can withdraw, else a MEV bot will intercept it.\\n     * @param to The address to transfer ether to.\\n     */\\n    function withdrawEther(address to, uint256 amount) external onlyForwarder {\\n        (bool success, ) = payable(to).call{value:amount}(\\\"\\\");\\n        if (!success) {\\n            revert PaymentHub_TransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer ether to a given address.\\n     * @dev Used with the mutlisigwallet.\\n     * @param to The address to transfer ether to.\\n     */\\n    function transferEther(address to) external payable {\\n        (bool success, ) = payable(to).call{value:msg.value}(\\\"\\\");\\n        if (!success) {\\n            revert PaymentHub_TransferFailed();\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {\\n        // Important to receive ETH refund from Uniswap\\n    }\\n}\\n\",\"keccak256\":\"0x1fc5832edd436055ffe25b11859ae7e54357bb05f5426a38462bdd7ac5a7856f\",\"license\":\"LicenseRef-Aktionariat\"},\"src/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n// and modified it.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Address {\\n\\n    /// @param target Target address to call the function on.\\n    error Address_NotTransferNorContract(address target);\\n\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n        return account.code.length > 0;\\n    }\\n    \\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\\n        if (data.length != 0 && !isContract(target)) {\\n            revert Address_NotTransferNorContract(target);\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else if (returndata.length > 0) {\\n            assembly{\\n                revert (add (returndata, 0x20), mload (returndata))\\n            }\\n        } else {\\n           revert(\\\"failed\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0xb95d45875550203c1afb7dfc9c99ce62c77496c36e96f3adfaad2d42cb3380a2\",\"license\":\"MIT\"},\"src/utils/BrokerbotLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../brokerbot/IBrokerbot.sol\\\";\\nimport \\\"../brokerbot/PaymentHub.sol\\\";\\nimport \\\"../brokerbot/BrokerbotRegistry.sol\\\";\\n\\nlibrary BrokerbotLib {\\n\\n\\terror Brokerbot_Not_Found();  \\n\\tfunction getBrokerbotAndPaymentHub(BrokerbotRegistry brokerbotRegistry, IERC20 base, IERC20 token) internal view returns (IBrokerbot brokerbot, PaymentHub paymentHub) {\\n\\t\\tbrokerbot = brokerbotRegistry.getBrokerbot(base, token);\\n\\t\\tif (address(brokerbot) == address(0)) revert Brokerbot_Not_Found();\\n\\t\\tpaymentHub = PaymentHub(payable(brokerbot.paymenthub()));\\n\\t}\\n}\",\"keccak256\":\"0xde6568fe1305b43423fc7c408150a5e3503f475732a1b2b5bad5ad375af80d9c\",\"license\":\"MIT\"},\"src/utils/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n  function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, 'toUint24_overflow');\\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\",\"keccak256\":\"0x75f44eb099f9281deecd164e9a675f4d0f5278ce306ada92feaa50844d437a82\",\"license\":\"Unlicense\"},\"src/utils/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n//\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n//\\n// Modifications:\\n// - Replaced Context._msgSender() with msg.sender\\n// - Made leaner\\n// - Extracted interface\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    error Ownable_NotOwner(address sender);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor (address initialOwner) {\\n        owner = initialOwner;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function _checkOwner() internal view {\\n        if (msg.sender != owner) {\\n            revert Ownable_NotOwner(msg.sender);\\n        }\\n    }\\n}\",\"keccak256\":\"0x9057578671d192c7891a59854cf8bab2698450c5b271f21e0696036fb65cae3b\",\"license\":\"MIT\"},\"src/utils/Path.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// copied and modified from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/Path.sol\\npragma solidity >=0.6.0;\\n\\nimport './BytesLib.sol';\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary Path {\\n    using BytesLib for bytes;\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The length of the bytes encoded fee\\n    uint256 private constant FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address and pool fee\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n    /// @notice Returns true iff the path contains two or more pools\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more pools, otherwise false\\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n    }\\n\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return fee The fee level of the pool\\n    function decodeFirstPool(bytes memory path)\\n        internal\\n        pure\\n        returns (\\n            address tokenA,\\n            address tokenB,\\n            uint24 fee\\n        )\\n    {\\n        tokenA = path.toAddress(0);\\n        fee = path.toUint24(ADDR_SIZE);\\n        tokenB = path.toAddress(NEXT_OFFSET);\\n    }\\n\\n    /// @notice Gets the segment corresponding to the last pool in the path\\n    /// @param path The bytes encoded swap path\\n    /// @return The segment containing all data necessary to target the last pool in the path\\n    function getLastPool(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(path.length - POP_OFFSET, POP_OFFSET);\\n    }\\n\\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + fee elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\\n    }\\n}\",\"keccak256\":\"0xe79eae37bcbd069502062f85a74aee342295c2ea5f3f14af408a548cb11ede31\",\"license\":\"GPL-2.0-or-later\"},\"src/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../ERC20/IERC20Permit.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        if (nonceAfter != nonceBefore + 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\",\"keccak256\":\"0xa162e550fe203915126fddc231c55d28dd3f16d39be22dd48c5fc7f5ccd6fd93\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051611ad1380380611ad183398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b608051611a2b6100a66000396000818160c20152818161022d015281816104f5015281816108b70152610ae70152611a2b6000f3fe6080604052600436106100745760003560e01c80636e94a6291161004e5780636e94a629146100fc578063c04b8d591461011c578063db3e21981461012f578063f28c04981461014257600080fd5b806312210e8a14610080578063414bf3891461008a5780634b07dff0146100b057600080fd5b3661007b57005b600080fd5b610088610155565b005b61009d610098366004611587565b6101fe565b6040519081526020015b60405180910390f35b3480156100bc57600080fd5b506100e47f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100a7565b34801561010857600080fd5b506100886101173660046115b9565b6103eb565b61009d61012a3660046115e8565b610476565b61009d61013d366004611587565b610887565b61009d6101503660046115e8565b610a09565b47156101fc57604080516000808252602082019092523390479060405161017c919061165f565b60006040518083038185875af1925050503d80600081146101b9576040519150601f19603f3d011682016040523d82523d6000602084013e6101be565b606091505b50509050806101fa5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b60448201526064015b60405180910390fd5b505b565b600081608001354281101561022657604051639638793160e01b815260040160405180910390fd5b600061026e7f000000000000000000000000000000000000000000000000000000000000000061025c60408701602088016115b9565b61026960208801886115b9565b610cd3565b509050610299333060a087013561028860208901896115b9565b6001600160a01b0316929190610ddf565b6102a660208501856115b9565b60408051808201825260018152600160f81b60208201529051630200057560e51b81526001600160a01b039290921691634000aea0916102f091859160a08a0135916004016116b7565b6020604051808303816000875af115801561030f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033391906116de565b5061034460408501602086016115b9565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa15801561038a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ae9190611700565b92506103e46103c360808601606087016115b9565b846103d460408801602089016115b9565b6001600160a01b03169190610e4c565b5050919050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610432573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104569190611700565b90508015610472576104726001600160a01b0383163383610e4c565b5050565b600081604001354281101561049e57604051639638793160e01b815260040160405180910390fd5b6000806104e86104ae8680611719565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610e8292505050565b509150915060008061051b7f00000000000000000000000000000000000000000000000000000000000000008486610cd3565b90925090506105396001600160a01b038516333060608b0135610ddf565b604051636eb1769f60e11b81523060048201526001600160a01b03828116602483015285169063dd62ed3e90604401602060405180830381865afa158015610585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105a99190611700565b6000036106265760405163095ea7b360e01b81526001600160a01b038281166004830152600019602483015285169063095ea7b3906044016020604051808303816000875af1158015610600573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062491906116de565b505b61066d6106338880611719565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ebe92505050565b1561076257600061067d886117c1565b90506106c661068c8980611719565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ef892505050565b815260408051808201825260018152600160f81b60208201529051631a924e2960e31b81526001600160a01b0384169163d4927148916107179187918a9160608f013591889060009060040161188f565b6020604051808303816000875af1158015610736573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061075a9190611700565b96505061087d565b60408051808201825260018152600160f81b60208201529051630200057560e51b81526001600160a01b03861691634000aea0916107ab91869160608d013591906004016116b7565b6020604051808303816000875af11580156107ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107ee91906116de565b506040516370a0823160e01b81523060048201526001600160a01b038416906370a0823190602401602060405180830381865afa158015610833573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108579190611700565b955061087d61086c6040890160208a016115b9565b6001600160a01b0385169088610e4c565b5050505050919050565b60008160800135428110156108af57604051639638793160e01b815260040160405180910390fd5b6000806108f37f00000000000000000000000000000000000000000000000000000000000000006108e360208801886115b9565b6102696040890160208a016115b9565b9092509050341561091d5761090e82828760a0013534610f2f565b9350610918610155565b6109d9565b61093e828260a088013560c089013561093960208b018b6115b9565b611034565b60408051808201825260018152600160f81b60208201529051630bfab2e960e11b81529195506001600160a01b038316916317f565d29161098591869189916004016116b7565b6020604051808303816000875af11580156109a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c89190611700565b506109d961011760208701876115b9565b610a016109ec60808701606088016115b9565b60a08701356103d46040890160208a016115b9565b505050919050565b6000816040013542811015610a3157604051639638793160e01b815260040160405180910390fd5b6000610a3d8480611719565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939450839250610a8491506104ae90508780611719565b5090925090506000610adb610ad6610a9c8980611719565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506111ad92505050565b610e82565b50915050600080610b0d7f00000000000000000000000000000000000000000000000000000000000000008587610cd3565b90925090503415610b3757610b2882828b6060013534610f2f565b9750610b32610155565b610c9f565b610b4c82828b606001358c6080013587611034565b9750610b5b6106338a80611719565b15610c0c57610b6d61068c8a80611719565b9550806001600160a01b0316635daf206a838a868d608001358b604051806040016040528060018152602001600160f81b8152506040518763ffffffff1660e01b8152600401610bc29695949392919061191f565b60408051808303816000875af1158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190611978565b509750610c96565b60408051808201825260018152600160f81b60208201529051630bfab2e960e11b81526001600160a01b038316916317f565d291610c519186918d91906004016116b7565b6020604051808303816000875af1158015610c70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c949190611700565b505b610c9f836103eb565b610cc7610cb260408b0160208c016115b9565b6001600160a01b0387169060608c0135610e4c565b50505050505050919050565b604051633b55df8560e11b81526001600160a01b038381166004830152828116602483015260009182918616906376abbf0a90604401602060405180830381865afa158015610d26573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4a919061199c565b91506001600160a01b038216610d73576040516325ef27af60e01b815260040160405180910390fd5b816001600160a01b031663777adcf06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610db1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dd5919061199c565b9050935093915050565b6040516001600160a01b038481166024830152838116604483015260648201839052610e469186918216906323b872dd906084015b604051602081830303815290604052915060e01b6020820180516001600160e01b0383818316178352505050506111ec565b50505050565b6040516001600160a01b03838116602483015260448201839052610e7d91859182169063a9059cbb90606401610e14565b505050565b60008080610e90848261124f565b9250610e9d8460146112b4565b9050610eb5610eae600360146119cf565b859061124f565b91509193909250565b6000610ecc600360146119cf565b6014610ed96003826119cf565b610ee391906119cf565b610eed91906119cf565b825110159050919050565b6060610f29610f09600360146119cf565b610f15600360146119cf565b8451610f2191906119e2565b84919061135f565b92915050565b60405163023536c560e21b81526004810183905260009081906001600160a01b038716906308d4db1490602401602060405180830381865afa158015610f79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9d9190611700565b60408051808201825260018152600160f81b6020820152905163020601bd60e11b81529192506001600160a01b0387169163040c037a918691610fe7918b918791906004016116b7565b604080518083038185885af1158015611004573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906110299190611978565b509695505050505050565b60405163023536c560e21b8152600481018490526000906001600160a01b038716906308d4db1490602401602060405180830381865afa15801561107c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a09190611700565b90506110b76001600160a01b038316333086610ddf565b604051636eb1769f60e11b81523060048201526001600160a01b03868116602483015283169063dd62ed3e90604401602060405180830381865afa158015611103573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111279190611700565b6000036111a45760405163095ea7b360e01b81526001600160a01b038681166004830152600019602483015283169063095ea7b3906044016020604051808303816000875af115801561117e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a291906116de565b505b95945050505050565b6060610f2960146111bf6003826119cf565b6111c991906119cf565b83516111d591906119e2565b60146111e26003826119cf565b610f2191906119cf565b60006112016001600160a01b0384168361146e565b9050805160001415801561122657508080602001905181019061122491906116de565b155b15610e7d57604051635274afe760e01b81526001600160a01b03841660048201526024016101f1565b600061125c8260146119cf565b835110156112a45760405162461bcd60e51b8152602060048201526015602482015274746f416464726573735f6f75744f66426f756e647360581b60448201526064016101f1565b500160200151600160601b900490565b6000816112c28160036119cf565b10156113045760405162461bcd60e51b8152602060048201526011602482015270746f55696e7432345f6f766572666c6f7760781b60448201526064016101f1565b61130f8260036119cf565b835110156113565760405162461bcd60e51b8152602060048201526014602482015273746f55696e7432345f6f75744f66426f756e647360601b60448201526064016101f1565b50016003015190565b60608161136d81601f6119cf565b10156113ac5760405162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b60448201526064016101f1565b6113b682846119cf565b845110156113fa5760405162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b60448201526064016101f1565b6060821580156114195760405191506000825260208201604052611463565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561145257805183526020928301920161143a565b5050858452601f01601f1916604052505b5090505b9392505050565b6060611467838360006060825160001415801561149357506001600160a01b0384163b155b156114bc57604051639eb1341360e01b81526001600160a01b03851660048201526024016101f1565b600080856001600160a01b031684866040516114d8919061165f565b60006040518083038185875af1925050503d8060008114611515576040519150601f19603f3d011682016040523d82523d6000602084013e61151a565b606091505b5091509150811561152e5791506114679050565b80511561153d57805160208201fd5b60405162461bcd60e51b815260206004820152600660248201526519985a5b195960d21b60448201526064016101f1565b6000610100828403121561158157600080fd5b50919050565b6000610100828403121561159a57600080fd5b611467838361156e565b6001600160a01b03811681146101fa57600080fd5b6000602082840312156115cb57600080fd5b8135611467816115a4565b600060a0828403121561158157600080fd5b6000602082840312156115fa57600080fd5b813567ffffffffffffffff81111561161157600080fd5b61161d848285016115d6565b949350505050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561165657818101518382015260200161163e565b50506000910152565b6000825161167181846020870161163b565b9190910192915050565b8035611686816115a4565b919050565b600081518084526116a381602086016020860161163b565b601f01601f19169290920160200192915050565b60018060a01b03841681528260208201526060604082015260006111a4606083018461168b565b6000602082840312156116f057600080fd5b8151801515811461146757600080fd5b60006020828403121561171257600080fd5b5051919050565b6000808335601e1984360301811261173057600080fd5b83018035915067ffffffffffffffff82111561174b57600080fd5b60200191503681900382131561176057600080fd5b9250929050565b60405160a0810167ffffffffffffffff8111828210171561178a5761178a611625565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156117b9576117b9611625565b604052919050565b600060a082360312156117d357600080fd5b6117db611767565b823567ffffffffffffffff808211156117f357600080fd5b9084019036601f83011261180657600080fd5b813560208282111561181a5761181a611625565b61182c601f8301601f19168201611790565b9250818352368183860101111561184257600080fd5b8181850182850137600081838501015282855261186081880161167b565b818601525050505060408301356040820152606083013560608201526080830135608082015280915050919050565b600060018060a01b038089168352808816602084015286604084015260c060608401526118bf60c084018761168b565b8381036080850152855160a082526118da60a083018261168b565b905082602088015116602083015260408701516040830152606087015160608301526080870151608083015280935050505082151560a0830152979650505050505050565b6001600160a01b03878116825260208201879052851660408201526060810184905260c0608082018190526000906119599083018561168b565b82810360a084015261196b818561168b565b9998505050505050505050565b6000806040838503121561198b57600080fd5b505080516020909101519092909150565b6000602082840312156119ae57600080fd5b8151611467816115a4565b634e487b7160e01b600052601160045260246000fd5b80820180821115610f2957610f296119b9565b81810381811115610f2957610f296119b956fea2646970667358221220f9746fb7993f60c1696510ba2b342ace3982f19e92d9116fc7f139af683c8cab64736f6c63430008150033",
  "deployedBytecode": "0x6080604052600436106100745760003560e01c80636e94a6291161004e5780636e94a629146100fc578063c04b8d591461011c578063db3e21981461012f578063f28c04981461014257600080fd5b806312210e8a14610080578063414bf3891461008a5780634b07dff0146100b057600080fd5b3661007b57005b600080fd5b610088610155565b005b61009d610098366004611587565b6101fe565b6040519081526020015b60405180910390f35b3480156100bc57600080fd5b506100e47f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100a7565b34801561010857600080fd5b506100886101173660046115b9565b6103eb565b61009d61012a3660046115e8565b610476565b61009d61013d366004611587565b610887565b61009d6101503660046115e8565b610a09565b47156101fc57604080516000808252602082019092523390479060405161017c919061165f565b60006040518083038185875af1925050503d80600081146101b9576040519150601f19603f3d011682016040523d82523d6000602084013e6101be565b606091505b50509050806101fa5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b60448201526064015b60405180910390fd5b505b565b600081608001354281101561022657604051639638793160e01b815260040160405180910390fd5b600061026e7f000000000000000000000000000000000000000000000000000000000000000061025c60408701602088016115b9565b61026960208801886115b9565b610cd3565b509050610299333060a087013561028860208901896115b9565b6001600160a01b0316929190610ddf565b6102a660208501856115b9565b60408051808201825260018152600160f81b60208201529051630200057560e51b81526001600160a01b039290921691634000aea0916102f091859160a08a0135916004016116b7565b6020604051808303816000875af115801561030f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033391906116de565b5061034460408501602086016115b9565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa15801561038a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ae9190611700565b92506103e46103c360808601606087016115b9565b846103d460408801602089016115b9565b6001600160a01b03169190610e4c565b5050919050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610432573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104569190611700565b90508015610472576104726001600160a01b0383163383610e4c565b5050565b600081604001354281101561049e57604051639638793160e01b815260040160405180910390fd5b6000806104e86104ae8680611719565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610e8292505050565b509150915060008061051b7f00000000000000000000000000000000000000000000000000000000000000008486610cd3565b90925090506105396001600160a01b038516333060608b0135610ddf565b604051636eb1769f60e11b81523060048201526001600160a01b03828116602483015285169063dd62ed3e90604401602060405180830381865afa158015610585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105a99190611700565b6000036106265760405163095ea7b360e01b81526001600160a01b038281166004830152600019602483015285169063095ea7b3906044016020604051808303816000875af1158015610600573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062491906116de565b505b61066d6106338880611719565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ebe92505050565b1561076257600061067d886117c1565b90506106c661068c8980611719565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ef892505050565b815260408051808201825260018152600160f81b60208201529051631a924e2960e31b81526001600160a01b0384169163d4927148916107179187918a9160608f013591889060009060040161188f565b6020604051808303816000875af1158015610736573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061075a9190611700565b96505061087d565b60408051808201825260018152600160f81b60208201529051630200057560e51b81526001600160a01b03861691634000aea0916107ab91869160608d013591906004016116b7565b6020604051808303816000875af11580156107ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107ee91906116de565b506040516370a0823160e01b81523060048201526001600160a01b038416906370a0823190602401602060405180830381865afa158015610833573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108579190611700565b955061087d61086c6040890160208a016115b9565b6001600160a01b0385169088610e4c565b5050505050919050565b60008160800135428110156108af57604051639638793160e01b815260040160405180910390fd5b6000806108f37f00000000000000000000000000000000000000000000000000000000000000006108e360208801886115b9565b6102696040890160208a016115b9565b9092509050341561091d5761090e82828760a0013534610f2f565b9350610918610155565b6109d9565b61093e828260a088013560c089013561093960208b018b6115b9565b611034565b60408051808201825260018152600160f81b60208201529051630bfab2e960e11b81529195506001600160a01b038316916317f565d29161098591869189916004016116b7565b6020604051808303816000875af11580156109a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c89190611700565b506109d961011760208701876115b9565b610a016109ec60808701606088016115b9565b60a08701356103d46040890160208a016115b9565b505050919050565b6000816040013542811015610a3157604051639638793160e01b815260040160405180910390fd5b6000610a3d8480611719565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250939450839250610a8491506104ae90508780611719565b5090925090506000610adb610ad6610a9c8980611719565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506111ad92505050565b610e82565b50915050600080610b0d7f00000000000000000000000000000000000000000000000000000000000000008587610cd3565b90925090503415610b3757610b2882828b6060013534610f2f565b9750610b32610155565b610c9f565b610b4c82828b606001358c6080013587611034565b9750610b5b6106338a80611719565b15610c0c57610b6d61068c8a80611719565b9550806001600160a01b0316635daf206a838a868d608001358b604051806040016040528060018152602001600160f81b8152506040518763ffffffff1660e01b8152600401610bc29695949392919061191f565b60408051808303816000875af1158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190611978565b509750610c96565b60408051808201825260018152600160f81b60208201529051630bfab2e960e11b81526001600160a01b038316916317f565d291610c519186918d91906004016116b7565b6020604051808303816000875af1158015610c70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c949190611700565b505b610c9f836103eb565b610cc7610cb260408b0160208c016115b9565b6001600160a01b0387169060608c0135610e4c565b50505050505050919050565b604051633b55df8560e11b81526001600160a01b038381166004830152828116602483015260009182918616906376abbf0a90604401602060405180830381865afa158015610d26573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4a919061199c565b91506001600160a01b038216610d73576040516325ef27af60e01b815260040160405180910390fd5b816001600160a01b031663777adcf06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610db1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dd5919061199c565b9050935093915050565b6040516001600160a01b038481166024830152838116604483015260648201839052610e469186918216906323b872dd906084015b604051602081830303815290604052915060e01b6020820180516001600160e01b0383818316178352505050506111ec565b50505050565b6040516001600160a01b03838116602483015260448201839052610e7d91859182169063a9059cbb90606401610e14565b505050565b60008080610e90848261124f565b9250610e9d8460146112b4565b9050610eb5610eae600360146119cf565b859061124f565b91509193909250565b6000610ecc600360146119cf565b6014610ed96003826119cf565b610ee391906119cf565b610eed91906119cf565b825110159050919050565b6060610f29610f09600360146119cf565b610f15600360146119cf565b8451610f2191906119e2565b84919061135f565b92915050565b60405163023536c560e21b81526004810183905260009081906001600160a01b038716906308d4db1490602401602060405180830381865afa158015610f79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9d9190611700565b60408051808201825260018152600160f81b6020820152905163020601bd60e11b81529192506001600160a01b0387169163040c037a918691610fe7918b918791906004016116b7565b604080518083038185885af1158015611004573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906110299190611978565b509695505050505050565b60405163023536c560e21b8152600481018490526000906001600160a01b038716906308d4db1490602401602060405180830381865afa15801561107c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a09190611700565b90506110b76001600160a01b038316333086610ddf565b604051636eb1769f60e11b81523060048201526001600160a01b03868116602483015283169063dd62ed3e90604401602060405180830381865afa158015611103573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111279190611700565b6000036111a45760405163095ea7b360e01b81526001600160a01b038681166004830152600019602483015283169063095ea7b3906044016020604051808303816000875af115801561117e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a291906116de565b505b95945050505050565b6060610f2960146111bf6003826119cf565b6111c991906119cf565b83516111d591906119e2565b60146111e26003826119cf565b610f2191906119cf565b60006112016001600160a01b0384168361146e565b9050805160001415801561122657508080602001905181019061122491906116de565b155b15610e7d57604051635274afe760e01b81526001600160a01b03841660048201526024016101f1565b600061125c8260146119cf565b835110156112a45760405162461bcd60e51b8152602060048201526015602482015274746f416464726573735f6f75744f66426f756e647360581b60448201526064016101f1565b500160200151600160601b900490565b6000816112c28160036119cf565b10156113045760405162461bcd60e51b8152602060048201526011602482015270746f55696e7432345f6f766572666c6f7760781b60448201526064016101f1565b61130f8260036119cf565b835110156113565760405162461bcd60e51b8152602060048201526014602482015273746f55696e7432345f6f75744f66426f756e647360601b60448201526064016101f1565b50016003015190565b60608161136d81601f6119cf565b10156113ac5760405162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b60448201526064016101f1565b6113b682846119cf565b845110156113fa5760405162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b60448201526064016101f1565b6060821580156114195760405191506000825260208201604052611463565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561145257805183526020928301920161143a565b5050858452601f01601f1916604052505b5090505b9392505050565b6060611467838360006060825160001415801561149357506001600160a01b0384163b155b156114bc57604051639eb1341360e01b81526001600160a01b03851660048201526024016101f1565b600080856001600160a01b031684866040516114d8919061165f565b60006040518083038185875af1925050503d8060008114611515576040519150601f19603f3d011682016040523d82523d6000602084013e61151a565b606091505b5091509150811561152e5791506114679050565b80511561153d57805160208201fd5b60405162461bcd60e51b815260206004820152600660248201526519985a5b195960d21b60448201526064016101f1565b6000610100828403121561158157600080fd5b50919050565b6000610100828403121561159a57600080fd5b611467838361156e565b6001600160a01b03811681146101fa57600080fd5b6000602082840312156115cb57600080fd5b8135611467816115a4565b600060a0828403121561158157600080fd5b6000602082840312156115fa57600080fd5b813567ffffffffffffffff81111561161157600080fd5b61161d848285016115d6565b949350505050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561165657818101518382015260200161163e565b50506000910152565b6000825161167181846020870161163b565b9190910192915050565b8035611686816115a4565b919050565b600081518084526116a381602086016020860161163b565b601f01601f19169290920160200192915050565b60018060a01b03841681528260208201526060604082015260006111a4606083018461168b565b6000602082840312156116f057600080fd5b8151801515811461146757600080fd5b60006020828403121561171257600080fd5b5051919050565b6000808335601e1984360301811261173057600080fd5b83018035915067ffffffffffffffff82111561174b57600080fd5b60200191503681900382131561176057600080fd5b9250929050565b60405160a0810167ffffffffffffffff8111828210171561178a5761178a611625565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156117b9576117b9611625565b604052919050565b600060a082360312156117d357600080fd5b6117db611767565b823567ffffffffffffffff808211156117f357600080fd5b9084019036601f83011261180657600080fd5b813560208282111561181a5761181a611625565b61182c601f8301601f19168201611790565b9250818352368183860101111561184257600080fd5b8181850182850137600081838501015282855261186081880161167b565b818601525050505060408301356040820152606083013560608201526080830135608082015280915050919050565b600060018060a01b038089168352808816602084015286604084015260c060608401526118bf60c084018761168b565b8381036080850152855160a082526118da60a083018261168b565b905082602088015116602083015260408701516040830152606087015160608301526080870151608083015280935050505082151560a0830152979650505050505050565b6001600160a01b03878116825260208201879052851660408201526060810184905260c0608082018190526000906119599083018561168b565b82810360a084015261196b818561168b565b9998505050505050505050565b6000806040838503121561198b57600080fd5b505080516020909101519092909150565b6000602082840312156119ae57600080fd5b8151611467816115a4565b634e487b7160e01b600052601160045260246000fd5b80820180821115610f2957610f296119b9565b81810381811115610f2957610f296119b956fea2646970667358221220f9746fb7993f60c1696510ba2b342ace3982f19e92d9116fc7f139af683c8cab64736f6c63430008150033",
  "devdoc": {
    "author": "Bernhard Ruf, bernhard@aktionariat.com ",
    "errors": {
      "Address_NotTransferNorContract(address)": [
        {
          "params": {
            "target": "Target address to call the function on."
          }
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC20 token failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "exactInput((bytes,address,uint256,uint256,uint256))": {
        "params": {
          "params": "The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata."
        },
        "returns": {
          "amountOut": "The amount of the received token"
        }
      },
      "exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))": {
        "details": "Only use it for selling shares, else there will be no brokerbot found. Output can't be ETH you have to swap WETH to ETH on your integration.",
        "params": {
          "params": "The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata."
        },
        "returns": {
          "amountOut": "The amountOut actually received."
        }
      },
      "exactOutput((bytes,address,uint256,uint256,uint256))": {
        "details": "If ETH is sent this function will try to swap ETH for share tokens directly and will ignore the path.",
        "params": {
          "params": "Params struct for swap. See @ISwapRouter for struct definition."
        },
        "returns": {
          "amountIn": "The amountIn actually spent."
        }
      },
      "exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))": {
        "details": "not usable to sell shares for excact output, as shares is not divisible (decimals is 0).Single swap with ETH works, but base currency address has to be provided as tokenIn.",
        "params": {
          "params": "Params struct for swap. See @ISwapRouter for struct definition."
        }
      },
      "refundETH()": {
        "details": "Remember to call this function if you make a swap with ETH."
      }
    },
    "title": "Brokerbot Swap Router",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "exactInput((bytes,address,uint256,uint256,uint256))": {
        "notice": "Sell `amountIn` of share tokens for as much as possible of another along the specified path."
      },
      "exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))": {
        "notice": "Sell `amountIn` of share tokens for base currency."
      },
      "exactOutput((bytes,address,uint256,uint256,uint256))": {
        "notice": "Buy share tokens with any erc20 by given a uniswap routing path"
      },
      "exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))": {
        "notice": "Buy share tokens with base currency."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}