{
  "language": "Solidity",
  "sources": {
    "src/draggable/IDraggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IOffer.sol\";\ninterface IDraggable {\n    \n    function wrapped() external view returns (IERC20);\n    function unwrap(uint256 amount) external;\n    function offer() external view returns (IOffer);\n    function oracle() external view returns (address);\n    function drag(address buyer, IERC20 currency) external;\n    function notifyOfferEnded() external;\n    function votingPower(address voter) external returns (uint256);\n    function totalVotingTokens() external view returns (uint256);\n    function notifyVoted(address voter) external;\n    function setTerms(string calldata _terms) external;\n\n}"
    },
    "src/draggable/IOffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IOffer {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n  //////////////////////////////////////////////////////////////*/\n\t/// Invalid msg.sender.\n\t/// @param sender The msg.sender of the transaction.\n\terror Offer_InvalidSender(address sender);\n\t/// Offer needs to be still open.\n\terror Offer_AlreadyAccepted();\n\t/// Offer needs to be not accepted yet.\n\terror Offer_NotAccepted();\n\t/// Sender of the offer needs to have needed funds in his account.\n\terror Offer_NotWellFunded();\n\t/// New offer not valid. `newPrice` needs to be higher than `oldPrice`.\n\t/// @param oldPrice Price of the old offer.\n\t/// @param newPrice Price of the new offer.\n\terror Offer_OldOfferBetter(uint256 oldPrice, uint256 newPrice);\n\t/// Voting needs to be still open.\n\terror Offer_VotingEnded();\n\t/// Too many (External) reported votes. `reportedVotes` needs to be less or equal to `maxVotes`.\n\t/// @param maxVotes The max possible votes for the token.\n\t/// @param reportedVotes The external reported votes + circulating supply of the token.\n\terror Offer_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\n\t/// Competing offer needs to be in the same currency.\n\terror Offer_OfferInWrongCurrency();\n\t/// Offer got already killed.\n\terror Offer_IsKilled();\n\n\t/*//////////////////////////////////////////////////////////////\n                            Function Interfaces\n\t//////////////////////////////////////////////////////////////*/\n\n\tfunction makeCompetingOffer(IOffer newOffer) external;\n\n\t// if there is a token transfer while an offer is open, the votes get transfered too\n\tfunction notifyMoved(address from, address to, uint256 value) external;\n\n\tfunction currency() external view returns (IERC20);\n\n\tfunction price() external view returns (uint256);\n\n\tfunction isWellFunded() external view returns (bool);\n\n\tfunction voteYes() external;\n\n\tfunction voteNo() external;\n\n\tfunction isKilled() external view returns (bool);\n}"
    },
    "src/draggable/IOfferFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IOffer.sol\";\n\ninterface IOfferFactory {\n\n\tfunction create(\n\t\tbytes32 salt, address buyer, uint256 pricePerShare,\tIERC20 currency,\tuint256 quorum,\tuint256 votePeriod\n\t) external payable returns (IOffer);\n}"
    },
    "src/draggable/Offer.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IDraggable.sol\";\nimport \"./IOffer.sol\";\nimport \"../utils/SafeERC20.sol\";\n/**\n * @title A public offer to acquire all tokens\n * @author Luzius Meisser, luzius@aktionariat.com\n */\ncontract Offer is IOffer {\n    using SafeERC20 for IERC20;\n\n    address private constant LICENSE_FEE_ADDRESS = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D;\n\n    uint256 private constant AQUISITION_GRACE_PERIOD = 30 days;     // buyer has thirty days to complete acquisition after voting ends\n    \n    uint256 private constant BPS_MUL = 10000;           // basis point multiplier to be used with quorum\n\n    uint256 public immutable quorum;                    // Percentage of votes needed to start drag-along process in BPS, i.e. 10'000 = 100%\n\n    IDraggable public immutable token;\n    address public immutable buyer;                     // who made the offer\n    \n    IERC20 override public immutable currency;\n    uint256 override public immutable price;            // the price offered per share\n\n    enum Vote { NONE, YES, NO }                         // Used internally, represents not voted yet or yes/no vote.\n    mapping (address => Vote) private votes;            // Who votes what\n    uint256 public yesVotes;                            // total number of yes votes, including external votes\n    uint256 public noVotes;                             // total number of no votes, including external votes\n    uint256 public noExternal;                          // number of external no votes reported by oracle\n    uint256 public yesExternal;                         // number of external yes votes reported by oracle\n\n    uint256 public immutable voteEnd;                   // end of vote period in block time (seconds after 1.1.1970)\n\n    bool public isKilled;                                      // indicator that contract disabled (replaces selfdestruct)\n    bool public isWE;\n\n    event VotesChanged(uint256 yesVotes, uint256 noVotes);\n    event OfferCreated(address indexed buyer, IDraggable indexed token, uint256 pricePerShare, IERC20 indexed currency);\n    event OfferEnded(address indexed buyer, bool executed, string message);\n\n    // Not checked here, but buyer should make sure it is well funded from the beginning\n    constructor(\n        address _buyer,\n        IDraggable _token,\n        uint256 _price,\n        IERC20 _currency,\n        uint256 _quorum,\n        uint256 _votePeriod\n    ) \n        payable \n    {\n        buyer = _buyer;\n        token = _token;\n        currency = _currency;\n        price = _price;\n        quorum = _quorum;\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        voteEnd = block.timestamp + _votePeriod;\n        emit OfferCreated(_buyer, _token, _price, _currency);\n        // License Fee to Aktionariat AG, also ensures that offer is serious.\n        // Any circumvention of this license fee payment is a violation of the copyright terms.\n        payable(LICENSE_FEE_ADDRESS).transfer(3 ether);\n    }\n\n    modifier onlyBuyer {\n        _checkSender(buyer);\n        _;\n    }\n\n    modifier onlyToken {\n        _checkSender(address(token));\n        _;\n    }\n\n    modifier onlyOracle {\n        _checkSender(token.oracle());\n        _;\n    }\n\n    modifier votingOpen {\n        if (!isVotingOpen()) {\n            revert Offer_VotingEnded();\n        }\n        _;\n    }\n\n    function makeCompetingOffer(IOffer betterOffer) external override onlyToken {\n        if (isAccepted()) {\n            revert Offer_AlreadyAccepted();\n        }\n        uint256 newPrice = betterOffer.price();\n        if (newPrice <= price) {\n            revert Offer_OldOfferBetter(price, newPrice);\n        }\n        if (currency != betterOffer.currency()) {\n            revert Offer_OfferInWrongCurrency();\n        }\n        if (!betterOffer.isWellFunded()) {\n            revert Offer_NotWellFunded();\n        }\n        kill(false, \"replaced\");\n    }\n\n    function hasExpired() internal view returns (bool) {\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > voteEnd + AQUISITION_GRACE_PERIOD; \n    }\n\n    function contest() external {\n        if (hasExpired()) {\n            kill(false, \"expired\");\n        } else if (isDeclined()) {\n            kill(false, \"declined\");\n        } else if (!isWellFunded()) {\n            kill(false, \"lack of funds\");\n        }\n    }\n\n    function cancel() external onlyBuyer {\n        kill(false, \"cancelled\");\n    }\n\n    function execute() external onlyBuyer {\n        if (isKilled) revert Offer_IsKilled();\n        if (!isAccepted()) revert Offer_NotAccepted();\n        uint256 totalPrice = getTotalPrice();\n        currency.safeTransferFrom(buyer, address(token), totalPrice);\n        token.drag(buyer, currency);\n        kill(true, \"success\");\n    }\n\n    function getTotalPrice() internal view returns (uint256) {\n        IERC20 tok = IERC20(address(token));\n        return (tok.totalSupply() - tok.balanceOf(buyer)) * price;\n    }\n\n    function isWellFunded() public view override returns (bool) {\n        uint256 buyerBalance = currency.balanceOf(buyer);\n        uint256 totalPrice = getTotalPrice();\n        return totalPrice <= buyerBalance;\n    }\n\n    function isAccepted() public view returns (bool) {\n        if (isVotingOpen()) {\n            // is it already clear that more than the quorum requiered will vote yes even though the vote is not over yet?\n            return yesVotes * BPS_MUL  >= quorum * token.totalVotingTokens();\n        } else {\n            // did more than the quorum requiered votes say 'yes'?\n            return yesVotes * BPS_MUL >= quorum * (yesVotes + noVotes);\n        }\n    }\n\n    function isDeclined() public view returns (bool) {\n        if (isVotingOpen()) {\n            // is it already clear that 25% will vote no even though the vote is not over yet?\n            uint256 supply = token.totalVotingTokens();\n            return (supply - noVotes) * BPS_MUL < quorum * supply;\n        } else {\n            // did quorum% of all cast votes say 'no'?\n            return BPS_MUL * yesVotes < quorum * (yesVotes + noVotes);\n        }\n    }\n\n    function notifyMoved(address from, address to, uint256 value) external override onlyToken {\n        if (isVotingOpen()) {\n            Vote fromVoting = votes[from];\n            Vote toVoting = votes[to];\n            update(fromVoting, toVoting, value);\n        }\n    }\n\n    function update(Vote previousVote, Vote newVote, uint256 votes_) internal {\n        if (previousVote != newVote) {\n            if (previousVote == Vote.NO) {\n                noVotes -= votes_;\n            } else if (previousVote == Vote.YES) {\n                yesVotes -= votes_;\n            }\n            if (newVote == Vote.NO) {\n                noVotes += votes_;\n            } else if (newVote == Vote.YES) {\n                yesVotes += votes_;\n            }\n            emit VotesChanged(yesVotes, noVotes);\n        }\n    }\n\n    function isVotingOpen() public view returns (bool) {\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp <= voteEnd && !isKilled;\n    }\n\n    /**\n     * Function to allow the oracle to report the votes of external votes (e.g. shares tokenized on other blockchains).\n     * This functions is idempotent and sets the number of external yes and no votes. So when more votes come in, the\n     * oracle should always report the total number of yes and no votes. Abstentions are not counted.\n     */\n    function reportExternalVotes(uint256 yes, uint256 no) external onlyOracle votingOpen {\n        uint256 maxVotes = token.totalVotingTokens();\n        uint256 reportingVotes = yes + no + IERC20(address(token)).totalSupply();\n        if (reportingVotes > maxVotes) {\n            revert Offer_TooManyVotes(maxVotes, reportingVotes);\n        }\n        // adjust total votes taking into account that the oralce might have reported different counts before\n        yesVotes = yesVotes - yesExternal + yes;\n        noVotes = noVotes - noExternal + no;\n        // remember how the oracle voted in case the oracle later reports updated numbers\n        yesExternal = yes;\n        noExternal = no;\n    }\n\n    function voteYes() external override{\n        vote(Vote.YES);\n    }\n\n    function voteNo() external override{ \n        vote(Vote.NO);\n    }\n\n    function vote(Vote newVote) internal votingOpen {\n        Vote previousVote = votes[msg.sender];\n        votes[msg.sender] = newVote;\n        if(previousVote == Vote.NONE){\n            token.notifyVoted(msg.sender);\n        }\n        update(previousVote, newVote, token.votingPower(msg.sender));\n    }\n\n    function hasVotedYes(address voter) external view returns (bool) {\n        return votes[voter] == Vote.YES;\n    }\n\n    function hasVotedNo(address voter) external view returns (bool) {\n        return votes[voter] == Vote.NO;\n    }\n\n    function kill(bool executed, string memory message) internal {\n        isKilled = true;\n        emit OfferEnded(buyer, executed, message);\n        token.notifyOfferEnded();\n        payable(buyer).call{value:address(this).balance}(\"\");       // buyer is responsible to be able to receive Ether, else he can block cancellation\n    }\n\n    /**\n     * Checks if msg.sender is an authorized address.\n     * @param validSender The authorized address.\n     */\n    function _checkSender(address validSender) internal view {\n        if (msg.sender != validSender) {\n            revert Offer_InvalidSender(msg.sender);\n        }\n    }\n\n}"
    },
    "src/draggable/OfferFactory.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./Offer.sol\";\nimport \"./IOffer.sol\";\nimport \"./IOfferFactory.sol\";\n\ncontract OfferFactory is IOfferFactory{\n\n    // It must be possible to predict the address of the offer so one can pre-fund the allowance.\n    function predictOfferAddress(bytes32 salt, address buyer, IDraggable token, uint256 pricePerShare, IERC20 currency, uint256 quorum, uint256 votePeriod) external view returns (address) {\n        bytes32 initCodeHash = keccak256(abi.encodePacked(type(Offer).creationCode, abi.encode(buyer, token, pricePerShare, currency, quorum, votePeriod)));\n        bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash));\n        return address(uint160(uint256(hashResult)));\n    }\n\n    // Do not call directly, msg.sender must be the token to be acquired\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, IERC20 currency, uint256 quorum, uint256 votePeriod) override external payable returns (IOffer) {\n        IOffer offer = new Offer{value: msg.value, salt: salt}(buyer, IDraggable(msg.sender), pricePerShare, currency, quorum, votePeriod);\n        return offer;\n    }\n}"
    },
    "src/ERC20/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "src/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit is IERC20 {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    "src/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n\n    /// @param target Target address to call the function on.\n    error Address_NotTransferNorContract(address target);\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n        return account.code.length > 0;\n    }\n    \n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\n        if (data.length != 0 && !isContract(target)) {\n            revert Address_NotTransferNorContract(target);\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            assembly{\n                revert (add (returndata, 0x20), mload (returndata))\n            }\n        } else {\n           revert(\"failed\");\n        }\n    }\n}"
    },
    "src/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"../ERC20/IERC20Permit.sol\";\nimport {Address} from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}